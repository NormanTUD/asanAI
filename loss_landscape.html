<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>TFJS Loss-Landscape & Optimizer-Trajektorien (Dynamisch)</title>
    <script src="tf/tf.min.js"></script>
    <script src="libs/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="loss_landscape.css">
</head>
<body>
    <h1>TFJS Loss-Landscape & Optimizer-Trajektorien (Dynamisch)</h1>

    <div class="controls">
        <div class="control-group">
            <h3>üî¢ Daten (x, y Paare)</h3>
            <label for="dataInput">x-Werte (kommagetrennt):</label>
            <textarea id="dataInput">0, 1, 2, 3, 4</textarea>
            <label for="dataOutput">y-Werte (kommagetrennt):</label>
            <textarea id="dataOutput">1.0, 3.0, 5.0, 7.0, 9.0</textarea>

            <div class="example-buttons">
                <button onclick="loadExample('linear')">Linie (y=2x+1)</button>
                <button onclick="loadExample('parabola')">Parabel (y=x¬≤)</button>
                <button onclick="loadExample('sinus')">Sinuswelle (komplex)</button>
            </div>
        </div>

        <div class="control-group">
            <h3>‚öôÔ∏è Allgemeine Parameter</h3>
            <label for="epochs">Epochen:</label>
            <input type="number" id="epochs" value="50" min="1" max="1000">

            <label for="steps">Puffer (N) f√ºr Landschaftsrand:</label>
            <input type="number" id="steps" value="3" min="0" max="10">

             <div class="control-group" style="align-self: flex-end; margin-top: 20px;">
                <button id="startButton" onclick="startExperiment()">Experiment starten</button>
                <button id="stopButton" onclick="stopExperiment()">Experiment stoppen</button>
            </div>
        </div>

        <div class="control-group" style="min-width: 300px;">
            <h3>ü§ñ Optimizer-Auswahl</h3>
            <div id="optimizer-checkboxes" class="optimizer-selection">
                </div>
            <div id="optimizer-options-container">
                Bitte w√§hlen Sie einen Optimizer, um seine spezifischen Parameter anzuzeigen.
            </div>
        </div>
    </div>

    <div id="status">Bereit. Bitte starten Sie das Experiment.</div>

    <div class="plot-container" id="plot-container">
    </div>

<script>
    // ***********************************************
    // I. Globale Konfiguration & Zustand
    // ***********************************************

    const PLOT_DENSITY_STEP = 0.1;
    // Definitionen der Optimizer mit ihren Parametern und Standardwerten
    const OPTIMIZER_CONFIGS = {
        'SGD': {
            factory: (params) => tf.train.sgd(params.learningRate),
            params: [{ name: 'learningRate', label: 'Lernrate (LR)', default: 0.01, min: 0.0001, max: 1, step: 0.001 }],
            defaults: { learningRate: 0.01 }
        },
        'Momentum': {
            factory: (params) => tf.train.momentum(params.learningRate, params.momentum, params.useNesterov === 'true'),
            params: [
                { name: 'learningRate', label: 'Lernrate (LR)', default: 0.01, min: 0.0001, max: 1, step: 0.001 },
                { name: 'momentum', label: 'Momentum', default: 0.9, min: 0.0, max: 1.0, step: 0.1 },
                { name: 'useNesterov', label: 'Nesterov verwenden?', type: 'select', options: [{ value: 'false', text: 'Nein' }, { value: 'true', text: 'Ja' }], default: 'false' }
            ],
            defaults: { learningRate: 0.01, momentum: 0.9, useNesterov: 'false' }
        },
        'Adagrad': {
            factory: (params) => tf.train.adagrad(params.learningRate, params.initialAccumulatorValue),
            params: [
                { name: 'learningRate', label: 'Lernrate (LR)', default: 0.01, min: 0.0001, max: 1, step: 0.001 },
                { name: 'initialAccumulatorValue', label: 'Init. Akku-Wert', default: 0.1, min: 0.0, max: 1.0, step: 0.01 }
            ],
            defaults: { learningRate: 0.01, initialAccumulatorValue: 0.1 }
        },
        'Adadelta': {
            factory: (params) => tf.train.adadelta(params.learningRate, params.rho, params.epsilon),
            params: [
                { name: 'learningRate', label: 'Lernrate (LR)', default: 1.0, min: 0.0001, max: 10, step: 0.1 },
                { name: 'rho', label: 'Rho (Verfall)', default: 0.95, min: 0.0, max: 1.0, step: 0.01 },
                { name: 'epsilon', label: 'Epsilon (Stab.)', default: 1e-8, min: 1e-9, max: 1e-6, step: 1e-9 }
            ],
            defaults: { learningRate: 1.0, rho: 0.95, epsilon: 1e-8 }
        },
        'Adam': {
            factory: (params) => tf.train.adam(params.learningRate, params.beta1, params.beta2, params.epsilon),
            params: [
                { name: 'learningRate', label: 'Lernrate (LR)', default: 0.001, min: 0.0001, max: 1, step: 0.0001 },
                { name: 'beta1', label: 'Beta1 (M1 Verf.)', default: 0.9, min: 0.0, max: 1.0, step: 0.01 },
                { name: 'beta2', label: 'Beta2 (M2 Verf.)', default: 0.999, min: 0.0, max: 1.0, step: 0.001 },
                { name: 'epsilon', label: 'Epsilon (Stab.)', default: 1e-8, min: 1e-9, max: 1e-6, step: 1e-9 }
            ],
            defaults: { learningRate: 0.001, beta1: 0.9, beta2: 0.999, epsilon: 1e-8 }
        },
        'Adamax': {
            factory: (params) => tf.train.adamax(params.learningRate, params.beta1, params.beta2, params.epsilon, params.decay),
            params: [
                { name: 'learningRate', label: 'Lernrate (LR)', default: 0.002, min: 0.0001, max: 1, step: 0.0001 },
                { name: 'beta1', label: 'Beta1 (M1 Verf.)', default: 0.9, min: 0.0, max: 1.0, step: 0.01 },
                { name: 'beta2', label: 'Beta2 (M2 Verf.)', default: 0.999, min: 0.0, max: 1.0, step: 0.001 },
                { name: 'epsilon', label: 'Epsilon (Stab.)', default: 1e-8, min: 1e-9, max: 1e-6, step: 1e-9 },
                { name: 'decay', label: 'Verfall', default: 0.0, min: 0.0, max: 0.1, step: 0.001 }
            ],
            defaults: { learningRate: 0.002, beta1: 0.9, beta2: 0.999, epsilon: 1e-8, decay: 0.0 }
        },
        'RMSProp': {
            factory: (params) => tf.train.rmsprop(params.learningRate, params.decay, params.momentum, params.epsilon, params.centered === 'true'),
            params: [
                { name: 'learningRate', label: 'Lernrate (LR)', default: 0.001, min: 0.0001, max: 1, step: 0.0001 },
                { name: 'decay', label: 'Verfall', default: 0.9, min: 0.0, max: 1.0, step: 0.01 },
                { name: 'momentum', label: 'Momentum', default: 0.0, min: 0.0, max: 1.0, step: 0.1 },
                { name: 'epsilon', label: 'Epsilon (Stab.)', default: 1e-10, min: 1e-11, max: 1e-8, step: 1e-11 },
                { name: 'centered', label: 'Zentriert?', type: 'select', options: [{ value: 'false', text: 'Nein' }, { value: 'true', text: 'Ja' }], default: 'false' }
            ],
            defaults: { learningRate: 0.001, decay: 0.9, momentum: 0.0, epsilon: 1e-10, centered: 'false' }
        },
    };

    let experimentRunning = false;
    let stopRequested = false;

    let lossCache = {};
    let currentLandscapeBounds = { minW: 0, maxW: 0, minB: 0, maxB: 0 };
    let currentLandscapeData = { W: [], B: [], L: [] };
    let plotInstances = {};

    // NEUE FUNKTION: Beispiel-Daten laden
    function loadExample(type) {
        const xInput = document.getElementById('dataInput');
        const yInput = document.getElementById('dataOutput');

        let xs, ys;

        // Setze Parameter nur, wenn sie nicht bereits durch den Benutzer angepasst wurden
        const setParamDefault = (id, value) => {
            const el = document.getElementById(id);
            if (el && (el.value === el.dataset.initialValue || el.value === '')) {
                 el.value = value;
                 el.dataset.initialValue = value;
            } else if (el) {
                 // Speichere den aktuellen Wert, falls er ge√§ndert wurde
                 el.dataset.initialValue = el.value;
            }
        };

        switch(type) {
            case 'linear':
                // y = 2x + 1 (Perfekte Lineare Regression)
                xs = Array.from({length: 11}, (_, i) => i - 5); // -5 bis 5
                ys = xs.map(x => 2 * x + 1);
                // Setze Parameter f√ºr schnelle Konvergenz
                setParamDefault('epochs', '50');
                setParamDefault('steps', '3');
                break;
            case 'parabola':
                // y = x^2 + 5 (Breiter Loss-Krater erwartet)
                xs = Array.from({length: 21}, (_, i) => (i - 10) / 2.0); // -5.0 bis 5.0
                ys = xs.map(x => x * x + 5);
                 // Setze Parameter f√ºr Erkundung
                setParamDefault('epochs', '100');
                setParamDefault('steps', '5');
                break;
            case 'sinus':
                // Komplexere, nicht-lineare Daten
                xs = Array.from({length: 30}, (_, i) => i * 0.4); // 0 bis 11.6
                ys = xs.map(x => Math.sin(x) * x + 5);
                 // Setze Parameter f√ºr Exploration
                setParamDefault('epochs', '200');
                setParamDefault('steps', '7');
                break;
            default:
                return;
        }

        xInput.value = xs.map(n => n.toFixed(1)).join(', ');
        yInput.value = ys.map(n => n.toFixed(3)).join(', ');

        document.getElementById('status').innerText = `Beispieldaten f√ºr '${type}' geladen.`;

        // Update der Optimizer-Optionen, um die Standard-LR zu aktualisieren
        updateOptimizerOptions();
    }
    window.loadExample = loadExample; // Macht die Funktion global zug√§nglich f√ºr onclick

    function parseData() {
        try {
            const xStr = document.getElementById('dataInput').value;
            const yStr = document.getElementById('dataOutput').value;

            const xsArray = xStr.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
            const ysArray = yStr.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));

            if (xsArray.length !== ysArray.length || xsArray.length === 0) {
                throw new Error("X- und Y-Daten m√ºssen die gleiche Anzahl g√ºltiger Zahlen enthalten.");
            }

            const xs = tf.tensor2d(xsArray.map(x => [x]));
            const ys = tf.tensor2d(ysArray.map(y => [y]));

            return { xs, ys, N_DATA_POINTS: xsArray.length };
        } catch (error) {
            document.getElementById('status').innerText = `Fehler beim Parsen der Daten: ${error.message}`;
            throw error;
        }
    }

    function initializeOptimizerCheckboxes() {
        const container = document.getElementById('optimizer-checkboxes');
        container.innerHTML = '';

        for (const name in OPTIMIZER_CONFIGS) {
            const id = `opt-${name}`;
            const label = document.createElement('label');

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = id;
            checkbox.name = 'optimizer';
            checkbox.value = name;
            checkbox.onchange = updateOptimizerOptions; // Wichtig: Beim √Ñndern der Auswahl die Optionen aktualisieren

            if (['SGD', 'Adam', 'RMSProp'].includes(name)) {
                checkbox.checked = true;
            }

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(name));
            container.appendChild(label);
        }
        updateOptimizerOptions(); // Initial die Optionen setzen
    }

    /**
     * Erzeugt dynamisch die Eingabefelder f√ºr die Parameter der ausgew√§hlten Optimizer.
     */
    function updateOptimizerOptions() {
        const container = document.getElementById('optimizer-options-container');
        container.innerHTML = '';

        const selectedOptimizers = Array.from(document.querySelectorAll('input[name="optimizer"]:checked'))
                                       .map(checkbox => checkbox.value);

        if (selectedOptimizers.length === 0) {
            container.innerHTML = 'Bitte w√§hlen Sie mindestens einen Optimizer aus.';
            return;
        }

        // Sammle alle eindeutigen Parameter √ºber alle ausgew√§hlten Optimierer
        const uniqueParams = {};
        for (const name of selectedOptimizers) {
            const config = OPTIMIZER_CONFIGS[name];
            for (const param of config.params) {
                if (!uniqueParams[param.name]) {
                    uniqueParams[param.name] = { ...param, optimizers: [name] };
                } else {
                    uniqueParams[param.name].optimizers.push(name);
                }
            }
        }

        // Sortiere f√ºr bessere Lesbarkeit
        const sortedParams = Object.values(uniqueParams).sort((a, b) => {
             // LR zuerst, dann der Rest alphabetisch
             if (a.name === 'learningRate') return -1;
             if (b.name === 'learningRate') return 1;
             return a.name.localeCompare(b.name);
        });

        // Generiere die Steuerelemente
        for (const param of sortedParams) {
            const paramGroup = document.createElement('div');
            paramGroup.className = 'param-group';

            const description = document.createElement('p');
            description.innerText = `${param.label} (${param.name}) f√ºr: ${param.optimizers.join(', ')}`;
            paramGroup.appendChild(description);

            const label = document.createElement('label');
            label.setAttribute('for', `param-${param.name}`);

            if (param.type === 'select') {
                const select = document.createElement('select');
                select.id = `param-${param.name}`;
                select.name = `param-${param.name}`;
                select.dataset.default = param.default;

                for (const option of param.options) {
                    const optEl = document.createElement('option');
                    optEl.value = option.value;
                    optEl.text = option.text;
                    if (option.value.toString() === param.default.toString()) {
                        optEl.selected = true;
                    }
                    select.appendChild(optEl);
                }
                label.appendChild(select);
            } else {
                // Typ: number (Standard)
                const input = document.createElement('input');
                input.type = 'number';
                input.id = `param-${param.name}`;
                input.name = `param-${param.name}`;
                input.value = param.default;
                input.min = param.min;
                input.max = param.max;
                input.step = param.step;
                input.dataset.default = param.default;
                label.appendChild(input);
            }

            paramGroup.appendChild(label);
            container.appendChild(paramGroup);
        }
    }
    window.onload = initializeOptimizerCheckboxes; // F√ºge onload hinzu

    window.onresize = () => {
        const plotDivs = document.querySelectorAll('.plot-div');
        plotDivs.forEach(div => {
            Plotly.relayout(div.id, {
                width: div.clientWidth,
                height: div.clientHeight
            });
        });
    };

    // ***********************************************
    // II. Modell & Loss-Berechnung (mit Caching)
    // ***********************************************

    function createSimpleModel() {
        const model = tf.sequential();
        model.add(tf.layers.dense({
            units: 1,
            inputShape: [1],
            kernelInitializer: tf.initializers.constant({ value: 0.1 }),
            biasInitializer: tf.initializers.constant({ value: -0.1 }),
        }));

        return model;
    }

    /**
     * Berechnet den Loss f√ºr gegebene Gewichte (w, b).
     * Stellt sicher, dass der Loss > 0 ist (f√ºr die log-Achse).
     */
    function calculateLoss(w, b, xs, ys, N_DATA_POINTS) {
        // Schl√ºssel f√ºr das 0.1-Raster-Gitter (f√ºr die Landscape-Oberfl√§che)
        const wKeyGrid = parseFloat(w.toFixed(1));
        const bKeyGrid = parseFloat(b.toFixed(1));
        const cacheKeyGrid = `${wKeyGrid},${bKeyGrid}`;

        // Schl√ºssel f√ºr den genauen Trajektorienpunkt (w, b sind hier die genauen Werte)
        const wKeyExact = w;
        const bKeyExact = b;
        // Speichere Trajektorienpunkte mit 4 Nachkommastellen unter einem 'E'-Prefix
        const cacheKeyExact = `E${wKeyExact.toFixed(4)},${bKeyExact.toFixed(4)}`;

        // 1. Pr√ºfe den exakten Schl√ºssel
        if (lossCache.hasOwnProperty(cacheKeyExact)) {
            return lossCache[cacheKeyExact];
        }

        const rawResult = tf.tidy(() => {
            const weights = tf.tensor2d([[w]]);
            const bias = tf.tensor1d([b]);

            const tempModel = createSimpleModel();
            tempModel.layers[0].setWeights([weights, bias]);

            tempModel.compile({ optimizer: 'sgd', loss: 'meanSquaredError' });

            const lossTensor = tempModel.evaluate(xs, ys, { batchSize: N_DATA_POINTS, verbose: 0 });

            const result = (Array.isArray(lossTensor)) ? lossTensor[0].dataSync()[0] : lossTensor.dataSync()[0];

            weights.dispose();
            bias.dispose();
            tempModel.dispose();

            return result; // Dies ist der rohe, berechnete Loss (kann 0 sein)
        });

        // FIX: Sicherstellen, dass Loss > 0 f√ºr die log-Achse
        const loss = Math.max(rawResult, 1e-8); // Erzwinge einen Mindestwert von 0.00000001

        // Speichere den genauen Wert im Cache (wichtig f√ºr den Trajektorienstartpunkt)
        lossCache[cacheKeyExact] = loss;

        // Speichere den Raster-Wert, wenn der Punkt exakt auf dem Raster liegt.
        if (wKeyExact.toFixed(1) === wKeyGrid.toFixed(1) && bKeyExact.toFixed(1) === bKeyGrid.toFixed(1)) {
             lossCache[cacheKeyGrid] = loss;
        }

        return loss;
    }

    // ***********************************************
    // III. Loss-Landscape Berechnung (Dynamisch & Non-Blocking)
    // ***********************************************

    function computeNewLossPoints(newMinW, newMaxW, newMinB, newMaxB, data) {
        return new Promise(resolve => {
            if (stopRequested) return resolve();

            // Rasterpunkte definieren
            const W_START_GRID = parseFloat(Math.floor(newMinW / PLOT_DENSITY_STEP) * PLOT_DENSITY_STEP).toFixed(1);
            const W_END_GRID = parseFloat(Math.ceil(newMaxW / PLOT_DENSITY_STEP) * PLOT_DENSITY_STEP).toFixed(1);
            const B_START_GRID = parseFloat(Math.floor(newMinB / PLOT_DENSITY_STEP) * PLOT_DENSITY_STEP).toFixed(1);
            const B_END_GRID = parseFloat(Math.ceil(newMaxB / PLOT_DENSITY_STEP) * PLOT_DENSITY_STEP).toFixed(1);
            const STEP_SIZE = PLOT_DENSITY_STEP;

            const pointsToProcess = [];
            for (let b = parseFloat(B_START_GRID); b <= parseFloat(B_END_GRID); b = parseFloat((b + STEP_SIZE).toFixed(1))) {
                for (let w = parseFloat(W_START_GRID); w <= parseFloat(W_END_GRID); w = parseFloat((w + STEP_SIZE).toFixed(1))) {
                    const cacheKey = `${w.toFixed(1)},${b.toFixed(1)}`; // Hier nutzen wir den Raster-Schl√ºssel
                    if (!lossCache.hasOwnProperty(cacheKey)) {
                        pointsToProcess.push({ w, b });
                    }
                }
            }

            // F√ºge gecachte Rasterpunkte, die jetzt in den Bounds sind, zu currentLandscapeData hinzu
            const W_current_keys = new Set(currentLandscapeData.W.map(w => w.toFixed(1)));
            const B_current_keys = new Set(currentLandscapeData.B.map(b => b.toFixed(1)));

            for (let b = parseFloat(B_START_GRID); b <= parseFloat(B_END_GRID); b = parseFloat((b + STEP_SIZE).toFixed(1))) {
                for (let w = parseFloat(W_START_GRID); w <= parseFloat(W_END_GRID); w = parseFloat((w + STEP_SIZE).toFixed(1))) {
                    const wFixed = w.toFixed(1);
                    const bFixed = b.toFixed(1);
                    const cacheKey = `${wFixed},${bFixed}`;

                    // Punkt bereits im Raster-Cache und nicht in der currentLandscapeData (nach Koordinaten-Paar)
                    const isPointInCurrentData = currentLandscapeData.W.some((_, i) => currentLandscapeData.W[i].toFixed(1) === wFixed && currentLandscapeData.B[i].toFixed(1) === bFixed);

                    if (lossCache.hasOwnProperty(cacheKey) && !isPointInCurrentData) {
                        currentLandscapeData.W.push(w);
                        currentLandscapeData.B.push(b);
                        currentLandscapeData.L.push(lossCache[cacheKey]);
                    }
                }
            }

            const totalPoints = pointsToProcess.length;
            let currentPointIndex = 0;
            const chunkSize = 50;

            // Bounds nur erweitern
            currentLandscapeBounds.minW = Math.min(currentLandscapeBounds.minW, parseFloat(W_START_GRID));
            currentLandscapeBounds.maxW = Math.max(currentLandscapeBounds.maxW, parseFloat(W_END_GRID));
            currentLandscapeBounds.minB = Math.min(currentLandscapeBounds.minB, parseFloat(B_START_GRID));
            currentLandscapeBounds.maxB = Math.max(currentLandscapeBounds.maxB, parseFloat(B_END_GRID));

            const processChunk = () => {
                if (stopRequested) return resolve();

                const chunkEnd = Math.min(currentPointIndex + chunkSize, totalPoints);

                for (let i = currentPointIndex; i < chunkEnd; i++) {
                    const { w, b } = pointsToProcess[i];

                    // calculateLoss speichert den Loss automatisch unter dem Raster-Schl√ºssel ab
                    const loss = calculateLoss(w, b, data.xs, data.ys, data.N_DATA_POINTS);

                    // Der Punkt wird hier nur zu currentLandscapeData hinzugef√ºgt,
                    // wenn er NEU berechnet wurde.
                    currentLandscapeData.W.push(w);
                    currentLandscapeData.B.push(b);
                    currentLandscapeData.L.push(loss);
                }

                currentPointIndex = chunkEnd;

                if (currentPointIndex < totalPoints) {
                    document.getElementById('status').innerText = `Berechne Loss-Landschaft (dynamisch): ${currentPointIndex}/${totalPoints} neue Punkte...`;
                    setTimeout(processChunk, 10);
                } else {
                    document.getElementById('status').innerText = 'Loss-Landschaft erweitert. Fortsetzung des Trainings...';
                    resolve();
                }
            };

            if (totalPoints > 0) {
                 processChunk();
            } else {
                resolve();
            }
        });
    }

    // ***********************************************
    // IV. Training und Trajektorie (Realtime Update)
    // ***********************************************

    async function checkAndExpandLandscape(w_val, b_val, N_buffer, data) {
        let expand = false;

        if (w_val < currentLandscapeBounds.minW + PLOT_DENSITY_STEP || w_val > currentLandscapeBounds.maxW - PLOT_DENSITY_STEP ||
            b_val < currentLandscapeBounds.minB + PLOT_DENSITY_STEP || b_val > currentLandscapeBounds.maxB - PLOT_DENSITY_STEP) {

            // Wenn der Punkt zu nah am Rand (1 Raster-Schritt Puffer), erweitern wir um N_buffer
            expand = true;
        }

        if (expand) {
            const newMinW = Math.min(currentLandscapeBounds.minW, w_val - N_buffer * PLOT_DENSITY_STEP);
            const newMaxW = Math.max(currentLandscapeBounds.maxW, w_val + N_buffer * PLOT_DENSITY_STEP);
            const newMinB = Math.min(currentLandscapeBounds.minB, b_val - N_buffer * PLOT_DENSITY_STEP);
            const newMaxB = Math.max(currentLandscapeBounds.maxB, b_val + N_buffer * PLOT_DENSITY_STEP);

            await computeNewLossPoints(newMinW, newMaxW, newMinB, newMaxB, data);

            // Wichtig: Jetzt die Plots mit der neuen Surface-Definition aktualisieren
            updateAllPlots(currentLandscapeData);
        }
    }

    async function trainAndRecordTrajectory(name, optimizer, epochs, N_buffer, data) {
        if (stopRequested) throw new Error("Experiment gestoppt.");

        const model = createSimpleModel();
        model.compile({ optimizer: optimizer, loss: 'meanSquaredError' });

        const trajectory = { W: [], B: [], Loss: [] };
        const plotDivId = `plot-${name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
        let batchCounter = 0;

        const customCallback = new tf.CustomCallback({
            onBatchEnd: async (batch, logs) => {
                if (stopRequested) {
                     model.stopTraining = true;
                     return;
                }

                tf.tidy(() => {
                    const layer = model.layers[0];
                    const weights = layer.getWeights();

                    const w_val = weights[0].dataSync()[0];
                    const b_val = weights[1].dataSync()[0];

                    // Berechne den Loss f√ºr den genauen Trajektorienpunkt (wird im Cache gespeichert und ist > 0)
                    const measuredLoss = calculateLoss(w_val, b_val, data.xs, data.ys, data.N_DATA_POINTS);

                    trajectory.W.push(w_val);
                    trajectory.B.push(b_val);
                    trajectory.Loss.push(measuredLoss);

                    // Die Trajektorie muss mit den log-transformierten Z-Werten aktualisiert werden
                    const logW = trajectory.W;
                    const logB = trajectory.B;
                    const logLoss = trajectory.Loss.map(l => Math.log10(l));

                    if (batchCounter % 5 === 0) {
                        // Nur die Trajektorie (Trace 1) aktualisieren
                        Plotly.restyle(plotDivId, {
                            x: [logW],
                            y: [logB],
                            z: [logLoss]
                        }, [1]);
                    }
                    batchCounter++;

                    // Pr√ºfen und Landschaft erweitern (f√ºhrt zu updateAllPlots)
                    checkAndExpandLandscape(w_val, b_val, N_buffer, data);
                });
            },
            onEpochEnd: (epoch, logs) => {
                document.getElementById('status').innerText = `${name} - Epoche ${epoch + 1}/${epochs}: Loss = ${logs.loss.toFixed(4)}`;
            }
        });

        await model.fit(data.xs, data.ys, {
            epochs: epochs,
            callbacks: [customCallback],
            batchSize: data.N_DATA_POINTS,
            verbose: 0
        });

        model.dispose();

        if (stopRequested) throw new Error("Experiment gestoppt.");

        return trajectory;
    }

    // ***********************************************
    // V. Plotting (Log-Transformation & Color Mapping)
    // ***********************************************

    /**
     * Initialisiert den 3D-Plot mit der Loss-Oberfl√§che und der Trajektorie.
     */
    function initialize3DPlot(optimizerName, initialLandscapeData, initialTrajectory, initialSurfaceData) {
        const plotDivId = `plot-${optimizerName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;

        const plotContainer = document.getElementById('plot-container');
        const plotDiv = document.createElement('div');
        plotDiv.id = plotDivId;
        plotDiv.className = 'plot-div';
        plotContainer.appendChild(plotDiv);

        const { W_GRID, B_GRID, L_MATRIX } = initialSurfaceData;

        const lossValues = L_MATRIX.flat().filter(l => l !== null).map(l => Math.pow(10, l)); // R√ºck-Transformation f√ºr min/max Berechnung

        let minLossRaw = lossValues.length > 0 ? Math.min(...lossValues) : 0.1;
        minLossRaw = Math.max(minLossRaw, 1e-7);
        let maxLossRaw = lossValues.length > 0 ? Math.max(...lossValues) : 10;

        // *************************************************************
        // Log10 transformierte cmin/cmax
        // *************************************************************
        const L_LOG_MATRIX = L_MATRIX; // Bereits Log-transformiert

        const logMin = Math.log10(minLossRaw);
        const logMax = Math.log10(maxLossRaw);

        // Setze Farbskala-Grenzen mit Log-Puffer (cmin/cmax sind jetzt Log-Werte)
        const cminLogFinal = logMin - 1.0;
        const cmaxLogFinal = logMax + 0.1;
        // *************************************************************

        // Trace 0: Die Landschaft als 3D-Oberfl√§che (Surface)
        const surfaceTrace = {
            type: 'surface',
            x: W_GRID,
            y: B_GRID,
            z: L_LOG_MATRIX,
            name: 'Loss-Landschaft',

            // Farbgebung
            colorscale: 'Jet',
            reversescale: true,
            cmin: cminLogFinal,
            cmax: cmaxLogFinal,
            showscale: true,
            opacity: 0.9,

            // Beleuchtung (wie zuvor, um 3D-Effekt zu garantieren)
            lighting: {
                ambient: 0.6,
                diffuse: 0.6,
                specular: 0.1,
                fresnel: 0.1,
                roughness: 0.5,
            },

            contours: {
                z: { show: false }
            },
        };

        // Trace 1: Die Trajektorie
        const trajectoryTrace = {
            x: initialTrajectory.W,
            y: initialTrajectory.B,
            z: initialTrajectory.Loss.map(l => Math.log10(l)),
            type: 'scatter3d',
            mode: 'lines+markers',
            name: `${optimizerName} Trajektorie`,
            marker: { size: 4, color: 'red', symbol: 'circle' },
            line: { width: 5, color: 'red' }
        };

        const data = [surfaceTrace, trajectoryTrace];

        const layout = {
            title: {
                text: `${optimizerName} Loss-Landschaft & Trajektorie (Log10 Z-Achse)`,
                font: { color: '#d4d4d4' }
            },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)',

            scene: {
                xaxis: { title: 'Weight (w)', backgroundcolor: '#333', gridcolor: '#444', zerolinecolor: '#777', tickfont: { color: '#d4d4d4' }, titlefont: { color: '#d4d4d4' } },
                yaxis: { title: 'Bias (b)', backgroundcolor: '#333', gridcolor: '#444', zerolinecolor: '#777', tickfont: { color: '#d4d4d4' }, titlefont: { color: '#d4d4d4' } },
                // Z-Achse ist linear, da die Daten bereits log-transformiert sind
                zaxis: {
                    title: 'Loss (Log10(MSE))',
                    type: 'linear',
                    backgroundcolor: '#333',
                    gridcolor: '#444',
                    zerolinecolor: '#777',
                    tickfont: { color: '#d4d4d4' },
                    titlefont: { color: '#d4d4d4' }
                },
                camera: {
                    up: {x: 0, y: 0, z: 1},
                    center: {x: 0, y: 0, z: 0},
                    eye: {x: 1.5, y: 1.5, z: 1.5}
                }
            },
            margin: { l: 0, r: 0, b: 0, t: 30 }
        };

        Plotly.newPlot(plotDivId, data, layout, {responsive: true});
        plotInstances[plotDivId] = { W: initialTrajectory.W, B: initialTrajectory.B, Loss: initialTrajectory.Loss };

        window.dispatchEvent(new Event('resize'));
    }

    /**
     * Aktualisiert die Loss-Landschaft als 3D-Oberfl√§che (Surface) w√§hrend des Trainings.
     */
    function updateAllPlots(newLandscapeData) {
        const finalSurfaceData = convertScatterToSurfaceData(newLandscapeData);

        const rawLossValues = finalSurfaceData.L_MATRIX.flat().filter(l => l !== null).map(l => Math.pow(10, l)); // R√ºck-Transformation f√ºr min/max Berechnung

        if (rawLossValues.length === 0 || finalSurfaceData.W_GRID.length === 0 || finalSurfaceData.B_GRID.length === 0) return;

        let minLossRaw = Math.min(...rawLossValues);
        let maxLossRaw = Math.max(...rawLossValues);

        minLossRaw = Math.max(minLossRaw, 1e-7);
        maxLossRaw = Math.max(maxLossRaw, minLossRaw * 10.0); // Mindestbandbreite

        // *************************************************************
        // Log10 transformierte cmin/cmax
        // *************************************************************
        const L_LOG_MATRIX = finalSurfaceData.L_MATRIX; // Bereits Log-transformiert

        const logMin = Math.log10(minLossRaw);
        const logMax = Math.log10(maxLossRaw);

        // Setze Farbskala-Grenzen mit Log-Puffer
        const cminLogFinal = logMin - 1.0;
        const cmaxLogFinal = logMax + 0.1;
        // *************************************************************

        for (const id in plotInstances) {
             // Trace 0: Aktualisiere die Surface-Daten und Farb-Einstellungen
            Plotly.restyle(id, {
                x: [finalSurfaceData.W_GRID],
                y: [finalSurfaceData.B_GRID],
                z: [L_LOG_MATRIX],

                // Farbgebung
                cmin: [cminLogFinal],
                cmax: [cmaxLogFinal],

                'contours.z.show': [false],
            }, [0]);
        }
    }

    /**
     * Konvertiert die Scatter-Punkte in die Plotly-Surface-Matrix, wobei Gleitkommafehler durch Runden auf
     * eine feste String-Repr√§sentation vermieden werden.
     */
    function convertScatterToSurfaceData(landscapeData) {
        if (landscapeData.W.length === 0) return { W_GRID: [], B_GRID: [], L_MATRIX: [] };

        // 1. Definiere die eindeutigen Rasterpunkte (W_GRID, B_GRID)
        // Nutze .toFixed(1) als String-Key f√ºr Set, um Gleitkommafehler zu vermeiden.
        const uniqueW = Array.from(new Set(landscapeData.W.map(w => w.toFixed(1)))).map(s => parseFloat(s)).sort((a, b) => a - b);
        const uniqueB = Array.from(new Set(landscapeData.B.map(b => b.toFixed(1)))).map(s => parseFloat(s)).sort((a, b) => a - b);

        // 2. Erstelle Maps f√ºr schnellen Lookup der Indizes (mit String-Keys)
        const wMap = new Map(uniqueW.map((w, i) => [w.toFixed(1), i]));
        const bMap = new Map(uniqueB.map((b, i) => [b.toFixed(1), i]));

        const W_LEN = uniqueW.length;
        const B_LEN = uniqueB.length;

        // L_MATRIX speichert die Log10-transformierten Loss-Werte (noch als Roh-Loss im Input L)
        const L_MATRIX = new Array(B_LEN).fill(0).map(() => new Array(W_LEN).fill(null));

        for (let i = 0; i < landscapeData.W.length; i++) {
            const w = landscapeData.W[i];
            const b = landscapeData.B[i];
            const lossRaw = landscapeData.L[i];

            // 3. Lookup: Verwende den festen String-Key f√ºr den Index-Abruf
            const wIndex = wMap.get(w.toFixed(1));
            const bIndex = bMap.get(b.toFixed(1));

            if (wIndex !== undefined && bIndex !== undefined) {
                // Setze den Log10-transformierten Wert in die Matrix
                L_MATRIX[bIndex][wIndex] = Math.log10(lossRaw);
            }
        }

        return { W_GRID: uniqueW, B_GRID: uniqueB, L_MATRIX: L_MATRIX };
    }

    // ***********************************************
    // VI. Experiment-Start / Stop Logik
    // ***********************************************

    function getOptimizerParameters(name) {
        const config = OPTIMIZER_CONFIGS[name];
        const params = {};

        for (const param of config.params) {
            const inputId = `param-${param.name}`;
            const inputElement = document.getElementById(inputId);

            if (inputElement) {
                // Wenn das Feld vorhanden ist, lese den Wert.
                if (param.type === 'select') {
                    params[param.name] = inputElement.value; // String-Wert
                } else {
                    params[param.name] = parseFloat(inputElement.value);
                }
            } else {
                // Wenn das Feld nicht vorhanden ist (weil es von einem anderen Optimizer verwendet wird),
                // verwende den Standardwert des aktuellen Optimizers.
                params[param.name] = config.defaults[param.name];
            }
        }
        return params;
    }

    function setUIState(running) {
        experimentRunning = running;
        document.getElementById('startButton').style.display = running ? 'none' : 'block';
        document.getElementById('stopButton').style.display = running ? 'block' : 'none';
        document.querySelectorAll('.controls input, .controls select, .controls textarea, .controls button:not(#stopButton)').forEach(el => el.disabled = running);
    }

    function stopExperiment() {
        stopRequested = true;
        document.getElementById('status').innerText = 'Stopp-Anforderung gesendet. Warte auf Ende der aktuellen Operation...';
    }

    // Hilfsfunktion zum Runden auf das n√§chste Raster (z.B. 0.1)
    function roundToGrid(value) {
        return Math.round(value / PLOT_DENSITY_STEP) * PLOT_DENSITY_STEP;
    }

    async function startExperiment() {
        if (experimentRunning) return;
        setUIState(true);
        stopRequested = false;

        document.getElementById('plot-container').innerHTML = '';
        plotInstances = {};
        lossCache = {};
        currentLandscapeData = { W: [], B: [], L: [] };

        let data = null;

        try {
            data = parseData();

            const N_buffer = parseInt(document.getElementById('steps').value);
            const EPOCHS = parseInt(document.getElementById('epochs').value);

            const selectedOptimizers = Array.from(document.querySelectorAll('input[name="optimizer"]:checked'))
                                           .map(checkbox => checkbox.value);

            if (selectedOptimizers.length === 0) {
                document.getElementById('status').innerText = "Bitte w√§hlen Sie mindestens einen Optimizer aus.";
                setUIState(false);
                return;
            }

            document.getElementById('status').innerText = 'Experiment wird vorbereitet... Initialisiere Startpunkt.';

            const initialModel = createSimpleModel();
            const initialWeights = initialModel.layers[0].getWeights();
            let initialW = initialWeights[0].dataSync()[0];
            let initialB = initialWeights[1].dataSync()[0];
            initialModel.dispose();

            // Runde initialW und initialB auf das Raster
            initialW = roundToGrid(initialW);
            initialB = roundToGrid(initialB);

            // Berechne den Loss f√ºr den gerundeten Startpunkt.
            const initialLoss = calculateLoss(initialW, initialB, data.xs, data.ys, data.N_DATA_POINTS);

            const initialMinW = initialW - N_buffer * PLOT_DENSITY_STEP;
            const initialMaxW = initialW + N_buffer * PLOT_DENSITY_STEP;
            const initialMinB = initialB - N_buffer * PLOT_DENSITY_STEP;
            const initialMaxB = initialB + N_buffer * PLOT_DENSITY_STEP;

            currentLandscapeBounds = { minW: initialMinW, maxW: initialMaxW, minB: initialMinB, maxB: initialMaxB };

            document.getElementById('status').innerText = 'Berechne initiale Loss-Landschaft (Startbereich)...';
            await computeNewLossPoints(initialMinW, initialMaxW, initialMinB, initialMaxB, data);

            if (stopRequested) throw new Error("Experiment gestoppt.");

            const initialSurfaceData = convertScatterToSurfaceData(currentLandscapeData);
            const { W_GRID, B_GRID, L_MATRIX } = initialSurfaceData;

            if (W_GRID.length === 0 || B_GRID.length === 0 || L_MATRIX.length === 0) {
                throw new Error("Fehler: Initiales Loss-Landschafts-Raster konnte nicht berechnet werden (Pr√ºfen Sie Ihre Daten und Puffergr√∂√üe).");
            }

            // Plots direkt als Surface initialisieren
            for (const name of selectedOptimizers) {
                 initialize3DPlot(name, currentLandscapeData, { W: [initialW], B: [initialB], Loss: [initialLoss] }, initialSurfaceData);
            }

            document.getElementById('status').innerText = 'Starte Trainingsl√§ufe...';

            for (const name of selectedOptimizers) {
                if (stopRequested) throw new Error("Experiment gestoppt.");
                document.getElementById('status').innerText = `Starte Training f√ºr Optimierer: ${name}... (Loss-Landschaft wird dynamisch aktualisiert)`;

                const params = getOptimizerParameters(name);
                const optimizer = OPTIMIZER_CONFIGS[name].factory(params);

                await trainAndRecordTrajectory(name, optimizer, EPOCHS, N_buffer, data);

                optimizer.dispose(); // Wichtig: Optimierer nach Gebrauch entsorgen
            }

            if (stopRequested) throw new Error("Experiment gestoppt.");

            document.getElementById('status').innerText = 'Training abgeschlossen. Plots finalisiert.';

        } catch (error) {
            if (error.message === "Experiment gestoppt.") {
                document.getElementById('status').innerText = 'Experiment wurde erfolgreich gestoppt.';
            } else {
                console.error(error);
                document.getElementById('status').innerText = `FEHLER: ${error.message}`;
            }
        } finally {
            setUIState(false);
            if (data && data.xs) {
                data.xs.dispose();
                data.ys.dispose();
            }
        }
    }
</script>
</body>
</html>
