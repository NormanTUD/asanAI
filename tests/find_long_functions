#!/usr/bin/env python3

import argparse
import glob
import logging
import re
import sys

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s", stream=sys.stderr)

FUNC_REGEX = re.compile(
    r"""
    (?:function\s+([a-zA-Z0-9_$]+)\s*\([^)]*\)\s*\{) |
    (?:(?:const|let|var)\s+([a-zA-Z0-9_$]+)\s*=\s*\([^)]*\)\s*=>\s*\{)
    """,
    re.VERBOSE,
)

STRING_REGEX = re.compile(r"""(['"`])""")

def read_file(path):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.readlines()
    except Exception as e:
        logging.error(f"Failed to read {path}: {e}")
        return []


def find_functions_in_file(path):
    lines = read_file(path)
    functions = []
    i = 0
    while i < len(lines):
        line = lines[i]
        match = FUNC_REGEX.search(line)
        if match:
            func_name = match.group(1) or match.group(2) or "<anonymous>"
            start_line = i + 1
            i, end_line = find_function_end(lines, i, match.end())
            length = end_line - start_line + 1
            functions.append((func_name, start_line, length, path))
        i += 1
    return functions


def find_function_end(lines, start_index, start_pos):
    stack = 1
    i = start_index
    pos = start_pos
    in_string = None
    while i < len(lines):
        line = lines[i]
        while pos < len(line):
            ch = line[pos]
            if in_string:
                if ch == "\\":
                    pos += 2
                    continue
                if ch == in_string:
                    in_string = None
                pos += 1
                continue
            if ch in ('"', "'", "`"):
                in_string = ch
            elif ch == "{":
                stack += 1
            elif ch == "}":
                stack -= 1
                if stack == 0:
                    return i, i + 1
            pos += 1
        i += 1
        pos = 0
    return i, i


def collect_files(file_args):
    if file_args:
        return file_args
    return glob.glob("*.js")


def main():
    parser = argparse.ArgumentParser(description="Find longest functions in JS files")
    parser.add_argument("files", nargs="*", help="JS files to scan (default: *.js in current dir)")
    parser.add_argument("--min-lines", type=int, default=100, help="Show functions longer than this (default: 100)")
    parser.add_argument("--max-lines", type=int, help="Fail if any function exceeds this many lines")
    args = parser.parse_args()

    files = collect_files(args.files)
    if not files:
        logging.error("No JS files found")
        sys.exit(1)

    all_functions = []
    for f in files:
        all_functions.extend(find_functions_in_file(f))

    long_functions = [fn for fn in all_functions if fn[2] >= args.min_lines]
    long_functions.sort(key=lambda x: x[2], reverse=True)

    for name, start, length, path in long_functions:
        print(f"{path}:{start} {name} ({length} lines)")

    if args.max_lines:
        too_long = [fn for fn in all_functions if fn[2] > args.max_lines]
        if too_long:
            logging.error(f"{len(too_long)} function(s) exceed --max-lines={args.max_lines}")
            sys.exit(2)


if __name__ == "__main__":
    main()

