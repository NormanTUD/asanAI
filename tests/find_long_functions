#!/usr/bin/env python3
"""
find_long_js_functions.py

Find JavaScript functions (declared functions, arrow functions, class methods)
and report the longest ones (by line count). Robust lexer-style scanning:
- skips/ignores comments
- handles single/double-quoted strings and multiline template literals (with ${...})
- supports async functions, generators, arrow functions
- detects methods inside classes
- default file set: *.js (no recursion) unless files passed as args

Usage:
  ./find_long_js_functions.py                 # scans *.js in cwd
  ./find_long_js_functions.py file1.js a.js   # scan these files
  ./find_long_js_functions.py --min-lines 50
  ./find_long_js_functions.py --max-lines 500   # exits non-zero if any function > 500 lines
"""

from __future__ import annotations
import argparse
import glob
import logging
import os
import re
import sys
from dataclasses import dataclass
from typing import List, Optional, Tuple

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s", stream=sys.stderr)

ignored_long_funcs = ["debug_unusual_function_inputs", "_get_run_sh_file_for_custom_training", "_get_predict_py_for_local_training"]

@dataclass
class FunctionInfo:
    name: str
    filename: str
    start_line: int
    end_line: int

    @property
    def length(self) -> int:
        return self.end_line - self.start_line + 1


# ---- Utilities --------------------------------------------------------------

def read_file_text(path: str) -> str:
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as fh:
            return fh.read()
    except Exception as e:
        logging.error(f"Error reading {path}: {e}")
        return ""


def default_files_from_cwd() -> List[str]:
    return sorted(f for f in glob.glob("*.js") if f != "asanai.js")


def is_identifier_char(ch: str) -> bool:
    return ch.isalnum() or ch == "_" or ch == "$"


def scan_backwards_token(text: str, idx: int) -> Tuple[str, int]:
    """
    Scan backwards from idx-1 to find a token (identifier or keyword)
    Return (token, start_index_of_token). If none, return ("", idx).
    """
    i = idx - 1
    while i >= 0 and text[i].isspace():
        i -= 1
    if i < 0:
        return "", idx
    # identifier / keyword
    if is_identifier_char(text[i]):
        j = i
        while j >= 0 and is_identifier_char(text[j]):
            j -= 1
        return text[j + 1 : i + 1], j + 1
    # single-char tokens
    return text[i], i


# ---- Lexer-style scanner ----------------------------------------------------

def find_functions_in_text(text: str, filename: str) -> List[FunctionInfo]:
    n = len(text)
    i = 0
    line_starts = [0]
    for m in re.finditer(r"\n", text):
        line_starts.append(m.end())
    # helper to get line number from index (1-based)
    def line_of(idx: int) -> int:
        # binary search
        lo, hi = 0, len(line_starts) - 1
        while lo <= hi:
            mid = (lo + hi) // 2
            if line_starts[mid] <= idx:
                lo = mid + 1
            else:
                hi = mid - 1
        return lo  # lo is index of next line_start, so line number is lo

    results: List[FunctionInfo] = []

    # States
    # We'll iterate char by char, skipping comments & strings, and when we encounter a '{'
    # we decide if it starts a function body by looking backward (heuristic), or if we are in class body,
    # we also look for method signatures.
    class_stack = []  # stores indices of '{' that opened class bodies
    brace_stack = []  # general brace stack to keep context

    while i < n:
        ch = text[i]

        # Skip whitespace fast
        if ch.isspace():
            i += 1
            continue

        # Comments
        if ch == "/" and i + 1 < n:
            nxt = text[i + 1]
            if nxt == "/":
                # single-line comment -> skip to end of line
                j = text.find("\n", i + 2)
                i = n if j == -1 else j + 1
                continue
            elif nxt == "*":
                # multi-line comment -> find closing */
                j = text.find("*/", i + 2)
                i = n if j == -1 else j + 2
                continue

        # Strings
        if ch == "'" or ch == '"':
            quote = ch
            i += 1
            while i < n:
                c = text[i]
                if c == "\\":
                    i += 2
                    continue
                if c == quote:
                    i += 1
                    break
                i += 1
            continue

        # Template literals - must handle ${...} expressions that contain braces
        if ch == "`":
            i += 1
            while i < n:
                c = text[i]
                if c == "\\":
                    i += 2
                    continue
                if c == "`":
                    i += 1
                    break
                if c == "$" and i + 1 < n and text[i + 1] == "{":
                    # enter expression mode until matching }
                    i += 2
                    depth = 1
                    while i < n and depth > 0:
                        d = text[i]
                        if d == '"' or d == "'":
                            # skip inner string
                            q = d
                            i += 1
                            while i < n:
                                if text[i] == "\\":
                                    i += 2
                                    continue
                                if text[i] == q:
                                    i += 1
                                    break
                                i += 1
                            continue
                        if text[i] == "`":
                            # nested template literal inside expression (rare) - handle recursively-ish
                            i += 1
                            while i < n:
                                if text[i] == "\\":
                                    i += 2
                                    continue
                                if text[i] == "`":
                                    i += 1
                                    break
                                # nested ${ ... } inside nested template:
                                if text[i] == "$" and i + 1 < n and text[i + 1] == "{":
                                    i += 2
                                    depth2 = 1
                                    while i < n and depth2 > 0:
                                        if text[i] == "\\":
                                            i += 2
                                            continue
                                        if text[i] == "{":
                                            depth2 += 1
                                        elif text[i] == "}":
                                            depth2 -= 1
                                        i += 1
                                    continue
                                i += 1
                            continue
                        if text[i] == "{":
                            depth += 1
                        elif text[i] == "}":
                            depth -= 1
                        elif text[i] == "/" and i + 1 < n:
                            # attempt to skip regex literal naive-ly: if previous non-space is operator, treat as regex start
                            # But full regex parsing is complex; we conservatively skip if next char isn't '/' or '*'
                            if text[i + 1] not in ("/", "*"):
                                # try to skip a regex literal until unescaped slash followed by optional flags
                                j = i + 1
                                in_class = False
                                while j < n:
                                    if text[j] == "\\":
                                        j += 2
                                        continue
                                    if text[j] == "[":
                                        in_class = True
                                    elif text[j] == "]":
                                        in_class = False
                                    elif text[j] == "/" and not in_class:
                                        j += 1
                                        # skip flags
                                        while j < n and text[j].isalpha():
                                            j += 1
                                        break
                                    j += 1
                                i = j
                                continue
                        i += 1
                    continue
                i += 1
            continue

        # Regex literal (best-effort): when / starts a regex rather than division. Hard to know; attempt heuristic:
        # If previous non-space token is one of: ( , = : ? [ { ; return => it's likely start of regex.
        if ch == "/":
            # check next char - if it's / or * we handled comments earlier, so this is other '/'
            # find previous non-space character
            j = i - 1
            while j >= 0 and text[j].isspace():
                j -= 1
            prev = text[j] if j >= 0 else ""
            if prev in ("", "(", ",", "=", ":", "?", "[", "{", ";", "\n", "\t") or text[max(0, j - 5) : j + 1].strip().endswith("return"):
                # treat as regex start - skip until unescaped / (respecting character classes)
                k = i + 1
                in_class = False
                while k < n:
                    if text[k] == "\\":
                        k += 2
                        continue
                    if text[k] == "[":
                        in_class = True
                    elif text[k] == "]":
                        in_class = False
                    elif text[k] == "/" and not in_class:
                        k += 1
                        # skip flags
                        while k < n and text[k].isalpha():
                            k += 1
                        break
                    k += 1
                i = k
                continue
            # else fall through to treat as division operator
        # ---- At this point, we are in "normal" code parsing ----

        # Detect "class" keyword to track class scopes
        if text.startswith("class", i) and (i + 5 == n or not is_identifier_char(text[i + 5])):
            # find next '{' that starts class body (skip extends ... etc)
            j = i + 5
            while j < n and text[j] != "{":
                # skip strings/comments in between
                if text[j].isspace():
                    j += 1
                    continue
                if text[j] == "/" and j + 1 < n:
                    if text[j + 1] == "/":
                        k = text.find("\n", j + 2)
                        j = n if k == -1 else k + 1
                        continue
                    elif text[j + 1] == "*":
                        k = text.find("*/", j + 2)
                        j = n if k == -1 else k + 2
                        continue
                if text[j] in ("'", '"', "`"):
                    # reuse string/template skip logic minimally
                    q = text[j]
                    j += 1
                    while j < n:
                        if text[j] == "\\":
                            j += 2
                            continue
                        if text[j] == q:
                            j += 1
                            break
                        j += 1
                    continue
                j += 1
            if j < n and text[j] == "{":
                class_stack.append(j)
                brace_stack.append(("{class}", j))
                i = j + 1
                continue

        # Opening brace - maybe function body, maybe normal block
        if ch == "{":
            # Heuristic: check what kind of construct this block starts (function? class method? other)
            # Look backwards to decide
            # If immediately before brace we had ')' -> could be function declaration/expression or method signature
            k = i - 1
            # skip spaces
            while k >= 0 and text[k].isspace():
                k -= 1
            maybe_function = False
            func_name = "<anonymous>"
            name_found = False

            if k >= 0 and text[k] == ")":
                # find matching '(' backwards
                depth = 1
                j = k - 1
                while j >= 0 and depth > 0:
                    if text[j] == ")":
                        depth += 1
                    elif text[j] == "(":
                        depth -= 1
                    elif text[j] in ("'", '"', "`"):
                        # skip backward through string - approximate: move j backwards until matching quote (not perfect, but reduces false positives)
                        q = text[j]
                        j -= 1
                        while j >= 0:
                            if text[j] == "\\":
                                j -= 2
                                continue
                            if text[j] == q:
                                j -= 1
                                break
                            j -= 1
                    j -= 1
                # j is now index of char before '(', or -1
                token, tpos = scan_backwards_token(text, j + 1)
                # token might be 'function' or an identifier (method name) or 'async' before 'function'
                if token == "function":
                    # function declaration/expression: try capturing name if present between 'function' and '('
                    # find name (if any) between token end and the '(' we found earlier
                    name_search_end = k - 1
                    name_search_start = tpos + len("function")
                    m = re.search(r"[A-Za-z0-9_$]+", text[name_search_start : name_search_end + 1])
                    if m:
                        func_name = m.group(0)
                        name_found = True
                    maybe_function = True
                else:
                    # token might be identifier -> likely method or named function expression
                    if token and token not in ("async", "static", "get", "set"):
                        func_name = token
                        name_found = True
                    else:
                        # check further back for 'async'
                        tok2, _ = scan_backwards_token(text, tpos)
                        if tok2 == "async":
                            # name might be before that
                            tok3, _ = scan_backwards_token(text, tpos)
                            if tok3 and tok3 not in ("async", "static"):
                                func_name = tok3
                                name_found = True
                    maybe_function = True

            else:
                # If immediate previous significant chars include '=>', it's not a { that starts arrow's body (arrow would have { after =>)
                # If previous chars contain '=>' within a short span, it's an arrow function body.
                s_start = max(0, i - 50)
                before = text[s_start:i]
                arrow_match = before.rfind("=>")
                if arrow_match != -1 and (i - (s_start + arrow_match)) < 10:
                    # attempt to capture name before '=' if pattern is like `const name = (...) => {`
                    left_part = before[:arrow_match]
                    # find last identifier before '='
                    m = re.search(r"([A-Za-z0-9_$]+)\s*(?:=\s*)?$", left_part)
                    if m:
                        func_name = m.group(1)
                        name_found = True
                    maybe_function = True

                else:
                    # Could be class method defined as: foo() { ... } or async foo() { ... } or *generator methods
                    # Look backwards for pattern: identifier (or get/set) followed by optional whitespace and '('
                    j = i - 1
                    while j >= 0 and text[j].isspace():
                        j -= 1
                    if j >= 0 and text[j] == ")":
                        # handled above
                        maybe_function = True
                    else:
                        # check for "identifier (" just before
                        # look back a bit
                        s2 = max(0, i - 200)
                        snippet = text[s2:i]
                        mm = re.search(r"([A-Za-z0-9_$]+)\s*\(\s*[^\)]{0,200}\)\s*$", snippet)
                        if mm:
                            func_name = mm.group(1)
                            name_found = True
                            maybe_function = True

            # If heuristic thinks this is a function-like block, attempt to find its closing brace respecting strings/templates/comments
            if maybe_function:
                body_start = i
                body_end = find_matching_brace(text, body_start)
                if body_end is not None:
                    # Accept this as a function if our heuristics matched; also accept if inside a class (method)
                    start_line = line_of(body_start)
                    end_line = line_of(body_end)
                    # refine name: if not found, try to detect 'async' or other decorations before
                    if not name_found:
                        # attempt to find a name/keyword nearby
                        left_snip_start = max(0, i - 200)
                        left_snip = text[left_snip_start:i]
                        m = re.search(r"(?:async\s+)?([A-Za-z0-9_$]+)\s*\(\s*", left_snip[::-1])
                        # reverse search attempt is messy; simpler: look for "function NAME" earlier in a short window
                        m2 = re.search(r"function\s+([A-Za-z0-9_$]+)", left_snip)
                        if m2:
                            func_name = m2.group(1)
                        else:
                            # try to find "const name =" pattern before
                            m3 = re.search(r"(?:const|let|var)\s+([A-Za-z0-9_$]+)\s*=\s*[^=]{0,80}$", left_snip)
                            if m3:
                                func_name = m3.group(1)
                    results.append(FunctionInfo(name=func_name, filename=filename,
                                                start_line=line_of(body_start), end_line=line_of(body_end)))
                    i = body_end + 1
                    continue
                else:
                    # unclosed brace - move on (avoid infinite loop)
                    i += 1
                    continue

            # Otherwise treat as normal block: push to general brace stack
            brace_stack.append(("{", i))
            i += 1
            continue

        # Closing brace
        if ch == "}":
            # pop class stack if matches
            if class_stack and class_stack[-1] < i:
                # rough heuristic: if the topmost class start is before this brace, close it
                class_stack.pop()
            # pop generic brace if any
            if brace_stack:
                brace_stack.pop()
            i += 1
            continue

        # Otherwise just advance
        i += 1

    return results


def find_matching_brace(text: str, open_idx: int) -> Optional[int]:
    """
    Given index of '{' in text, find the index of the matching '}'.
    Considers strings, template-literals (with ${}), comments, and regex literals (best-effort).
    Returns index of matching '}' or None if not found.
    """
    n = len(text)
    if open_idx >= n or text[open_idx] != "{":
        return None
    i = open_idx + 1
    depth = 1
    while i < n:
        ch = text[i]
        # comments
        if ch == "/" and i + 1 < n:
            if text[i + 1] == "/":
                j = text.find("\n", i + 2)
                i = n if j == -1 else j + 1
                continue
            elif text[i + 1] == "*":
                j = text.find("*/", i + 2)
                i = n if j == -1 else j + 2
                continue
        # strings
        if ch == "'" or ch == '"':
            q = ch
            i += 1
            while i < n:
                if text[i] == "\\":
                    i += 2
                    continue
                if text[i] == q:
                    i += 1
                    break
                i += 1
            continue
        # template literal
        if ch == "`":
            i += 1
            while i < n:
                if text[i] == "\\":
                    i += 2
                    continue
                if text[i] == "`":
                    i += 1
                    break
                if text[i] == "$" and i + 1 < n and text[i + 1] == "{":
                    # enter expression
                    i += 2
                    subdepth = 1
                    while i < n and subdepth > 0:
                        c = text[i]
                        if c == "\\":
                            i += 2
                            continue
                        if c == "'" or c == '"':
                            q = c
                            i += 1
                            while i < n:
                                if text[i] == "\\":
                                    i += 2
                                    continue
                                if text[i] == q:
                                    i += 1
                                    break
                                i += 1
                            continue
                        if text[i] == "`":
                            # nested template
                            i += 1
                            while i < n:
                                if text[i] == "\\":
                                    i += 2
                                    continue
                                if text[i] == "`":
                                    i += 1
                                    break
                                if text[i] == "$" and i + 1 < n and text[i + 1] == "{":
                                    i += 2
                                    nested = 1
                                    while i < n and nested > 0:
                                        if text[i] == "\\":
                                            i += 2
                                            continue
                                        if text[i] == "{":
                                            nested += 1
                                        elif text[i] == "}":
                                            nested -= 1
                                        i += 1
                                    continue
                                i += 1
                            continue
                        if text[i] == "{":
                            subdepth += 1
                        elif text[i] == "}":
                            subdepth -= 1
                        i += 1
                    continue
                i += 1
            continue
        # regex literal (best-effort)
        if ch == "/":
            # determine if regex likely
            j = i - 1
            while j >= 0 and text[j].isspace():
                j -= 1
            prev = text[j] if j >= 0 else ""
            if prev in ("", "(", ",", "=", ":", "?", "[", "{", ";", "\n", "\t") or text[max(0, j - 6) : j + 1].strip().endswith("return"):
                k = i + 1
                in_class = False
                while k < n:
                    if text[k] == "\\":
                        k += 2
                        continue
                    if text[k] == "[":
                        in_class = True
                    elif text[k] == "]":
                        in_class = False
                    elif text[k] == "/" and not in_class:
                        k += 1
                        while k < n and text[k].isalpha():
                            k += 1
                        break
                    k += 1
                i = k
                continue
        # regular brace handling
        if ch == "{":
            depth += 1
        elif ch == "}":
            depth -= 1
            if depth == 0:
                return i
        i += 1
    return None


# ---- CLI & main ------------------------------------------------------------

def collect_input_files(args_files: List[str]) -> List[str]:
    if args_files:
        # preserve order; validate existence
        files = []
        for p in args_files:
            if os.path.isfile(p):
                files.append(p)
            else:
                logging.warning(f"File not found or not a file: {p}")
        return files
    else:
        files = default_files_from_cwd()
        return files


def main() -> None:
    parser = argparse.ArgumentParser(description="Find longest functions in JS files (robust lexer).")
    parser.add_argument("files", nargs="*", help="JS files to scan (default: *.js in current dir, no recursion)")
    parser.add_argument("--min-lines", type=int, default=100, help="Show only functions with >= this many lines (default 100)")
    parser.add_argument("--max-lines", type=int, help="Fail (exit non-zero) if any function exceeds this many lines")
    parser.add_argument("--top", type=int, default=0, help="Show only the top N longest functions (0 = show all matching)")
    args = parser.parse_args()

    files = collect_input_files(args.files)
    if not files:
        logging.error("No JS files to scan (provide files or ensure there are *.js in cwd).")
        sys.exit(1)

    all_funcs: List[FunctionInfo] = []
    for f in files:
        text = read_file_text(f)
        if not text:
            continue
        funcs = find_functions_in_text(text, f)
        all_funcs.extend(funcs)

    if not all_funcs:
        logging.info("No functions found.")
        return

    # Filter by min-lines
    filtered = [fn for fn in all_funcs if fn.length >= args.min_lines]
    filtered.sort(key=lambda x: x.length, reverse=True)

    if args.top > 0:
        filtered = filtered[: args.top]

    # Print results
    for fn in filtered:
        name = fn.name or "<anonymous>"
        if name not in ignored_long_funcs:
            print(f"{fn.filename}:{fn.start_line} {name} ({fn.length} lines)")

    # Check max-lines fail condition against all functions, not only filtered
    if args.max_lines is not None:
        offenders = [fn for fn in all_funcs if fn.length > args.max_lines]
        if offenders:
            logging.error(f"{len(offenders)} function(s) exceed --max-lines={args.max_lines}")
            # print the offenders too (top 10)
            offenders.sort(key=lambda x: x.length, reverse=True)
            for fn in offenders[:10]:
                print(f"{fn.filename}:{fn.start_line} {fn.name} ({fn.length} lines)")
            sys.exit(2)


if __name__ == "__main__":
    main()
