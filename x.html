<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dense Layer Visualizer (SVG Konvergenz - Final)</title>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        h1 {
            color: #333;
            margin-bottom: 5px;
        }
        h2 {
            font-size: 1rem;
            color: #6c757d;
            margin-bottom: 20px;
        }
        .visualizer-container {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            /* Maximale Breite, um das Layout zu stabilisieren */
            max-width: 550px; 
            width: 95%;
        }
    </style>
    
    <script>
    /* ----------------------------------------------------
     * dense_visualizer_svg_v3.js
     * Finale Visualisierung der Dense Layer mit SVG für präzise Geometrie.
     * NEU: Perfekte Linien-Synchronisation und schrittweise Summierung.
     * ---------------------------------------------------- */

    // --- 1. Encapsulated CSS ---
    function getDenseStyles(instanceId) {
        return `
        /* General setup for instance ${instanceId} */
        [data-dense-id="${instanceId}"] {
            /* Variables */
            --input-count: 4;
            --cell-size: 35px;
            --weight-box-width: 45px;
            --weight-line-height: 40px; /* 35px cell + 5px gap */
            --color-input: #333;
            --color-weight: #007bff;
            --color-bias: #ffc107;
            --color-output: #28a745;
            --flow-duration: 900ms; 
            --calc-delay: 1500ms; 
            --pulse-color: #ff0000; 
            --neuron-radius: 50px; /* VERGRÖSSERT für schrittweise Summe */
            --output-color-light: #d4edda;

            /* Page skeleton */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: Arial, sans-serif;
            padding: 0;
            box-sizing: border-box;
            width: 100%;
        }

        [data-dense-id="${instanceId}"] .dense-container {
            display: grid;
            /* Grid-Definition: 
               Input(35) | Gap(20) | Gewicht(45) | Gap(30) | Neuron(100) | Gap(30) | Output(35) */
            grid-template-columns: var(--cell-size) 20px var(--weight-box-width) 30px calc(2 * var(--neuron-radius)) 30px var(--cell-size);
            grid-template-rows: auto;
            align-items: center;
            gap: 0;
            position: relative;
            width: 100%;
            padding: 10px 0;
        }
        
        /* Input Vector (links) */
        [data-dense-id="${instanceId}"] .input-vector {
            grid-column: 1;
            grid-row: 1;
            display: flex;
            flex-direction: column; 
            gap: 5px;
            align-items: flex-end; 
            z-index: 10;
        }

        [data-dense-id="${instanceId}"] .input-val {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--color-input);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 4px;
            transition: box-shadow 0.2s;
        }

        /* SVG Overlay für die Synapsen-Linien (Konvergenz) */
        [data-dense-id="${instanceId}"] .synapse-svg-overlay {
            grid-column: 1 / span 5; 
            grid-row: 1;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; 
            z-index: 5;
            pointer-events: none;
        }
        
        [data-dense-id="${instanceId}"] .synapse-line {
            stroke: var(--color-weight);
            stroke-linecap: round;
            fill: none;
            transition: stroke-width 0.2s, stroke 0.2s;
        }

        /* Gewichtswerte (in den blauen Boxen) */
        [data-dense-id="${instanceId}"] .weight-values {
            grid-column: 3;
            grid-row: 1;
            display: flex;
            flex-direction: column; 
            /* gap entfernt, da der Wrapper die Höhe definiert */
            align-items: center;
            z-index: 10;
        }
        
        /* FIX: Wrapper für die vertikale Zentrierung in der 40px Reihe */
        [data-dense-id="${instanceId}"] .weight-box-wrapper {
            display: flex;
            align-items: center; 
            justify-content: center;
            height: var(--weight-line-height); /* 40px */
            width: 100%;
        }

        [data-dense-id="${instanceId}"] .weight-box {
            width: var(--weight-box-width); 
            height: 25px; 
            background-color: var(--color-weight);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem; 
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-weight: bold;
            transition: box-shadow 0.2s, background-color 0.2s;
            /* Sehr hoher Z-Index, um die Linien zu überdecken */
            z-index: 20; 
        }

        /* Das Neuron (Hauptknoten) */
        [data-dense-id="${instanceId}"] .neuron-node {
            grid-column: 5;
            grid-row: 1;
            width: calc(2 * var(--neuron-radius));
            height: calc(2 * var(--neuron-radius));
            background-color: #f8f9fa;
            border: 3px solid #6c757d;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; 
            font-size: 0.8rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: border-color var(--calc-delay) ease-in-out, background-color 0.1s, box-shadow 0.2s;
            z-index: 10;
        }
        
        /* Initial/Final Notation (ausgeblendet während der Summierung) */
        [data-dense-id="${instanceId}"] .math-notation {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 1;
            transition: opacity 0.3s;
        }

        /* Accumulator (für schrittweise Summierung) */
        [data-dense-id="${instanceId}"] .accumulator {
            font-size: 0.9rem;
            color: #444;
            font-weight: bold;
            min-height: 50px; 
            padding: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
            text-align: center;
            line-height: 1.2;
        }

        /* Highlight-Zustände (unverändert) */
        [data-dense-id="${instanceId}"] .neuron-node.summing {
            border-color: var(--color-bias);
            background-color: rgba(255, 193, 7, 0.2);
            box-shadow: 0 0 15px 5px var(--color-bias);
        }
        [data-dense-id="${instanceId}"] .neuron-node.activated {
            border-color: var(--color-output);
            background-color: var(--output-color-light);
            box-shadow: 0 0 15px 5px var(--color-output);
        }

        /* ... Bias, Output und Dot Animation bleiben gleich ... */

        /* Bias Addition */
        [data-dense-id="${instanceId}"] .bias-term {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 30px;
            height: 30px;
            background-color: var(--color-bias);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.8rem;
            z-index: 30; /* Über dem Neuron */
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: box-shadow 0.2s;
        }

        /* Output Linie */
        [data-dense-id="${instanceId}"] .output-line-container {
            grid-column: 6;
            grid-row: 1;
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        [data-dense-id="${instanceId}"] .output-line {
            height: 2px;
            width: 100%; 
            background-color: var(--color-output);
            position: relative;
        }
        
        @keyframes output-flow-animation {
            0% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(100%); }
        }

        [data-dense-id="${instanceId}"] .output-line-container.active .signal-dot {
            opacity: 1;
            top: calc(50% - 4px); 
            left: 0; 
            animation: output-flow-animation calc(var(--flow-duration) / 2) linear forwards;
        }
        
        /* Output (Aktiviertes Ergebnis) */
        [data-dense-id="${instanceId}"] .output-result {
            grid-column: 7;
            grid-row: 1;
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--color-output);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1rem;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: box-shadow 0.3s;
            z-index: 10;
        }
        `;
    }

    // --- 2. HTML Template ---
    function getDenseHtml(instanceId) {
        return `
        <div class="dense-container" data-dense-id="${instanceId}" role="region" aria-label="Dense Layer Neuron Calculation Demo">
            
            <div class="input-vector" data-element-type="inputVector">
                </div>
            
            <svg class="synapse-svg-overlay" data-element-type="synapseSvg" preserveAspectRatio="none">
                <g data-element-type="synapseGroup">
                    </g>
            </svg>

            <div class="weight-values" data-element-type="weightValues">
                </div>
            
            <div class="neuron-node" data-element-type="neuronNode">
                <div class="bias-term" data-element-type="biasTerm">b</div> 
                
                <div class="accumulator" data-element-type="accumulator"></div> 

                <div class="math-notation" data-element-type="mathNotation">
                    <div class="math-sum">
                        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>&#x2211;</mo><msub><mi>x</mi><mi>i</mi></msub><msub><mi>w</mi><mi>i</mi></msub></math>
                    </div>
                    <div class="math-sigma">
                        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>&#x3C3;</mi><mo>(</mo><mi>z</mi><mo>)</mo></math>
                    </div>
                </div>
            </div>

            <div class="output-line-container" data-element-type="outputLineContainer">
                <div class="output-line">
                    <div class="signal-dot"></div>
                </div>
            </div>

            <div class="output-result" data-element-type="outputResult">
                z'
            </div>
        </div>
        
        <div style="margin-top: 15px; font-style: italic; font-size: 0.9rem;">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                <msup>
                    <mi>z</mi>
                    <mo>′</mo>
                </msup>
                <mo>=</mo>
                <mi>&#x3C3;</mi>
                <mfenced open="(" close=")">
                    <mfenced open="(" close=")">
                        <munderover>
                            <mo>&#x2211;</mo>
                            <mrow>
                                <mi>i</mi>
                                <mo>=</mo>
                                <mn>1</mn>
                            </munderover>
                        <mi>N</mi>
                            <msub>
                                <mi>x</mi>
                                <mi>i</mi>
                            </msub>
                            <msub>
                                <mi>w</mi>
                                <mi>i</mi>
                            </msub>
                        </mfenced>
                        <mo>+</mo>
                        <mi>b</mi>
                    </mfenced>
                </math>
            </math>
        </div>
        `;
    }

    // --- 3. DenseVisualizer Class ---
    class DenseVisualizer {
        constructor(containerElement, options = {}) {
            if (!containerElement) throw new Error('Container element is required.');

            this.container = containerElement;
            this.instanceId = 'dense-instance-' + Math.random().toString(36).substring(2, 9);
            this.isRunning = false;
            this.animationFrameId = null;

            // Constants
            this.INPUT_COUNT = options.inputCount || 4;
            this.CELL_SIZE = 35; 
            this.WEIGHT_BOX_WIDTH = 45;
            this.WEIGHT_LINE_HEIGHT = 40; // 35px cell + 5px gap
            this.NEURON_RADIUS = 50; // Increased
            this.FLOW_DURATION_MS = 900;
            this.CALC_DELAY_MS = 1500;
            this.SUM_TERM_DELAY = 300; // Pause for each term in the sum
            
            // Data
            this.INPUT_VALUES = options.inputValues || this.generateInputValues();
            this.WEIGHT_VALUES = options.weightValues || this.generateWeightValues();
            this.BIAS_VALUE = options.biasValue || 0.5;

            this.setupDOM();
            this.initElements();
            
            this.startLoop();
        }

        generateInputValues() {
            return Array.from({ length: this.INPUT_COUNT }, () => (Math.random() * 2 - 1).toFixed(2));
        }

        generateWeightValues() {
            return Array.from({ length: this.INPUT_COUNT }, () => (Math.random() * 2 - 1).toFixed(2));
        }

        setupDOM() {
            const style = document.createElement('style');
            style.setAttribute('data-dense-instance-id', this.instanceId);
            style.textContent = getDenseStyles(this.instanceId);
            document.head.appendChild(style);

            this.container.setAttribute('data-dense-id', this.instanceId);
            this.container.innerHTML = getDenseHtml(this.instanceId);

            this.container.style.setProperty('--input-count', String(this.INPUT_COUNT));
            this.container.style.setProperty('--neuron-radius', this.NEURON_RADIUS + 'px');
            this.container.style.setProperty('--flow-duration', this.FLOW_DURATION_MS + 'ms');
            this.container.style.setProperty('--calc-delay', this.CALC_DELAY_MS + 'ms');
            this.container.style.setProperty('--weight-line-height', this.WEIGHT_LINE_HEIGHT + 'px');
        }

        initElements() {
            // Element References
            this.inputVector = this.container.querySelector('[data-element-type="inputVector"]');
            this.weightValuesContainer = this.container.querySelector('[data-element-type="weightValues"]');
            this.synapseGroup = this.container.querySelector('[data-element-type="synapseGroup"]');
            this.synapseSvg = this.container.querySelector('[data-element-type="synapseSvg"]');
            this.outputLineContainer = this.container.querySelector('[data-element-type="outputLineContainer"]');
            this.biasTerm = this.container.querySelector('[data-element-type="biasTerm"]');
            this.outputResult = this.container.querySelector('[data-element-type="outputResult"]');
            this.neuronNode = this.container.querySelector('[data-element-type="neuronNode"]');
            this.accumulator = this.container.querySelector('[data-element-type="accumulator"]');
            this.mathNotation = this.container.querySelector('[data-element-type="mathNotation"]');


            this.inputVector.innerHTML = '';
            this.weightValuesContainer.innerHTML = '';
            this.synapseGroup.innerHTML = '';
            
            this.inputElements = [];
            this.weightBoxElements = [];
            this.pathElements = [];
            this.dotElements = [];

            // Berechnung der gewichteten Produkte und des finalen Ergebnisses
            this.WEIGHTED_PRODUCTS = this.INPUT_VALUES.map((x, i) => 
                (parseFloat(x) * parseFloat(this.WEIGHT_VALUES[i])).toFixed(3)
            );
            this.SUM_Z = this.WEIGHTED_PRODUCTS.reduce((sum, p) => sum + parseFloat(p), 0);
            this.SUM_Z += parseFloat(this.BIAS_VALUE);
            this.ACTIVATION_RESULT = (1 / (1 + Math.exp(-this.SUM_Z))).toFixed(3); // Sigmoid-Funktion
            
            this.accumulator.innerHTML = '';
            this.mathNotation.style.opacity = '1';

            // --- Geometrie-Berechnung ---
            
            const PADDING_Y = 10; 
            const TOTAL_HEIGHT = this.INPUT_COUNT * this.WEIGHT_LINE_HEIGHT + 2 * PADDING_Y; 
            
            this.synapseSvg.style.height = TOTAL_HEIGHT + 'px';
            this.synapseSvg.setAttribute('height', TOTAL_HEIGHT);
            
            const NEURON_CENTER_Y = TOTAL_HEIGHT / 2; 

            // Feste X-Positionen (Relativ zum Start des SVG-Containers)
            const INPUT_RIGHT_X = this.CELL_SIZE; 
            const WEIGHT_BOX_LEFT_X = INPUT_RIGHT_X + 20; 
            const WEIGHT_BOX_RIGHT_X = WEIGHT_BOX_LEFT_X + this.WEIGHT_BOX_WIDTH; 
            const NEURON_LEFT_EDGE_X = WEIGHT_BOX_RIGHT_X + 30; 

            const NEURON_ENTRY_X = NEURON_LEFT_EDGE_X; 

            const maxAbsWeight = Math.max(1e-6, ...this.WEIGHT_VALUES.map(w => Math.abs(parseFloat(w))));

            for (let i = 0; i < this.INPUT_COUNT; i++) {
                const inputVal = parseFloat(this.INPUT_VALUES[i]);
                const weightVal = parseFloat(this.WEIGHT_VALUES[i]);
                
                // Y-Position der Mitte der aktuellen Zeile
                const LINE_CENTER_Y = PADDING_Y + i * this.WEIGHT_LINE_HEIGHT + this.WEIGHT_LINE_HEIGHT / 2;
                
                // 1. Input-Element
                const inputDiv = document.createElement('div');
                inputDiv.classList.add('input-val');
                inputDiv.textContent = inputVal.toFixed(2);
                this.inputVector.appendChild(inputDiv);
                this.inputElements.push(inputDiv);
                
                // 2. Weight-Box (mit Wrapper für Zentrierung)
                const weightWrapper = document.createElement('div');
                weightWrapper.classList.add('weight-box-wrapper'); 
                
                const weightBox = document.createElement('div');
                weightBox.classList.add('weight-box');
                weightBox.textContent = weightVal.toFixed(2); 
                
                weightWrapper.appendChild(weightBox);
                this.weightValuesContainer.appendChild(weightWrapper);
                this.weightBoxElements.push(weightBox);
                
                // --- Synapsen-Berechnung (SVG) ---
                
                // P_A: Input Right Edge Mid-Y
                const P_A_X = INPUT_RIGHT_X;
                const P_A_Y = LINE_CENTER_Y;
                
                // P_B: Weight Box Left Edge Mid-Y (Start der Diagonale)
                const P_B_X = WEIGHT_BOX_LEFT_X; 
                
                // P_C: Weight Box Right Edge Mid-Y (Ende der Diagonale)
                const P_C_X = WEIGHT_BOX_RIGHT_X; 
                
                // P_D: Neuron Left Edge Mid-Y
                const P_D_X = NEURON_ENTRY_X;
                const P_D_Y = NEURON_CENTER_Y;
                
                // Path: Input -> WeightBox_Start (Horizontal) + WeightBox_End -> Neuron (Diagonal)
                // Die Linie unter der Box wird durch den Z-Index der Box verdeckt.
                const d = `M ${P_A_X},${P_A_Y} L ${P_B_X},${P_A_Y} M ${P_C_X},${P_A_Y} L ${P_D_X},${P_D_Y}`;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', d);
                path.classList.add('synapse-line');

                // Visualisierung der Gewichtung (Dicke)
                const absWeightNormalized = Math.abs(weightVal / maxAbsWeight);
                const thickness = 2 + 3 * absWeightNormalized; 
                path.setAttribute('stroke-width', thickness);
                
                this.synapseGroup.appendChild(path);
                this.pathElements.push(path);
                
                // 3. Signal-Dot (SVG Circle)
                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                dot.setAttribute('r', '4');
                dot.setAttribute('fill', 'var(--pulse-color)');
                dot.setAttribute('opacity', '0'); 
                dot.setAttribute('cx', P_A_X);
                dot.setAttribute('cy', P_A_Y);
                dot.style.transition = 'opacity 0.1s';
                
                this.synapseGroup.appendChild(dot);
                this.dotElements.push(dot);
            }
            
            // 4. Bias-Wert setzen
            this.biasTerm.textContent = this.BIAS_VALUE;
            
            // 5. Output-Wert initial zurücksetzen
            this.outputResult.textContent = 'z\'';
        }

        async runDenseAnimation() {
            if (this.isRunning) return;
            this.isRunning = true;
            
            // 1. Reset Zustände
            this.outputResult.textContent = 'z\'';
            this.outputResult.style.boxShadow = '';
            this.neuronNode.classList.remove('summing', 'activated');
            this.neuronNode.style.border = '3px solid #6c757d';
            this.biasTerm.style.boxShadow = '';
            this.neuronNode.style.boxShadow = '0 4px 10px rgba(0,0,0,0.1)';
            this.outputLineContainer.classList.remove('active');
            this.mathNotation.style.opacity = '1';
            this.accumulator.style.opacity = '0';
            this.accumulator.innerHTML = '';
            this.dotElements.forEach(dot => dot.setAttribute('opacity', '0'));


            // 2. SIMULTANER Datenfluss (Input * Weight)
            
            this.inputElements.forEach(el => el.style.boxShadow = '0 0 5px 2px var(--color-input)');
            this.weightBoxElements.forEach(box => {
                box.style.boxShadow = '0 0 5px 2px var(--color-weight)';
            });
            
            // Startet die Dot-Animation entlang der SVG-Pfade
            const totalDuration = this.FLOW_DURATION_MS;
            let startTime;
            
            const animateDots = (timestamp) => {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(1, elapsed / totalDuration);

                this.dotElements.forEach((dot, i) => {
                    const path = this.pathElements[i];
                    const totalLength = path.getTotalLength();
                    
                    const point = path.getPointAtLength(progress * totalLength);
                    
                    dot.setAttribute('cx', point.x);
                    dot.setAttribute('cy', point.y);
                    
                    if (progress > 0) {
                        dot.setAttribute('opacity', '1');
                    }
                });

                if (progress < 1) {
                    this.animationFrameId = requestAnimationFrame(animateDots);
                }
            };
            
            this.animationFrameId = requestAnimationFrame(animateDots);
            
            await this.wait(this.FLOW_DURATION_MS); 
            
            // Fließelemente zurücksetzen
            this.inputElements.forEach(el => el.style.boxShadow = '');
            this.weightBoxElements.forEach(box => {
                box.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            });
            this.dotElements.forEach(dot => {
                dot.setAttribute('opacity', '0');
                dot.setAttribute('cx', this.pathElements[0].getPointAtLength(0).x); 
                dot.setAttribute('cy', this.pathElements[0].getPointAtLength(0).y); 
            });
            
            
            // 3. Summierung und Bias-Addition (Schrittweise)
            this.neuronNode.classList.add('summing');
            this.mathNotation.style.opacity = '0';
            this.accumulator.style.opacity = '1';

            let currentSum = 0;
            let sumString = '';

            // Sequenzielle Addition der gewichteten Produkte
            for (let i = 0; i < this.INPUT_COUNT; i++) {
                const product = parseFloat(this.WEIGHTED_PRODUCTS[i]);
                currentSum += product;

                // Syntax für die Anzeige: x1w1, dann +x2w2 oder -x2w2
                const operator = (i === 0) ? '' : (product >= 0 ? ' + ' : ' - ');
                const displayProduct = (i === 0) ? product.toFixed(2) : Math.abs(product).toFixed(2);
                
                sumString += `<span style="color:var(--color-input);">${operator}x${i+1}w${i+1}</span>`;
                
                this.accumulator.innerHTML = `
                    <div style="font-size:0.85rem; margin-bottom: 5px; max-width: 90%; word-break: break-all;">${sumString}</div>
                    <div style="color:var(--color-input);">Zwischensumme: ${currentSum.toFixed(3)}</div>
                `;

                // Kurzes visuelles Highlight für den aktuellen Term
                this.inputElements[i].style.boxShadow = '0 0 5px 2px var(--pulse-color)';
                this.weightBoxElements[i].style.boxShadow = '0 0 5px 2px var(--pulse-color)';
                await this.wait(this.SUM_TERM_DELAY);
                this.inputElements[i].style.boxShadow = '';
                this.weightBoxElements[i].style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            }

            // Addition des Bias-Terms
            this.biasTerm.style.boxShadow = '0 0 10px 3px var(--color-bias)';
            sumString += ` + b`;
            this.accumulator.innerHTML = `
                <div style="font-size:0.85rem; margin-bottom: 5px; max-width: 90%; word-break: break-all;">${sumString}</div>
                <div style="color:var(--color-bias);">Summe Z: ${this.SUM_Z.toFixed(3)}</div>
            `;
            
            await this.wait(this.CALC_DELAY_MS);
            
            
            // 4. Aktivierungsfunktion (Sigma)
            this.neuronNode.classList.remove('summing');
            this.neuronNode.classList.add('activated');
            this.biasTerm.style.boxShadow = ''; 
            
            // Anzeige der Aktivierungsfunktion
            this.accumulator.innerHTML = `
                <div style="font-size:1rem; margin-bottom: 5px;">Z = ${this.SUM_Z.toFixed(3)}</div>
                <div style="font-size:1.5rem; color:var(--color-output);">&#x3C3;(Z)</div>
            `;
            
            await this.wait(this.CALC_DELAY_MS / 2);
            
            
            // 5. Output-Fluss
            this.outputLineContainer.classList.add('active'); 
            
            await this.wait(this.FLOW_DURATION_MS / 2);

            // 6. Output-Resultat
            this.outputResult.textContent = this.ACTIVATION_RESULT; 
            this.outputResult.style.boxShadow = '0 0 15px 5px var(--color-output)';

            await this.wait(this.CALC_DELAY_MS);
            
            
            // 7. Cleanup und Reset
            this.neuronNode.classList.remove('activated');
            this.neuronNode.style.border = '3px solid #6c757d';
            this.outputResult.style.boxShadow = '';
            this.neuronNode.style.boxShadow = '0 4px 10px rgba(0,0,0,0.1)';
            this.outputLineContainer.classList.remove('active');
            
            this.mathNotation.style.opacity = '1';
            this.accumulator.style.opacity = '0';

            this.isRunning = false;
        }
        
        startLoop() {
            const loop = () => {
                if (this.isRunning) {
                    this.animationFrameId = requestAnimationFrame(loop);
                    return;
                }
                
                this.INPUT_VALUES = this.generateInputValues();
                this.WEIGHT_VALUES = this.generateWeightValues();
                this.BIAS_VALUE = (Math.random() * 1 - 0.5).toFixed(2); 

                this.initElements(); 

                this.runDenseAnimation().then(() => {
                    setTimeout(() => {
                        this.animationFrameId = requestAnimationFrame(loop);
                    }, 1000); 
                });
            };

            this.animationFrameId = requestAnimationFrame(loop);
        }
        
        wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    // --- 4. Initialization Function ---
    window.make_dense_visual_explanation = function(selector = '.dense_visual_explanation', options = {}) {
        const containers = document.querySelectorAll(selector);
        containers.forEach(container => {
            if (!container.visualizer) {
                try {
                    const visualizer = new DenseVisualizer(container, options);
                    container.visualizer = visualizer; 
                } catch (error) {
                    console.error('Failed to initialize DenseVisualizer for element:', container, error);
                }
            }
        });
    };
    
    // Startet den Visualizer, sobald das DOM geladen ist.
    document.addEventListener('DOMContentLoaded', () => {
        window.make_dense_visual_explanation('.dense_visual_explanation', {
            inputCount: 4
        });
    });
    </script>
</head>
<body>
    
    <h1>Dense Layer (Neuron) Berechnung</h1>
    <h2>Finale Visualisierung: Gewichtete Konvergenz (Fully Connected)</h2>
    
    <div class="visualizer-container">
        <div class="dense_visual_explanation"></div>
    </div>
    
</body>
</html>
