<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dense Layer Visualizer (SVG Konvergenz)</title>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        h1 {
            color: #333;
            margin-bottom: 5px;
        }
        h2 {
            font-size: 1rem;
            color: #6c757d;
            margin-bottom: 20px;
        }
        .visualizer-container {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            /* Maximale Breite, um das Layout zu stabilisieren */
            max-width: 550px; 
            width: 95%;
        }
    </style>
    
    <script>
    /* ----------------------------------------------------
     * dense_visualizer_svg.js
     * Visualisiert die Berechnung eines einzelnen Neurons
     * NEU: Konvergente Synapsen in SVG für präzise Geometrie.
     * ---------------------------------------------------- */

    // --- 1. Encapsulated CSS ---
    function getDenseStyles(instanceId) {
        return `
        /* General setup for instance ${instanceId} */
        [data-dense-id="${instanceId}"] {
            /* Variables */
            --input-count: 4;
            --cell-size: 35px;
            --weight-box-width: 45px;
            --color-input: #333;
            --color-weight: #007bff;
            --color-bias: #ffc107;
            --color-output: #28a745;
            --flow-duration: 900ms; 
            --calc-delay: 1500ms; 
            --pulse-color: #ff0000; 
            --neuron-radius: 40px; /* VERGRÖSSERT, um Formeln einzuschließen */
            --output-color-light: #d4edda;
            --weight-color-light: #cce5ff;

            /* Page skeleton */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: Arial, sans-serif;
            padding: 0;
            box-sizing: border-box;
            width: 100%;
        }

        [data-dense-id="${instanceId}"] .dense-container {
            display: grid;
            /* Layout: Input | Gewicht | Neuron | Output */
            grid-template-columns: var(--cell-size) 20px var(--weight-box-width) 30px calc(2 * var(--neuron-radius)) 30px var(--cell-size);
            grid-template-rows: auto;
            align-items: center;
            gap: 0;
            position: relative;
            width: 100%;
            padding: 10px 0;
        }
        
        /* Input Vector (links) */
        [data-dense-id="${instanceId}"] .input-vector {
            grid-column: 1;
            grid-row: 1;
            display: flex;
            flex-direction: column; 
            gap: 5px;
            align-items: flex-end; 
            z-index: 10;
        }

        [data-dense-id="${instanceId}"] .input-val {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--color-input);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 4px;
            transition: box-shadow 0.2s;
        }

        /* SVG Overlay für die Synapsen-Linien (Konvergenz) */
        [data-dense-id="${instanceId}"] .synapse-svg-overlay {
            grid-column: 1 / span 5; /* Erstreckt sich über Input, Gewicht, Lücken und Neuron */
            grid-row: 1;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: visible;
            z-index: 5;
            pointer-events: none;
        }
        
        [data-dense-id="${instanceId}"] .synapse-line {
            stroke: var(--color-weight);
            stroke-linecap: round;
            fill: none;
            transition: stroke-width 0.2s, stroke 0.2s;
        }

        /* Gewichtswerte (in den blauen Boxen) */
        [data-dense-id="${instanceId}"] .weight-values {
            grid-column: 3;
            grid-row: 1;
            display: flex;
            flex-direction: column; 
            gap: 5px;
            align-items: center;
            z-index: 10;
        }

        [data-dense-id="${instanceId}"] .weight-box {
            width: var(--weight-box-width); 
            height: 25px; 
            background-color: var(--color-weight);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem; 
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-weight: bold;
            transition: box-shadow 0.2s, background-color 0.2s;
        }

        /* Das Neuron (Hauptknoten) */
        [data-dense-id="${instanceId}"] .neuron-node {
            grid-column: 5;
            grid-row: 1;
            width: calc(2 * var(--neuron-radius));
            height: calc(2 * var(--neuron-radius));
            background-color: #f8f9fa;
            border: 3px solid #6c757d;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; 
            font-size: 0.8rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: border-color var(--calc-delay) ease-in-out, background-color 0.1s, box-shadow 0.2s;
            z-index: 10;
        }
        
        /* Neuron Inhalt */
        [data-dense-id="${instanceId}"] .neuron-node .math-sum {
            font-size: 1.2rem;
            color: var(--color-input);
            margin-bottom: 2px;
        }

        [data-dense-id="${instanceId}"] .neuron-node .math-sigma {
            font-size: 1.2rem;
            color: var(--color-output);
            font-style: italic;
        }

        /* Bias Addition */
        [data-dense-id="${instanceId}"] .bias-term {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 30px;
            height: 30px;
            background-color: var(--color-bias);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.8rem;
            z-index: 20;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: box-shadow 0.2s;
        }

        /* Output Linie */
        [data-dense-id="${instanceId}"] .output-line-container {
            grid-column: 6;
            grid-row: 1;
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        [data-dense-id="${instanceId}"] .output-line {
            height: 2px;
            width: 100%; 
            background-color: var(--color-output);
            position: relative;
        }

        /* Output (Aktiviertes Ergebnis) */
        [data-dense-id="${instanceId}"] .output-result {
            grid-column: 7;
            grid-row: 1;
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--color-output);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1rem;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: box-shadow 0.3s;
            z-index: 10;
        }

        /* --- Signal-Dot (CSS Animation) --- */
        [data-dense-id="${instanceId}"] .signal-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--pulse-color); 
            opacity: 0;
            z-index: 30;
        }
        
        /* Animation auf SVG-Pfaden (wird in JS dynamisch über offset gesteuert) */
        
        /* Output Dot */
        @keyframes output-flow-animation {
            0% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(100%); }
        }

        [data-dense-id="${instanceId}"] .output-line-container.active .signal-dot {
            opacity: 1;
            /* Zentriert das Dot in Y-Richtung */
            top: calc(50% - 4px); 
            left: 0; 
            animation: output-flow-animation calc(var(--flow-duration) / 2) linear forwards;
        }

        /* Highlight-Zustände */
        [data-dense-id="${instanceId}"] .neuron-node.summing {
            border-color: var(--color-bias);
            background-color: rgba(255, 193, 7, 0.2);
            box-shadow: 0 0 15px 5px var(--color-bias);
        }
        [data-dense-id="${instanceId}"] .neuron-node.activated {
            border-color: var(--color-output);
            background-color: var(--output-color-light);
            box-shadow: 0 0 15px 5px var(--color-output);
        }
        `;
    }

    // --- 2. HTML Template ---
    function getDenseHtml(instanceId) {
        return `
        <div class="dense-container" data-dense-id="${instanceId}" role="region" aria-label="Dense Layer Neuron Calculation Demo">
            
            <div class="input-vector" data-element-type="inputVector">
                </div>
            
            <svg class="synapse-svg-overlay" data-element-type="synapseSvg" preserveAspectRatio="none">
                <g data-element-type="synapseGroup">
                    </g>
            </svg>

            <div class="weight-values" data-element-type="weightValues">
                </div>
            
            <div class="neuron-node" data-element-type="neuronNode">
                <div class="bias-term" data-element-type="biasTerm">b</div> 
                <div class="math-sum">
                    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>&#x2211;</mo><msub><mi>x</mi><mi>i</mi></msub><msub><mi>w</mi><mi>i</mi></msub></math>
                </div>
                <div class="math-sigma">
                    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>&#x3C3;</mi><mo>(</mo><mi>z</mi><mo>)</mo></math>
                </div>
            </div>

            <div class="output-line-container" data-element-type="outputLineContainer">
                <div class="output-line">
                    <div class="signal-dot"></div>
                </div>
            </div>

            <div class="output-result" data-element-type="outputResult">
                z'
            </div>
        </div>
        
        <div style="margin-top: 15px; font-style: italic; font-size: 0.9rem;">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                <msup>
                    <mi>z</mi>
                    <mo>′</mo>
                </msup>
                <mo>=</mo>
                <mi>&#x3C3;</mi>
                <mfenced open="(" close=")">
                    <mfenced open="(" close=")">
                        <munderover>
                            <mo>&#x2211;</mo>
                            <mrow>
                                <mi>i</mi>
                                <mo>=</mo>
                                <mn>1</mn>
                            </munderover>
                        <mi>N</mi>
                        </mfenced>
                        <mo>+</mo>
                        <mi>b</mi>
                    </mfenced>
                </math>
            </math>
        </div>
        `;
    }

    // --- 3. DenseVisualizer Class ---
    class DenseVisualizer {
        constructor(containerElement, options = {}) {
            if (!containerElement) throw new Error('Container element is required.');

            this.container = containerElement;
            this.instanceId = 'dense-instance-' + Math.random().toString(36).substring(2, 9);
            this.isRunning = false;
            this.animationFrameId = null;

            // Constants
            this.INPUT_COUNT = options.inputCount || 4;
            this.CELL_SIZE = 35; 
            this.WEIGHT_BOX_WIDTH = 45;
            this.WEIGHT_LINE_HEIGHT = this.CELL_SIZE + 5; 
            this.NEURON_RADIUS = 40;
            this.FLOW_DURATION_MS = 900;
            this.CALC_DELAY_MS = 1500;
            
            // Data
            this.INPUT_VALUES = options.inputValues || this.generateInputValues();
            this.WEIGHT_VALUES = options.weightValues || this.generateWeightValues();
            this.BIAS_VALUE = options.biasValue || 0.5;

            this.setupDOM();
            this.initElements();
            
            this.startLoop();
        }

        generateInputValues() {
            return Array.from({ length: this.INPUT_COUNT }, () => (Math.random() * 2 - 1).toFixed(2));
        }

        generateWeightValues() {
            return Array.from({ length: this.INPUT_COUNT }, () => (Math.random() * 2 - 1).toFixed(2));
        }

        setupDOM() {
            const style = document.createElement('style');
            style.setAttribute('data-dense-instance-id', this.instanceId);
            style.textContent = getDenseStyles(this.instanceId);
            document.head.appendChild(style);

            this.container.setAttribute('data-dense-id', this.instanceId);
            this.container.innerHTML = getDenseHtml(this.instanceId);

            this.container.style.setProperty('--input-count', String(this.INPUT_COUNT));
            this.container.style.setProperty('--neuron-radius', this.NEURON_RADIUS + 'px');
            this.container.style.setProperty('--flow-duration', this.FLOW_DURATION_MS + 'ms');
            this.container.style.setProperty('--calc-delay', this.CALC_DELAY_MS + 'ms');
        }

        initElements() {
            // Element References
            this.inputVector = this.container.querySelector('[data-element-type="inputVector"]');
            this.weightValuesContainer = this.container.querySelector('[data-element-type="weightValues"]');
            this.synapseGroup = this.container.querySelector('[data-element-type="synapseGroup"]');
            this.synapseSvg = this.container.querySelector('[data-element-type="synapseSvg"]');
            this.outputLineContainer = this.container.querySelector('[data-element-type="outputLineContainer"]');
            this.biasTerm = this.container.querySelector('[data-element-type="biasTerm"]');
            this.outputResult = this.container.querySelector('[data-element-type="outputResult"]');
            this.neuronNode = this.container.querySelector('[data-element-type="neuronNode"]');
            this.denseContainer = this.container.querySelector('.dense-container');

            this.inputVector.innerHTML = '';
            this.weightValuesContainer.innerHTML = '';
            this.synapseGroup.innerHTML = '';
            
            this.inputElements = [];
            this.weightBoxElements = [];
            this.pathElements = [];
            this.dotElements = [];

            // --- Geometrie-Berechnung ---
            
            const FLOW_HEIGHT = this.INPUT_COUNT * this.WEIGHT_LINE_HEIGHT; 
            const PADDING_Y = 10; // Padding oben/unten vom dense-container
            const TOTAL_HEIGHT = FLOW_HEIGHT + 2 * PADDING_Y; 
            
            // Setze die Höhe des SVG-Containers
            this.synapseSvg.style.height = TOTAL_HEIGHT + 'px';
            this.synapseSvg.setAttribute('height', TOTAL_HEIGHT);
            
            // Y-Mitte des gesamten Flows (Neuron-Zentrum Y)
            const NEURON_CENTER_Y = TOTAL_HEIGHT / 2; 

            // Feste X-Positionen (Relativ zum Start des SVG-Containers/Input-Links)
            const INPUT_RIGHT_X = this.CELL_SIZE; 
            const WEIGHT_BOX_LEFT_X = INPUT_RIGHT_X + 20; // + 20px Lücke
            const NEURON_LEFT_EDGE_X = WEIGHT_BOX_LEFT_X + this.WEIGHT_BOX_WIDTH + 30; // + 30px Lücke

            const NEURON_ENTRY_X = NEURON_LEFT_EDGE_X; 

            // Max. Gewichtswert (für die Skalierung der Liniendicke)
            const maxAbsWeight = Math.max(1e-6, ...this.WEIGHT_VALUES.map(w => Math.abs(parseFloat(w))));

            for (let i = 0; i < this.INPUT_COUNT; i++) {
                const inputVal = parseFloat(this.INPUT_VALUES[i]);
                const weightVal = parseFloat(this.WEIGHT_VALUES[i]);
                
                // Y-Position der Mitte der aktuellen Zeile
                const LINE_CENTER_Y = PADDING_Y + i * this.WEIGHT_LINE_HEIGHT + this.WEIGHT_LINE_HEIGHT / 2;
                
                // 1. Input-Element
                const inputDiv = document.createElement('div');
                inputDiv.classList.add('input-val');
                inputDiv.textContent = inputVal.toFixed(2);
                this.inputVector.appendChild(inputDiv);
                this.inputElements.push(inputDiv);
                
                // 2. Weight-Box (zeigt den Wert)
                const weightBox = document.createElement('div');
                weightBox.classList.add('weight-box');
                weightBox.textContent = weightVal.toFixed(2); 
                this.weightValuesContainer.appendChild(weightBox);
                this.weightBoxElements.push(weightBox);
                
                // --- Synapsen-Berechnung (SVG) ---
                
                // Startpunkt der Linie (Mitte Input-Rechts)
                const P0_X = INPUT_RIGHT_X;
                const P0_Y = LINE_CENTER_Y;

                // Punkt 1 (Ende der horizontalen Linie zum Gewicht)
                const P1_X = WEIGHT_BOX_LEFT_X; 
                const P1_Y = LINE_CENTER_Y;

                // Punkt 2 (Start der Diagonale, rechte Kante des Gewichts)
                const P2_X = WEIGHT_BOX_LEFT_X + this.WEIGHT_BOX_WIDTH;
                const P2_Y = LINE_CENTER_Y;

                // Endpunkt (Neuron-Kante)
                const P3_X = NEURON_ENTRY_X;
                const P3_Y = NEURON_CENTER_Y;
                
                // SVG Path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                // Path: M (MoveTo P0) L (LineTo P1) L (LineTo P2) L (LineTo P3)
                const d = `M${P0_X},${P0_Y} L${P1_X},${P1_Y} M${P2_X},${P2_Y} L${P3_X},${P3_Y}`;
                path.setAttribute('d', d);
                path.classList.add('synapse-line');

                // Visualisierung der Gewichtung (Dicke)
                const absWeightNormalized = Math.abs(weightVal / maxAbsWeight);
                const thickness = 2 + 3 * absWeightNormalized; // Dicke zwischen 2px und 5px
                path.setAttribute('stroke-width', thickness);
                
                this.synapseGroup.appendChild(path);
                this.pathElements.push(path);
                
                // --- Signal-Dot (SVG Circle) ---
                
                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                dot.setAttribute('r', '4');
                dot.setAttribute('fill', 'var(--pulse-color)');
                dot.setAttribute('opacity', '0'); 
                
                // Setze den Startpunkt des Dots (Mitte P0)
                dot.setAttribute('cx', P0_X);
                dot.setAttribute('cy', P0_Y);
                dot.style.transition = 'opacity 0.1s';
                
                this.synapseGroup.appendChild(dot);
                this.dotElements.push(dot);
            }
            
            // 3. Bias-Wert setzen
            this.biasTerm.textContent = this.BIAS_VALUE;
            
            // 4. Output-Wert initial zurücksetzen
            this.outputResult.textContent = 'z\'';
        }

        async runDenseAnimation() {
            if (this.isRunning) return;
            this.isRunning = true;
            
            // 1. Reset Zustände
            this.outputResult.textContent = 'z\'';
            this.outputResult.style.boxShadow = '';
            this.neuronNode.classList.remove('summing', 'activated');
            this.neuronNode.style.border = '3px solid #6c757d';
            this.biasTerm.style.boxShadow = '';
            this.neuronNode.style.boxShadow = '0 4px 10px rgba(0,0,0,0.1)';
            this.outputLineContainer.classList.remove('active');
            this.dotElements.forEach(dot => dot.setAttribute('opacity', '0'));


            // 2. SIMULTANER Datenfluss (Input * Weight)
            
            this.inputElements.forEach(el => el.style.boxShadow = '0 0 5px 2px var(--color-input)');
            this.weightBoxElements.forEach(box => {
                box.style.boxShadow = '0 0 5px 2px var(--color-weight)';
            });
            
            // Animation der SVG-Dots entlang der Pfade
            this.dotElements.forEach((dot, i) => {
                const path = this.pathElements[i];
                const totalLength = path.getTotalLength();
                
                // Setze die CSS-Variable für die Flow-Länge im SVG
                dot.style.setProperty('--flow-path-length', totalLength + 'px');
                
                dot.setAttribute('opacity', '1');
                
                // Animation über keyframes (Offset wird über CSS gesteuert)
                dot.style.transition = `transform ${this.FLOW_DURATION_MS}ms linear`;
                dot.style.transform = `translateX(${totalLength}px)`; 
            });

            await this.wait(this.FLOW_DURATION_MS); 
            
            // Fließelemente zurücksetzen
            this.inputElements.forEach(el => el.style.boxShadow = '');
            this.weightBoxElements.forEach(box => {
                box.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            });
            this.dotElements.forEach(dot => {
                dot.setAttribute('opacity', '0');
                dot.style.transition = 'none'; // Entferne Transition für sofortigen Reset
                dot.style.transform = 'translateX(0)';
            });
            
            // 3. Summierung und Bias-Addition
            this.neuronNode.classList.add('summing');
            this.biasTerm.style.boxShadow = '0 0 10px 3px var(--color-bias)';
            
            await this.wait(this.CALC_DELAY_MS);
            
            
            // 4. Aktivierungsfunktion (Sigma)
            this.neuronNode.classList.remove('summing');
            this.neuronNode.classList.add('activated');
            this.biasTerm.style.boxShadow = ''; 
            
            await this.wait(this.CALC_DELAY_MS / 2);
            
            
            // 5. Output-Fluss
            this.outputLineContainer.classList.add('active'); 
            
            await this.wait(this.FLOW_DURATION_MS / 2);

            // 6. Output-Resultat
            this.outputResult.textContent = '0.9'; 
            this.outputResult.style.boxShadow = '0 0 15px 5px var(--color-output)';

            await this.wait(this.CALC_DELAY_MS);
            
            
            // 7. Cleanup und Reset
            this.neuronNode.classList.remove('activated');
            this.neuronNode.style.border = '3px solid #6c757d';
            this.outputResult.style.boxShadow = '';
            this.neuronNode.style.boxShadow = '0 4px 10px rgba(0,0,0,0.1)';
            this.outputLineContainer.classList.remove('active');

            this.isRunning = false;
        }
        
        startLoop() {
            const loop = () => {
                if (this.isRunning) {
                    this.animationFrameId = requestAnimationFrame(loop);
                    return;
                }
                
                // Neue Zufallswerte 
                this.INPUT_VALUES = this.generateInputValues();
                this.WEIGHT_VALUES = this.generateWeightValues();
                this.BIAS_VALUE = (Math.random() * 1 - 0.5).toFixed(2); 

                this.initElements(); 

                this.runDenseAnimation().then(() => {
                    setTimeout(() => {
                        this.animationFrameId = requestAnimationFrame(loop);
                    }, 1000); 
                });
            };

            this.animationFrameId = requestAnimationFrame(loop);
        }
        
        wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    // --- 4. Initialization Function ---
    window.make_dense_visual_explanation = function(selector = '.dense_visual_explanation', options = {}) {
        const containers = document.querySelectorAll(selector);
        containers.forEach(container => {
            if (!container.visualizer) {
                try {
                    const visualizer = new DenseVisualizer(container, options);
                    container.visualizer = visualizer; 
                } catch (error) {
                    console.error('Failed to initialize DenseVisualizer for element:', container, error);
                }
            }
        });
    };
    
    // Startet den Visualizer, sobald das DOM geladen ist.
    document.addEventListener('DOMContentLoaded', () => {
        window.make_dense_visual_explanation('.dense_visual_explanation', {
            inputCount: 4
        });
    });
    </script>
</head>
<body>
    
    <h1>Dense Layer (Neuron) Berechnung</h1>
    <h2>Finale Visualisierung: Gewichtete Konvergenz (Fully Connected)</h2>
    
    <div class="visualizer-container">
        <div class="dense_visual_explanation"></div>
    </div>
    
</body>
</html>
