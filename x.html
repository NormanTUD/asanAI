<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dense Layer Visualizer (SVG Konvergenz - Final & Mathematisch)</title>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        h1 {
            color: #333;
            margin-bottom: 5px;
        }
        h2 {
            font-size: 1rem;
            color: #6c757d;
            margin-bottom: 20px;
        }
        .visualizer-container {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            /* Maximale Breite, um das Layout zu stabilisieren */
            max-width: 550px; 
            width: 95%;
        }
    </style>
    
    <script>
    /* ----------------------------------------------------
     * dense_visualizer_svg_v8.js
     * Finale Visualisierung: Langsam, 5-Schritt-Logik, sanfter Soft Glow und Formel-Fit.
     * ---------------------------------------------------- */

    // --- 1. Encapsulated CSS ---
    // --- 1. Encapsulated CSS (UPDATED) ---
    function getDenseStyles(instanceId) {
        return `
        /* General setup for instance ${instanceId} */
        [data-dense-id="${instanceId}"] {
            /* Variables */
            --input-count: 4;
            --cell-size: 35px;
            --weight-box-width: 45px;
            --weight-line-height: 40px; 
            --color-input: #333;
            --color-weight: #007bff;
            --color-bias: #ffc107;
            --color-output: #28a745;
            /* Längere Dauer für das Verlangsamen der Animation */
            --flow-duration: 1800ms; 
            --calc-delay: 3000ms; 
            --pulse-color: #ff0000; 
            --neuron-radius: 55px; /* Etwas größer für Formel-Fit */
            --output-color-light: #d4edda;
            --highlight-color: #dc3545; /* Dezente Highlight-Farbe */

            /* Page skeleton */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: Arial, sans-serif;
            padding: 0;
            box-sizing: border-box;
            width: 100%;
        }

        [data-dense-id="${instanceId}"] .dense-container {
            display: grid;
            grid-template-columns: var(--cell-size) 20px var(--weight-box-width) 30px calc(2 * var(--neuron-radius)) 30px var(--cell-size);
            grid-template-rows: auto;
            align-items: center;
            gap: 0;
            position: relative;
            width: 100%;
            padding: 10px 0;
        }
        
        /* Input Vector (links) */
        [data-dense-id="${instanceId}"] .input-vector {
            grid-column: 1;
            grid-row: 1;
            display: flex;
            flex-direction: column; 
            gap: 5px;
            align-items: flex-end; 
            z-index: 10;
        }

        /* Input/Weight Base Styles */
        [data-dense-id="${instanceId}"] .input-val,
        [data-dense-id="${instanceId}"] .weight-box {
            transition: box-shadow 0.2s, background-color 0.2s; 
        }

        [data-dense-id="${instanceId}"] .input-val {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--color-input);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 4px;
        }
        
        [data-dense-id="${instanceId}"] .weight-box {
            width: var(--weight-box-width); 
            height: 25px; 
            background-color: var(--color-weight);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem; 
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-weight: bold;
            z-index: 20; 
        }
        
        /* SVG Overlay */
        [data-dense-id="${instanceId}"] .synapse-svg-overlay {
            grid-column: 1 / span 5; 
            grid-row: 1;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; 
            z-index: 5;
            pointer-events: none;
        }
        
        [data-dense-id="${instanceId}"] .synapse-line {
            stroke: var(--color-weight);
            stroke-linecap: round;
            fill: none;
            transition: stroke-width 0.2s, stroke 0.2s;
        }

        /* Gewichtswerte (Alignment Fix) */
        [data-dense-id="${instanceId}"] .weight-values {
            grid-column: 3;
            grid-row: 1;
            display: flex;
            flex-direction: column; 
            align-items: center;
            z-index: 10;
        }
        
        [data-dense-id="${instanceId}"] .weight-box-wrapper {
            display: flex;
            align-items: center; 
            justify-content: center;
            height: var(--weight-line-height); 
            width: 100%;
        }


        /* Das Neuron (Hauptknoten) */
        [data-dense-id="${instanceId}"] .neuron-node {
            grid-column: 5;
            grid-row: 1;
            width: calc(2 * var(--neuron-radius));
            height: calc(2 * var(--neuron-radius));
            background-color: #f8f9fa;
            border: 3px solid #6c757d;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; 
            font-size: 0.8rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: border-color var(--calc-delay) ease-in-out, background-color 0.1s, box-shadow 0.2s;
            z-index: 10;
        }
        
        /* Initial/Final Notation (UPDATED) */
        [data-dense-id="${instanceId}"] .math-notation {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 1;
            transition: opacity 0.3s;
            /* Wichtig: Line-Height reduzieren, um MathML-Höhe zu reduzieren */
            line-height: 0.5; 
            /* Wichtig: Abstand zwischen den Formeln reduzieren */
            gap: 2px;
        }
        
        /* MathML-Elemente in math-notation (Zusätzlich: Ausrichtung fixen) */
        [data-dense-id="${instanceId}"] .math-notation .math-sum,
        [data-dense-id="${instanceId}"] .math-notation .math-sigma {
            /* Zentrierung auf der Zeile erzwingen, um Versatz zu verhindern */
            display: flex; 
            align-items: center;
            justify-content: center;
            height: 40%; /* Relative Höhe im Container */
        }

        /* Accumulator (für schrittweise Summierung) */
        [data-dense-id="${instanceId}"] .accumulator {
            font-weight: bold;
            min-height: 50px; 
            padding: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
            text-align: center;
            line-height: 1.2;
            overflow: hidden; 
        }
        
        /* Formel für Z (Angepasst für besseren Fit) */
        [data-dense-id="${instanceId}"] .accumulator .Z-formula {
            font-size: 1.1rem; /* Reduzierte Größe für besseren Fit */
            color: var(--color-input);
            min-height: 1.1em; 
            max-width: 90%;
            word-break: break-all;
        }
        
        /* Formel für Sigma */
        [data-dense-id="${instanceId}"] .accumulator .Sigma-formula {
            font-size: 1.5rem;
            color: var(--color-output);
            font-style: italic;
        }

        /* Highlight-Zustände */
        [data-dense-id="${instanceId}"] .neuron-node.summing {
            border-color: var(--color-bias);
            background-color: rgba(255, 193, 7, 0.2);
            box-shadow: 0 0 15px 5px var(--color-bias);
        }
        [data-dense-id="${instanceId}"] .neuron-node.activated {
            border-color: var(--color-output);
            background-color: var(--output-color-light);
            box-shadow: 0 0 15px 5px var(--color-output);
        }

        /* Bias Addition */
        [data-dense-id="${instanceId}"] .bias-term {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 30px;
            height: 30px;
            background-color: var(--color-bias);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.8rem;
            z-index: 30;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: box-shadow 0.2s;
        }

        /* Output Linie & Dot */
        [data-dense-id="${instanceId}"] .output-line-container {
            grid-column: 6;
            grid-row: 1;
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        [data-dense-id="${instanceId}"] .output-line {
            height: 2px;
            width: 100%; 
            background-color: var(--color-output);
            position: relative;
        }
        
        @keyframes output-flow-animation {
            0% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(100%); }
        }

        [data-dense-id="${instanceId}"] .output-line-container.active .signal-dot {
            opacity: 1;
            top: calc(50% - 4px); 
            left: 0; 
            animation: output-flow-animation calc(var(--flow-duration) / 2) linear forwards;
        }
        
        /* Output (Aktiviertes Ergebnis) */
        [data-dense-id="${instanceId}"] .output-result {
            grid-column: 7;
            grid-row: 1;
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--color-output);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1rem;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: box-shadow 0.3s;
            z-index: 10;
        }
        `;
    }

    // --- 2. HTML Template ---
    function getDenseHtml(instanceId) {
        return `
        <div class="dense-container" data-dense-id="${instanceId}" role="region" aria-label="Dense Layer Neuron Calculation Demo">
            
            <div class="input-vector" data-element-type="inputVector">
                </div>
            
            <svg class="synapse-svg-overlay" data-element-type="synapseSvg" preserveAspectRatio="none">
                <g data-element-type="synapseGroup">
                    </g>
            </svg>

            <div class="weight-values" data-element-type="weightValues">
                </div>
            
            <div class="neuron-node" data-element-type="neuronNode">
                <div class="bias-term" data-element-type="biasTerm">b</div> 
                
                <div class="accumulator" data-element-type="accumulator"></div> 

                <div class="math-notation" data-element-type="mathNotation">
                    <div class="math-sum">
                        <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" style="font-size: 0.9rem;"><mo>&#x2211;</mo><msub><mi>x</mi><mi>i</mi></msub><msub><mi>w</mi><mi>i</mi></msub></math>
                    </div>
                    <div class="math-sigma">
                        <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" style="font-size: 1.4rem;"><mi>&#x3C3;</mi><mo>(</mo><mi>z</mi><mo>)</mo></math>
                    </div>
                </div>
            </div>

            <div class="output-line-container" data-element-type="outputLineContainer">
                <div class="output-line">
                    <div class="signal-dot"></div>
                </div>
            </div>

            <div class="output-result" data-element-type="outputResult">
                z'
            </div>
        </div>
        
        <div style="margin-top: 15px; font-style: italic; font-size: 0.9rem;">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                <msup>
                    <mi>z</mi>
                    <mo>′</mo>
                </msup>
                <mo>=</mo>
                <mi>&#x3C3;</mi>
                <mfenced open="(" close=")">
                    <mi>z</mi>
                </mfenced>
                <mtext> wobei </mtext>
                 <mi>z</mi>
                <mo>=</mo>
                <munderover>
                    <mo>&#x2211;</mo>
                    <mrow>
                        <mi>i</mi>
                        <mo>=</mo>
                        <mn>1</mn>
                    </munderover>
                <mi>N</mi>
                    <msub>
                        <mi>x</mi>
                        <mi>i</mi>
                    </msub>
                    <msub>
                        <mi>w</mi>
                    </msub>
                    <mi>i</mi>
                <mo>+</mo>
                <mi>b</mi>
            </math>
        </div>
        `;
    }

    // --- 3. DenseVisualizer Class ---
    class DenseVisualizer {
        constructor(containerElement, options = {}) {
            if (!containerElement) throw new Error('Container element is required.');

            this.container = containerElement;
            this.instanceId = 'dense-instance-' + Math.random().toString(36).substring(2, 9);
            this.isRunning = false;
            this.animationFrameId = null;

            // Constants (LANGSAMER)
            this.INPUT_COUNT = options.inputCount || 4;
            this.CELL_SIZE = 35; 
            this.WEIGHT_BOX_WIDTH = 45;
            this.WEIGHT_LINE_HEIGHT = 40; 
            this.NEURON_RADIUS = 55; // Slightly increased
            this.FLOW_DURATION_MS = 1800; 
            this.CALC_DELAY_MS = 3000; 
            this.STEP_DELAY_MS = 1200; // Time between detailed steps
            this.INITIAL_Z_DELAY = 1500; 
            this.BLINK_DURATION_MS = 600; // Duration of the single glow pulse
            
            // Data
            this.INPUT_VALUES = options.inputValues || this.generateInputValues();
            this.WEIGHT_VALUES = options.weightValues || this.generateWeightValues();
            this.BIAS_VALUE = options.biasValue || 0.5;

            this.setupDOM();
            this.initElements();
            
            this.startLoop();
        }

        generateInputValues() {
            return Array.from({ length: this.INPUT_COUNT }, () => (Math.random() * 2 - 1).toFixed(2));
        }

        generateWeightValues() {
            return Array.from({ length: this.INPUT_COUNT }, () => (Math.random() * 2 - 1).toFixed(2));
        }

        setupDOM() {
            const style = document.createElement('style');
            style.setAttribute('data-dense-instance-id', this.instanceId);
            style.textContent = getDenseStyles(this.instanceId);
            document.head.appendChild(style);

            this.container.setAttribute('data-dense-id', this.instanceId);
            this.container.innerHTML = getDenseHtml(this.instanceId);

            this.container.style.setProperty('--input-count', String(this.INPUT_COUNT));
            this.container.style.setProperty('--neuron-radius', this.NEURON_RADIUS + 'px');
            this.container.style.setProperty('--flow-duration', this.FLOW_DURATION_MS + 'ms');
            this.container.style.setProperty('--calc-delay', this.CALC_DELAY_MS + 'ms');
            this.container.style.setProperty('--weight-line-height', this.WEIGHT_LINE_HEIGHT + 'px');
        }

        initElements() {
            // Element References
            this.inputVector = this.container.querySelector('[data-element-type="inputVector"]');
            this.weightValuesContainer = this.container.querySelector('[data-element-type="weightValues"]');
            this.synapseGroup = this.container.querySelector('[data-element-type="synapseGroup"]');
            this.synapseSvg = this.container.querySelector('[data-element-type="synapseSvg"]');
            this.outputLineContainer = this.container.querySelector('[data-element-type="outputLineContainer"]');
            this.biasTerm = this.container.querySelector('[data-element-type="biasTerm"]');
            this.outputResult = this.container.querySelector('[data-element-type="outputResult"]');
            this.neuronNode = this.container.querySelector('[data-element-type="neuronNode"]');
            this.accumulator = this.container.querySelector('[data-element-type="accumulator"]');
            this.mathNotation = this.container.querySelector('[data-element-type="mathNotation"]');


            this.inputVector.innerHTML = '';
            this.weightValuesContainer.innerHTML = '';
            this.synapseGroup.innerHTML = '';
            
            this.inputElements = [];
            this.weightBoxElements = [];
            this.pathElements = [];
            this.dotElements = [];

            // Berechnung der gewichteten Produkte und des finalen Ergebnisses
            this.WEIGHTED_PRODUCTS = this.INPUT_VALUES.map((x, i) => 
                (parseFloat(x) * parseFloat(this.WEIGHT_VALUES[i])).toFixed(3)
            );
            this.SUM_Z_NO_BIAS = this.WEIGHTED_PRODUCTS.reduce((sum, p) => sum + parseFloat(p), 0);
            this.SUM_Z = this.SUM_Z_NO_BIAS + parseFloat(this.BIAS_VALUE);
            this.ACTIVATION_RESULT = (1 / (1 + Math.exp(-this.SUM_Z))).toFixed(3); // Sigmoid-Funktion
            
            this.accumulator.innerHTML = '';
            this.mathNotation.style.opacity = '1';

            // --- Geometrie-Berechnung (unverändert) ---
            
            const PADDING_Y = 10; 
            const TOTAL_HEIGHT = this.INPUT_COUNT * this.WEIGHT_LINE_HEIGHT + 2 * PADDING_Y; 
            
            this.synapseSvg.style.height = TOTAL_HEIGHT + 'px';
            this.synapseSvg.setAttribute('height', TOTAL_HEIGHT);
            
            // ... (Geometrie Code bleibt gleich) ...

            const NEURON_CENTER_Y = TOTAL_HEIGHT / 2; 
            const INPUT_RIGHT_X = this.CELL_SIZE; 
            const WEIGHT_BOX_LEFT_X = INPUT_RIGHT_X + 20; 
            const WEIGHT_BOX_RIGHT_X = WEIGHT_BOX_LEFT_X + this.WEIGHT_BOX_WIDTH; 
            const NEURON_LEFT_EDGE_X = WEIGHT_BOX_RIGHT_X + 30; 
            const NEURON_ENTRY_X = NEURON_LEFT_EDGE_X; 
            const maxAbsWeight = Math.max(1e-6, ...this.WEIGHT_VALUES.map(w => Math.abs(parseFloat(w))));

            for (let i = 0; i < this.INPUT_COUNT; i++) {
                const inputVal = parseFloat(this.INPUT_VALUES[i]);
                const weightVal = parseFloat(this.WEIGHT_VALUES[i]);
                
                const LINE_CENTER_Y = PADDING_Y + i * this.WEIGHT_LINE_HEIGHT + this.WEIGHT_LINE_HEIGHT / 2;
                
                // 1. Input-Element
                const inputDiv = document.createElement('div');
                inputDiv.classList.add('input-val');
                inputDiv.textContent = inputVal.toFixed(2);
                this.inputVector.appendChild(inputDiv);
                this.inputElements.push(inputDiv);
                
                // 2. Weight-Box (mit Wrapper für Zentrierung)
                const weightWrapper = document.createElement('div');
                weightWrapper.classList.add('weight-box-wrapper'); 
                
                const weightBox = document.createElement('div');
                weightBox.classList.add('weight-box');
                weightBox.textContent = weightVal.toFixed(2); 
                
                weightWrapper.appendChild(weightBox);
                this.weightValuesContainer.appendChild(weightWrapper);
                this.weightBoxElements.push(weightBox);
                
                // --- Synapsen-Berechnung (SVG) ---
                const P_A_X = INPUT_RIGHT_X;
                const P_A_Y = LINE_CENTER_Y;
                const P_B_X = WEIGHT_BOX_LEFT_X; 
                const P_C_X = WEIGHT_BOX_RIGHT_X; 
                const P_D_X = NEURON_ENTRY_X;
                const P_D_Y = NEURON_CENTER_Y;
                
                const d = `M ${P_A_X},${P_A_Y} L ${P_B_X},${P_A_Y} M ${P_C_X},${P_A_Y} L ${P_D_X},${P_D_Y}`;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', d);
                path.classList.add('synapse-line');
                const absWeightNormalized = Math.abs(weightVal / maxAbsWeight);
                const thickness = 2 + 3 * absWeightNormalized; 
                path.setAttribute('stroke-width', thickness);
                
                this.synapseGroup.appendChild(path);
                this.pathElements.push(path);
                
                // 3. Signal-Dot (SVG Circle)
                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                dot.setAttribute('r', '4');
                dot.setAttribute('fill', 'var(--pulse-color)');
                dot.setAttribute('opacity', '0'); 
                dot.setAttribute('cx', P_A_X);
                dot.setAttribute('cy', P_A_Y);
                dot.style.transition = 'opacity 0.1s';
                
                this.synapseGroup.appendChild(dot);
                this.dotElements.push(dot);
            }
            
            // 4. Bias-Wert setzen
            this.biasTerm.textContent = this.BIAS_VALUE;
            
            // 5. Output-Wert initial zurücksetzen
            this.outputResult.textContent = 'z\'';
        }

        // Hilfsfunktion für den sanften Glow (ersetzt penetrantes Blinken)
        async toggleSoftGlow(element, duration, colorVar) {
            const originalBoxShadow = element.style.boxShadow || '';
            const color = getComputedStyle(this.container).getPropertyValue(colorVar).trim();
            
            element.style.boxShadow = `0 0 8px 3px ${color}`; 
            await this.wait(duration);
            element.style.boxShadow = originalBoxShadow; 
        }

        async runDenseAnimation() {
            if (this.isRunning) return;
            this.isRunning = true;
            
            // 1. Reset Zustände
            this.outputResult.textContent = 'z\'';
            this.outputResult.style.boxShadow = '';
            this.neuronNode.classList.remove('summing', 'activated');
            this.neuronNode.style.border = '3px solid #6c757d';
            this.biasTerm.style.boxShadow = '';
            this.neuronNode.style.boxShadow = '0 4px 10px rgba(0,0,0,0.1)';
            this.outputLineContainer.classList.remove('active');
            this.mathNotation.style.opacity = '1';
            this.accumulator.style.opacity = '0';
            this.accumulator.innerHTML = '';
            this.dotElements.forEach(dot => dot.setAttribute('opacity', '0'));


            // 2. SIMULTANER Datenfluss (Input * Weight)
            
            // Highlight Input und Weights (Soft)
            this.inputElements.forEach(el => el.style.boxShadow = '0 0 5px 2px var(--color-input)');
            this.weightBoxElements.forEach(box => {
                box.style.boxShadow = '0 0 5px 2px var(--color-weight)';
            });
            
            // Animierter Fluss (Punkte)
            const totalDuration = this.FLOW_DURATION_MS;
            let startTime;
            
            const animateDots = (timestamp) => {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(1, elapsed / totalDuration);

                this.dotElements.forEach((dot, i) => {
                    const path = this.pathElements[i];
                    const totalLength = path.getTotalLength();
                    const point = path.getPointAtLength(progress * totalLength);
                    
                    dot.setAttribute('cx', point.x);
                    dot.setAttribute('cy', point.y);
                    
                    if (progress > 0) {
                        dot.setAttribute('opacity', '1');
                    }
                });

                if (progress < 1) {
                    this.animationFrameId = requestAnimationFrame(animateDots);
                }
            };
            
            this.animationFrameId = requestAnimationFrame(animateDots);
            
            await this.wait(this.FLOW_DURATION_MS); 
            
            // Fließelemente zurücksetzen
            this.inputElements.forEach(el => el.style.boxShadow = '');
            this.weightBoxElements.forEach(box => {
                box.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            });
            this.dotElements.forEach(dot => {
                dot.setAttribute('opacity', '0');
                dot.setAttribute('cx', this.pathElements[0].getPointAtLength(0).x); 
                dot.setAttribute('cy', this.pathElements[0].getPointAtLength(0).y); 
            });
            
            
            // 3. Summierung und Bias-Addition (Schrittweise - Explizite Multiplikation)
            this.neuronNode.classList.add('summing');
            this.mathNotation.style.opacity = '0';
            this.accumulator.style.opacity = '1';

            let currentSum = 0;
            // Initialisiere Z = 0
            this.accumulator.innerHTML = `<div class="Z-formula">Z = 0</div>`;
            await this.wait(this.INITIAL_Z_DELAY); 

            // Sequenzielle Addition der gewichteten Produkte
            for (let i = 0; i < this.INPUT_COUNT; i++) {
                const inputVal = parseFloat(this.INPUT_VALUES[i]);
                const weightVal = parseFloat(this.WEIGHT_VALUES[i]);
                const product = parseFloat(this.WEIGHTED_PRODUCTS[i]);
                const sign = product >= 0 ? '+' : '';

                
                // Step 1: Abstract Formula
                this.accumulator.innerHTML = `
                    <div class="Z-formula" style="font-size: 1.2rem;">
                        Z &leftarrow; Z ${sign} (<span style="color: var(--color-input);">x<sub>${i+1}</sub></span> &middot; <span style="color: var(--color-weight);">w<sub>${i+1}</sub></span>)
                    </div>
                `;
                await this.wait(this.STEP_DELAY_MS); 

                // Step 2: Input Value Blink/Substitution
                await this.toggleSoftGlow(this.inputElements[i], this.BLINK_DURATION_MS, '--color-input');
                this.accumulator.innerHTML = `
                    <div class="Z-formula">
                        Z = ${currentSum.toFixed(3)} ${sign} 
                        <span style="color: var(--color-input); font-size: 1.1em;">(${inputVal.toFixed(2)}</span> &middot; <span style="color: var(--color-weight);">w<sub>${i+1}</sub></span>)
                    </div>
                `;
                await this.wait(this.STEP_DELAY_MS); 

                // Step 3: Weight Value Blink/Substitution
                await this.toggleSoftGlow(this.weightBoxElements[i], this.BLINK_DURATION_MS, '--color-weight');
                this.accumulator.innerHTML = `
                    <div class="Z-formula">
                        Z = ${currentSum.toFixed(3)} ${sign} 
                        (${inputVal.toFixed(2)} &middot; <span style="color: var(--color-weight); font-size: 1.1em;">${weightVal.toFixed(2)}</span>)
                    </div>
                `;
                await this.wait(this.STEP_DELAY_MS); 
                
                // Step 4: Product Calculation (Numeric Term)
                this.accumulator.innerHTML = `
                    <div class="Z-formula">
                        Z = ${currentSum.toFixed(3)} ${sign} 
                        <span style="color: var(--color-input); font-size: 1.1em;">${product.toFixed(3)}</span>
                    </div>
                `;
                await this.wait(this.STEP_DELAY_MS); 
                
                // Step 5: Summation Update
                currentSum += product;
                this.accumulator.innerHTML = `<div class="Z-formula">Z = ${currentSum.toFixed(3)}</div>`;
                await this.wait(this.STEP_DELAY_MS);
            }
            
            // 3d. Addition des Bias-Terms
            this.biasTerm.style.boxShadow = '0 0 10px 3px var(--color-bias)';
            const biasVal = parseFloat(this.BIAS_VALUE);
            const biasSign = biasVal >= 0 ? '+' : '';

            // Step 1: Show formula Z = Z + b (Highlight Bias)
            this.accumulator.innerHTML = `
                <div class="Z-formula" style="font-size: 1.3rem; color:var(--color-bias);">
                    Z &leftarrow; Z ${biasSign} b
                </div>
            `;
            await this.wait(this.STEP_DELAY_MS);

            // Step 2: Show value Z = current_Z + b (Numerische Substitution)
            this.accumulator.innerHTML = `
                <div class="Z-formula" style="font-size: 1.1rem;">
                    Z = ${this.SUM_Z_NO_BIAS.toFixed(3)} 
                    <span style="color: var(--color-bias); font-weight: normal; font-size: 1.1em;">
                        ${biasSign} ${biasVal.toFixed(2)}
                    </span>
                </div>
            `;
            await this.wait(this.STEP_DELAY_MS * 1.5);
            
            // Finaler Summenwert Z
            this.accumulator.innerHTML = `<div class="Z-formula" style="color:var(--color-bias);">Z = ${this.SUM_Z.toFixed(3)}</div>`;
            
            await this.wait(this.CALC_DELAY_MS);
            
            
            // 4. Aktivierungsfunktion (Sigma)
            this.neuronNode.classList.remove('summing');
            this.neuronNode.classList.add('activated');
            this.biasTerm.style.boxShadow = ''; 
            
            // Anzeige der Aktivierungsfunktion
            this.accumulator.innerHTML = `
                <div class="Sigma-formula">
                    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>&#x3C3;</mi><mo>(</mo><mi>Z</mi><mo>)</mo></math>
                </div>
            `;
            
            await this.wait(this.CALC_DELAY_MS / 2);
            
            
            // 5. Output-Fluss
            this.outputLineContainer.classList.add('active'); 
            
            await this.wait(this.FLOW_DURATION_MS / 2);

            // 6. Output-Resultat
            this.outputResult.textContent = this.ACTIVATION_RESULT; 
            this.outputResult.style.boxShadow = '0 0 15px 5px var(--color-output)';

            await this.wait(this.CALC_DELAY_MS);
            
            
            // 7. Cleanup und Reset
            this.neuronNode.classList.remove('activated');
            this.neuronNode.style.border = '3px solid #6c757d';
            this.outputResult.style.boxShadow = '';
            this.neuronNode.style.boxShadow = '0 4px 10px rgba(0,0,0,0.1)';
            this.outputLineContainer.classList.remove('active');
            
            this.mathNotation.style.opacity = '1';
            this.accumulator.style.opacity = '0';

            this.isRunning = false;
        }
        
        startLoop() {
            const loop = () => {
                if (this.isRunning) {
                    this.animationFrameId = requestAnimationFrame(loop);
                    return;
                }
                
                this.INPUT_VALUES = this.generateInputValues();
                this.WEIGHT_VALUES = this.generateWeightValues();
                this.BIAS_VALUE = (Math.random() * 1 - 0.5).toFixed(2); 

                this.initElements(); 

                this.runDenseAnimation().then(() => {
                    setTimeout(() => {
                        this.animationFrameId = requestAnimationFrame(loop);
                    }, 1000); 
                });
            };

            this.animationFrameId = requestAnimationFrame(loop);
        }
        
        wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    // --- 4. Initialization Function ---
    window.make_dense_visual_explanation = function(selector = '.dense_visual_explanation', options = {}) {
        const containers = document.querySelectorAll(selector);
        containers.forEach(container => {
            if (!container.visualizer) {
                try {
                    const visualizer = new DenseVisualizer(container, options);
                    container.visualizer = visualizer; 
                } catch (error) {
                    console.error('Failed to initialize DenseVisualizer for element:', container, error);
                }
            }
        });
    };
    
    // Startet den Visualizer, sobald das DOM geladen ist.
    document.addEventListener('DOMContentLoaded', () => {
        window.make_dense_visual_explanation('.dense_visual_explanation', {
            inputCount: 4
        });
    });
    </script>
</head>
<body>
    
    <h1>Dense Layer (Neuron) Berechnung</h1>
    <h2>Finale Visualisierung: Gewichtete Konvergenz und Schrittweise Berechnung von Z</h2>
    
    <div class="visualizer-container">
        <div class="dense_visual_explanation"></div>
    </div>
    
</body>
</html>
