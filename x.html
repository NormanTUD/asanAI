<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dense Layer Visualizer</title>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        h1 {
            color: #333;
            margin-bottom: 5px;
        }
        h2 {
            font-size: 1rem;
            color: #6c757d;
            margin-bottom: 20px;
        }
        .visualizer-container {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 550px; 
            width: 95%;
        }
    </style>
    
    <script>
    /* ----------------------------------------------------
     * dense_visualizer_svg_v8.8.js (Fix: Input/Output Cell Size vs Line Height Alignment)
     * ---------------------------------------------------- */

    // --- 1. Encapsulated CSS (Fix for alignment) ---
    function getDenseStyles(instanceId) {
        return `
        /* General setup for instance ${instanceId} */
        [data-dense-id="${instanceId}"] {
            /* Variables */
            --input-count: 4;
            --cell-size: 40px; /* OPTIMIERT: Kleinere Zellengröße für Input und Output */
            --weight-box-width: 45px;
            --weight-line-height: 40px; /* Wichtig für die vertikale Ausrichtung */
            --color-input: #333;
            --color-weight: #007bff;
            --color-bias: #ffc107;
            --color-output: #28a745;
            /* Längere Dauer für das Verlangsamen der Animation */
            --flow-duration: 1800ms; 
            --calc-delay: 4000ms; /* Erhöht für längeres Verweilen */
            --pulse-color: #ff0000; 
            --neuron-radius: 55px; 
            --output-color-light: #d4edda;
            --highlight-color: #dc3545; 

            /* Page skeleton */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: Arial, sans-serif;
            padding: 0;
            box-sizing: border-box;
            width: 100%;
        }

        [data-dense-id="${instanceId}"] .dense-container {
            display: grid;
            /* Angepasst an die neue --cell-size */
            grid-template-columns: var(--cell-size) 20px var(--weight-box-width) 30px calc(2 * var(--neuron-radius)) 30px var(--cell-size); 
            grid-template-rows: auto;
            align-items: center;
            gap: 0;
            position: relative;
            width: 100%;
            padding: 10px 0;
        }
        
        /* Input Vector (links) */
        [data-dense-id="${instanceId}"] .input-vector {
            grid-column: 1;
            grid-row: 1;
            display: flex;
            flex-direction: column; 
            /* HIER WICHTIG: Flexbox Gap auf 0 setzen und Höhe über den Wrapper steuern */
            gap: 0; 
            align-items: flex-end; 
            z-index: 10;
        }

        /* Input/Weight Base Styles */
        [data-dense-id="${instanceId}"] .input-val-wrapper,
        [data-dense-id="${instanceId}"] .weight-box-wrapper {
            /* Steuert die Gesamthöhe pro Zeile, um die Zentrierung zu gewährleisten */
            height: var(--weight-line-height); 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        [data-dense-id="${instanceId}"] .input-val {
            width: var(--cell-size);
            height: var(--cell-size); /* Jetzt an die neue --cell-size gebunden */
            background-color: var(--color-input);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 4px;
        }
        
        [data-dense-id="${instanceId}"] .weight-box {
            width: var(--weight-box-width); 
            height: 25px; 
            background-color: var(--color-weight);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem; 
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-weight: bold;
            z-index: 20; 
        }
        
        /* SVG Overlay */
        [data-dense-id="${instanceId}"] .synapse-svg-overlay {
            grid-column: 1 / span 5; 
            grid-row: 1;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; 
            z-index: 5;
            pointer-events: none;
        }
        
        [data-dense-id="${instanceId}"] .synapse-line {
            stroke: var(--color-weight);
            stroke-linecap: round;
            fill: none;
            transition: stroke-width 0.2s, stroke 0.2s;
        }

        /* Gewichtswerte (Alignment Fix) */
        [data-dense-id="${instanceId}"] .weight-values {
            grid-column: 3;
            grid-row: 1;
            display: flex;
            flex-direction: column; 
            align-items: center;
            z-index: 10;
        }
        
        /* Output (Aktiviertes Ergebnis) - FIX für Überlauf und Splitting */
        [data-dense-id="${instanceId}"] .output-result-wrapper {
            grid-column: 7;
            grid-row: 1;
            width: var(--cell-size);
            height: 100%; /* Wichtig: Höhe beibehalten, um Align-Items: center zu nutzen */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        [data-dense-id="${instanceId}"] .output-result {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--color-output);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.75rem; 
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: box-shadow 0.3s;
            overflow-wrap: normal; 
            padding: 2px;
            box-sizing: border-box;
            line-height: 1.1; 
        }

        /* Das Neuron (Hauptknoten) */
        [data-dense-id="${instanceId}"] .neuron-node {
            grid-column: 5;
            grid-row: 1;
            width: calc(2 * var(--neuron-radius));
            height: calc(2 * var(--neuron-radius));
            background-color: #f8f9fa;
            border: 3px solid #6c757d;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; 
            font-size: 0.8rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: border-color var(--calc-delay) ease-in-out, background-color 0.1s, box-shadow 0.2s;
            z-index: 10;
        }
        
        /* Accumulator (für schrittweise Summierung - UPDATED for better fit) */
        [data-dense-id="${instanceId}"] .accumulator {
            font-weight: bold;
            min-height: 50px; 
            padding: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
            text-align: center;
            line-height: 1.0; 
            overflow: hidden; 
        }
        
        /* Formel für Z */
        [data-dense-id="${instanceId}"] .accumulator .Z-formula {
            font-size: 0.95rem; 
            color: var(--color-input);
            min-height: 1.1em; 
            max-width: 100%;
            word-break: break-all;
            padding: 0 5px; 
            box-sizing: border-box;
        }
        
        /* Formel für Activation */
        [data-dense-id="${instanceId}"] .accumulator .Activation-formula {
            font-size: 1.0rem; 
            color: var(--color-output);
            font-style: italic;
            padding: 5px;
            line-height: 1.2;
        }
        
        [data-dense-id="${instanceId}"] .accumulator .Activation-formula i {
            font-style: italic; 
            font-weight: bold;
            color: var(--color-output);
        }

        /* Highlight-Zustände (unverändert) */
        [data-dense-id="${instanceId}"] .neuron-node.summing {
            border-color: var(--color-bias);
            background-color: rgba(255, 193, 7, 0.2);
            box-shadow: 0 0 15px 5px var(--color-bias);
        }
        [data-dense-id="${instanceId}"] .neuron-node.activated {
            border-color: var(--color-output);
            background-color: var(--output-color-light);
            box-shadow: 0 0 15px 5px var(--color-output);
        }

        /* Bias Addition (unverändert) */
        [data-dense-id="${instanceId}"] .bias-term {
            position: absolute;
            top: -20px; 
            right: -25px; 
            width: 50px; 
            height: 25px; 
            background-color: var(--color-bias);
            color: white;
            border-radius: 4px; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.7rem;
            z-index: 30;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: box-shadow 0.2s;
            line-height: 1.1;
            padding: 2px 4px;
        }
        
        [data-dense-id="${instanceId}"] .bias-term .bias-label {
            font-size: 0.6rem;
            font-weight: normal;
            margin-top: -2px;
        }

        /* Output Linie & Dot (unverändert) */
        [data-dense-id="${instanceId}"] .output-line-container {
            grid-column: 6;
            grid-row: 1;
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        [data-dense-id="${instanceId}"] .output-line {
            height: 2px;
            width: 100%; 
            background-color: var(--color-output);
            position: relative;
        }
        
        @keyframes output-flow-animation {
            0% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(100%); }
        }

        [data-dense-id="${instanceId}"] .output-line-container.active .signal-dot {
            opacity: 1;
            top: calc(50% - 4px); 
            left: 0; 
            animation: output-flow-animation calc(var(--flow-duration) / 2) linear forwards;
        }
        `;
    }

    // --- 2. HTML Template (Input/Output Wrapper hinzugefügt) ---
    function getDenseHtml(instanceId) {
        return `
        <div class="dense-container" data-dense-id="${instanceId}" role="region" aria-label="Dense Layer Neuron Calculation Demo">
            
            <div class="input-vector" data-element-type="inputVector">
                </div> 

            <div class="synapse-svg-overlay">
                <svg class="synapse-svg" data-element-type="synapseSvg">
                    <g data-element-type="synapseGroup"></g>
                </svg>
            </div>
            
            <div class="weight-values" data-element-type="weightValues">
                </div>
            
            <div class="neuron-node" data-element-type="neuronNode">
                <div class="bias-term" data-element-type="biasTerm">
                    <span class="bias-value">b</span>
                    <span class="bias-label">Bias</span>
                </div> 
                
                <div class="accumulator" data-element-type="accumulator"></div> 
            </div>

            <div class="output-line-container" data-element-type="outputLineContainer">
                <div class="output-line">
                    <div class="signal-dot"></div>
                </div>
            </div>
            
            <div class="output-result-wrapper" data-element-type="outputResultWrapper">
                <div class="output-result">output</div>
            </div>
        </div>
        `;
    }

    // --- 3. DenseVisualizer Class (Logic UPDATED for alignment wrappers) ---
    class DenseVisualizer {
        constructor(containerElement, options = {}) {
            if (!containerElement) throw new Error('Container element is required.');

            this.container = containerElement;
            this.instanceId = 'dense-instance-' + Math.random().toString(36).substring(2, 9);
            this.isRunning = false;
            this.animationFrameId = null;

            // Constants
            this.INPUT_COUNT = options.inputCount || 4;
            this.CELL_SIZE = 40; // Aktualisiert auf 40px
            this.WEIGHT_BOX_WIDTH = 45;
            this.WEIGHT_LINE_HEIGHT = 40; // Muss gleich oder größer als CELL_SIZE sein
            this.NEURON_RADIUS = 55;
            this.FLOW_DURATION_MS = 1800;
            this.CALC_DELAY_MS = 4000; 
            this.STEP_DELAY_MS = 3500; 
            this.INITIAL_Z_DELAY = 1000; 
            this.BLINK_DURATION_MS = 600; 
            this.SEQUENTIAL_FLOW_DELAY = 300; 
            
            // Data
            this.INPUT_VALUES = options.inputValues || this.generateInputValues();
            this.WEIGHT_VALUES = options.weightValues || this.generateWeightValues();
            this.BIAS_VALUE = options.biasValue || 0.5;

            this.setupDOM();
            this.initElements();
            
            this.startLoop();
        }

        generateInputValues() {
            return Array.from({ length: this.INPUT_COUNT }, () => (Math.random() * 2 - 1).toFixed(2));
        }

        generateWeightValues() {
            return Array.from({ length: this.INPUT_COUNT }, () => (Math.random() * 2 - 1).toFixed(2));
        }

        setupDOM() {
            const style = document.createElement('style');
            style.setAttribute('data-dense-instance-id', this.instanceId);
            style.textContent = getDenseStyles(this.instanceId);
            document.head.appendChild(style);

            this.container.setAttribute('data-dense-id', this.instanceId);
            this.container.innerHTML = getDenseHtml(this.instanceId);

            this.container.style.setProperty('--input-count', String(this.INPUT_COUNT));
            this.container.style.setProperty('--neuron-radius', this.NEURON_RADIUS + 'px');
            this.container.style.setProperty('--flow-duration', this.FLOW_DURATION_MS + 'ms');
            this.container.style.setProperty('--calc-delay', this.CALC_DELAY_MS + 'ms');
            this.container.style.setProperty('--weight-line-height', this.WEIGHT_LINE_HEIGHT + 'px');
            this.container.style.setProperty('--cell-size', this.CELL_SIZE + 'px'); 
        }

        initElements() {
            // Element References
            this.inputVector = this.container.querySelector('[data-element-type="inputVector"]');
            this.weightValuesContainer = this.container.querySelector('[data-element-type="weightValues"]');
            this.synapseGroup = this.container.querySelector('[data-element-type="synapseGroup"]');
            this.synapseSvg = this.container.querySelector('[data-element-type="synapseSvg"]');
            this.outputLineContainer = this.container.querySelector('[data-element-type="outputLineContainer"]');
            this.biasTerm = this.container.querySelector('[data-element-type="biasTerm"]');
            this.biasValueElement = this.biasTerm.querySelector('.bias-value'); 
            this.outputResult = this.container.querySelector('.output-result'); // Über den Wrapper finden
            this.neuronNode = this.container.querySelector('[data-element-type="neuronNode"]');
            this.accumulator = this.container.querySelector('[data-element-type="accumulator"]');


            this.inputVector.innerHTML = '';
            this.weightValuesContainer.innerHTML = '';
            this.synapseGroup.innerHTML = '';
            
            this.inputElements = [];
            this.weightBoxElements = [];
            this.pathElements = [];
            this.dotElements = [];

            // Berechnung der gewichteten Produkte und des finalen Ergebnisses
            this.WEIGHTED_PRODUCTS = this.INPUT_VALUES.map((x, i) => 
                (parseFloat(x) * parseFloat(this.WEIGHT_VALUES[i])).toFixed(3)
            );
            this.SUM_Z_NO_BIAS = this.WEIGHTED_PRODUCTS.reduce((sum, p) => sum + parseFloat(p), 0);
            this.SUM_Z = this.SUM_Z_NO_BIAS + parseFloat(this.BIAS_VALUE);
            this.ACTIVATION_RESULT = (1 / (1 + Math.exp(-this.SUM_Z))).toFixed(3); // Sigmoid-Funktion
            
            this.accumulator.innerHTML = '';

            // --- Geometrie-Berechnung ---
            const PADDING_Y = 10; 
            const TOTAL_HEIGHT = this.INPUT_COUNT * this.WEIGHT_LINE_HEIGHT + 2 * PADDING_Y; 
            
            this.synapseSvg.style.height = TOTAL_HEIGHT + 'px';
            this.synapseSvg.setAttribute('height', TOTAL_HEIGHT);
            
            const NEURON_CENTER_Y = TOTAL_HEIGHT / 2; 
            const CELL_SIZE = this.CELL_SIZE;
            const WEIGHT_BOX_WIDTH = this.WEIGHT_BOX_WIDTH;
            const INPUT_RIGHT_X = CELL_SIZE; 
            const WEIGHT_BOX_LEFT_X = INPUT_RIGHT_X + 20; 
            const WEIGHT_BOX_RIGHT_X = WEIGHT_BOX_LEFT_X + WEIGHT_BOX_WIDTH; 
            const NEURON_LEFT_EDGE_X = WEIGHT_BOX_RIGHT_X + 30; 
            const NEURON_ENTRY_X = NEURON_LEFT_EDGE_X; 
            const maxAbsWeight = Math.max(1e-6, ...this.WEIGHT_VALUES.map(w => Math.abs(parseFloat(w))));

            for (let i = 0; i < this.INPUT_COUNT; i++) {
                const inputVal = parseFloat(this.INPUT_VALUES[i]);
                const weightVal = parseFloat(this.WEIGHT_VALUES[i]);
                
                const LINE_CENTER_Y = PADDING_Y + i * this.WEIGHT_LINE_HEIGHT + this.WEIGHT_LINE_HEIGHT / 2;
                
                // 1. Input-Element (mit Wrapper zur Höhensteuerung)
                const inputWrapper = document.createElement('div');
                inputWrapper.classList.add('input-val-wrapper'); 

                const inputDiv = document.createElement('div');
                inputDiv.classList.add('input-val');
                inputDiv.textContent = inputVal.toFixed(2);
                
                inputWrapper.appendChild(inputDiv);
                this.inputVector.appendChild(inputWrapper);
                this.inputElements.push(inputDiv);
                
                // 2. Weight-Box (mit Wrapper für Zentrierung)
                const weightWrapper = document.createElement('div');
                weightWrapper.classList.add('weight-box-wrapper'); 
                
                const weightBox = document.createElement('div');
                weightBox.classList.add('weight-box');
                weightBox.textContent = weightVal.toFixed(2); 
                
                weightWrapper.appendChild(weightBox);
                this.weightValuesContainer.appendChild(weightWrapper);
                this.weightBoxElements.push(weightBox);
                
                // --- Synapsen-Berechnung (SVG) ---
                const P_A_X = INPUT_RIGHT_X;
                const P_A_Y = LINE_CENTER_Y;
                const P_B_X = WEIGHT_BOX_LEFT_X; 
                const P_C_X = WEIGHT_BOX_RIGHT_X; 
                const P_D_X = NEURON_ENTRY_X;
                const P_D_Y = NEURON_CENTER_Y;
                
                const d = `M ${P_A_X},${P_A_Y} L ${P_B_X},${P_A_Y} M ${P_C_X},${P_A_Y} L ${P_D_X},${P_D_Y}`;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', d);
                path.classList.add('synapse-line');
                const absWeightNormalized = Math.abs(weightVal / maxAbsWeight);
                const thickness = 2 + 3 * absWeightNormalized; 
                path.setAttribute('stroke-width', thickness);
                
                this.synapseGroup.appendChild(path);
                this.pathElements.push(path);
                
                // 3. Signal-Dot (SVG Circle)
                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                dot.setAttribute('r', '4');
                dot.setAttribute('fill', 'var(--pulse-color)');
                dot.setAttribute('opacity', '0'); 
                dot.setAttribute('cx', P_A_X);
                dot.setAttribute('cy', P_A_Y);
                dot.style.transition = 'opacity 0.1s';
                
                this.synapseGroup.appendChild(dot);
                this.dotElements.push(dot);
            }
            
            // 4. Bias-Wert setzen
            this.biasValueElement.textContent = this.BIAS_VALUE; 
            
            // 5. Output-Wert initial zurücksetzen
            this.outputResult.textContent = 'output';
        }

        // Hilfsfunktion für den sanften Glow (unverändert)
        async toggleSoftGlow(element, duration, colorVar) {
            const originalBoxShadow = element.style.boxShadow || '';
            const color = getComputedStyle(this.container).getPropertyValue(colorVar).trim();
            
            element.style.boxShadow = `0 0 8px 3px ${color}`; 
            await this.wait(duration);
            element.style.boxShadow = originalBoxShadow; 
        }

	async runDenseAnimation() {
            if (this.isRunning) return;
            this.isRunning = true;
            
            // 1. Reset Zustände
            this.outputResult.textContent = 'output'; 
            this.outputResult.style.boxShadow = '';
            this.neuronNode.classList.remove('activated');
            this.neuronNode.style.border = '3px solid #6c757d';
            this.biasTerm.style.boxShadow = '';
            this.neuronNode.style.boxShadow = '0 4px 10px rgba(0,0,0,0.1)';
            this.outputLineContainer.classList.remove('active');
            this.accumulator.style.opacity = '0';
            this.accumulator.innerHTML = '';
            this.dotElements.forEach(dot => dot.setAttribute('opacity', '0'));
            
            // --- NEU: Initialisierung der Summierung ---
            this.neuronNode.classList.add('summing');
            this.accumulator.style.opacity = '1';
            
            let currentSum = 0;
            this.accumulator.innerHTML = `<div class="Z-formula">Z = 0.000</div>`;
            await this.wait(this.INITIAL_Z_DELAY); 


            // 2. SEQUENZIELLER Datenfluss (Input * Weight) & Berechnung
            const CALC_DELAY = this.STEP_DELAY_MS / 3; 

            for (let i = 0; i < this.INPUT_COUNT; i++) {
                const inputEl = this.inputElements[i];
                const weightBox = this.weightBoxElements[i];
                const path = this.pathElements[i];
                const dot = this.dotElements[i];
                const totalDuration = this.FLOW_DURATION_MS;
                
                const inputVal = parseFloat(this.INPUT_VALUES[i]);
                const weightVal = parseFloat(this.WEIGHT_VALUES[i]);
                const product = parseFloat(this.WEIGHTED_PRODUCTS[i]);
                const prevSumDisplay = currentSum.toFixed(3);
                const sign = (product >= 0) ? '+' : ''; // Nur Minuszeichen anzeigen

                // Highlight Input und Weight für den aktuellen Index (Bleibt während Animation)
                inputEl.style.boxShadow = '0 0 5px 2px var(--color-input)';
                weightBox.style.boxShadow = '0 0 5px 2px var(--color-weight)';

                // Setze den Punkt zurück
                dot.setAttribute('cx', path.getPointAtLength(0).x); 
                dot.setAttribute('cy', path.getPointAtLength(0).y); 

                let startTime;
                
                // --- A. DOT ANIMATION START ---
                await new Promise(resolve => {
                    const stepAnimate = (timestamp) => {
                        if (!startTime) startTime = timestamp;
                        const elapsed = timestamp - startTime;
                        const progress = Math.min(1, elapsed / totalDuration);

                        const totalLength = path.getTotalLength();
                        const point = path.getPointAtLength(progress * totalLength);
                        
                        dot.setAttribute('cx', point.x);
                        dot.setAttribute('cy', point.y);
                        
                        if (progress > 0.05) { 
                            dot.setAttribute('opacity', '1');
                        }

                        if (progress < 1) {
                            this.animationFrameId = requestAnimationFrame(stepAnimate);
                        } else {
                            // Cleanup nach Abschluss der Dot-Animation
                            dot.setAttribute('opacity', '0');
                            inputEl.style.boxShadow = '';
                            weightBox.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)'; // Reset weight box shadow
                            resolve(); 
                        }
                    };
                    requestAnimationFrame(stepAnimate);
                });
                // --- B. CALCULATION START (Immediately after dot arrives) ---
                
                // Step 1: Show calculation Z = Z + (x_i * w_i) with values substituted
                this.accumulator.innerHTML = `
                    <div class="Z-formula" style="font-size: 0.95rem;">
                        Z = ${prevSumDisplay} ${sign} 
                        (<span style="color: var(--color-input);">${inputVal.toFixed(2)}</span> &middot; <span style="color: var(--color-weight);">${weightVal.toFixed(2)}</span>)
                    </div>
                `;
                // Kurzes Aufleuchten des Neurons zur Bestätigung der "Aufnahme"
                this.neuronNode.style.boxShadow = '0 0 15px 7px var(--color-bias)'; 
                await this.wait(this.BLINK_DURATION_MS);
                this.neuronNode.style.boxShadow = '0 0 15px 5px var(--color-bias)'; // Zurück zum Summing-Glow

                await this.wait(CALC_DELAY); 

                // Step 2: Show product Z = Z + (product)
                this.accumulator.innerHTML = `
                    <div class="Z-formula">
                        Z = ${prevSumDisplay} 
                        <span style="color: var(--color-input); font-size: 1.1em;">${sign} (${Math.abs(product).toFixed(3)})</span>
                    </div>
                `;
                await this.wait(CALC_DELAY); 
                
                // Step 3: Summation Update
                currentSum += product;
                this.accumulator.innerHTML = `<div class="Z-formula">Z = ${currentSum.toFixed(3)}</div>`; 
                
                // Längere Wartezeit, bevor der nächste Punkt startet
                await this.wait(CALC_DELAY * 2); 
            }
            
            // 3. Bias Addition (Starts immediately after the last input product)
            this.biasTerm.style.boxShadow = '0 0 10px 3px var(--color-bias)';
            const biasVal = parseFloat(this.BIAS_VALUE);
            const biasSign = (biasVal >= 0) ? '+' : ''; 
            const prevSumDisplay = currentSum.toFixed(3);

            // Step 1: Show value Z = current_Z + b (Numerische Substitution)
            this.accumulator.innerHTML = `
                <div class="Z-formula" style="font-size: 0.95rem;">
                    Z = ${prevSumDisplay} 
                    <span style="color: var(--color-bias); font-weight: normal; font-size: 1.1em;">
                        ${biasSign} (${Math.abs(biasVal).toFixed(2)})
                    </span>
                </div>
            `;
            await this.wait(this.STEP_DELAY_MS * 1.5);
            
            // Finaler Summenwert Z (inkl. Bias)
            currentSum = this.SUM_Z; 
            this.accumulator.innerHTML = `<div class="Z-formula" style="color:var(--color-bias);">Z = ${currentSum.toFixed(3)}</div>`;
            
            // Längere Verweildauer für das finale Z
            await this.wait(this.CALC_DELAY_MS); 
            
            
            // 4. Aktivierungsfunktion (Activation)
            this.neuronNode.classList.remove('summing');
            this.neuronNode.classList.add('activated');
            this.biasTerm.style.boxShadow = ''; 
            
            // Anzeige der Aktivierungsfunktion - WICHTIG: Z-Wert ist hier enthalten
            this.accumulator.innerHTML = `
                <div class="Activation-formula">
                    Activation(<i>Z</i> = ${currentSum.toFixed(3)})
                </div>
            `;
            
            // Längere Verweildauer für Activation(Z)
            await this.wait(this.CALC_DELAY_MS); 
            
            
            // 5. Output-Fluss
            this.outputLineContainer.classList.add('active'); 
            
            await this.wait(this.FLOW_DURATION_MS / 2);

            // 6. Output-Resultat
            this.outputResult.textContent = this.ACTIVATION_RESULT; 
            this.outputResult.style.boxShadow = '0 0 15px 5px var(--color-output)';

            await this.wait(this.CALC_DELAY_MS / 2); // Kürzere Verweildauer am Ende
            
            
            // 7. Cleanup und Reset
            this.neuronNode.classList.remove('activated');
            this.neuronNode.style.border = '3px solid #6c757d';
            this.outputResult.style.boxShadow = '';
            this.neuronNode.style.boxShadow = '0 4px 10px rgba(0,0,0,0.1)';
            this.outputLineContainer.classList.remove('active');
            
            this.accumulator.style.opacity = '0';

            this.isRunning = false;
        }

        startLoop() {
            const loop = () => {
                if (this.isRunning) {
                    this.animationFrameId = requestAnimationFrame(loop);
                    return;
                }
                
                this.INPUT_VALUES = this.generateInputValues();
                this.WEIGHT_VALUES = this.generateWeightValues();
                this.BIAS_VALUE = (Math.random() * 1 - 0.5).toFixed(2); 

                this.initElements(); 

                this.runDenseAnimation().then(() => {
                    setTimeout(() => {
                        this.animationFrameId = requestAnimationFrame(loop);
                    }, 1000); 
                });
            };

            this.animationFrameId = requestAnimationFrame(loop);
        }
        
        wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    // --- 4. Initialization Function ---
    window.make_dense_visual_explanation = function(selector = '.dense_visual_explanation', options = {}) {
        const containers = document.querySelectorAll(selector);
        containers.forEach(container => {
            if (!container.visualizer) {
                try {
                    const visualizer = new DenseVisualizer(container, options);
                    container.visualizer = visualizer; 
                } catch (error) {
                    console.error('Failed to initialize DenseVisualizer for element:', container, error);
                }
            }
        });
    };
    
    // Startet den Visualizer, sobald das DOM geladen ist.
    document.addEventListener('DOMContentLoaded', () => {
        window.make_dense_visual_explanation('.dense_visual_explanation', {
            inputCount: 4
        });
    });
    </script>
</head>
<body>
    
    <h1>Dense Layer (Neuron) Berechnung</h1>
    <h2>Finale Visualisierung: Gewichtete Konvergenz und Schrittweise Berechnung von Z</h2>
    
    <div class="visualizer-container">
        <div class="dense_visual_explanation"></div>
    </div>
    
</body>
</html>
