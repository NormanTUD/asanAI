<?php
	$GLOBALS['translations'] = array(
		'en' => array(
			"predicted_category" => "Predicted category",
			"correct_category" => "Correct category",
			"model_was_set" => "Model was set properly",
			'example_csv_shoe_size' => 'Load example shoe data (0 = male, 1 = female)',
			'we_want_to_train_this_model_5_categories' => 'The computer should now learn to classify the images into one of the five categories.',
			'fire' => 'Fire prevention',
			'mandatory' => 'Mandatory',
			'prohibition' => 'Prohibition',
			'rescue' => 'Rescue',
			'warning' => 'Warning',
			'the_more_variations_the_model_sees' => 'The more variations the model sees, the better it can learn important features of the images.',
			'quality_depends_on_random' => 'The quality of the results depends on randomness.',
			'program_looks_at_data' => 'The learning process (training) is now running and the computer tries, through trial and error, many different filter configurations.',
			'the_further_on_top_the_better' => "Especially at the beginning of the training, many images are initially classified into the wrong category. As the training progresses, the correct category is increasingly assigned, and this assignment becomes more reliable. The categorical assignment is more reliable the higher an image moves up into the blue area.",
			'add_category' => 'Add category',
			'settings' => 'Settings',
			'description' => 'Description',
			'use_bias' => 'Use Bias',
			'activation_function' => 'Activation function',
			'bias_initializer' => 'Bias-Initializer',
			'kernel_initializer' => 'Kernel-Initializer',
			'trainable' => 'Trainable',
			'visualize_layer' => 'Visualize layer',
			'visualize_this_layer' => 'Visualize this layer',
			'examples' => 'Examples',
			'dataset' => 'Dataset',
			'height' => 'Height',
			'width' => 'Width',
			'batch_size' => 'Batch-Size',
			'epochs' => 'Epochs',
			'own_data' => 'Data Source',
			'filters' => 'Filters',
			'distribution' => 'Distribution',
			'image_options' => 'Image Options',
			'feature_extraction' => 'Feature ex&shy;traction',
			'classification' => 'Classi&shy;fication',
			'flatten' => 'Flatten',
			'dataset_and_network' => 'Dataset and network',
			'visualization' => 'Model Visualization',
			'data' => 'Data',
			'training_data' => 'Data',
			'currently_the_network_has_seen' => 'The remaining time of this training will be',
			'of' => 'of',
			'times_seen' => 'times.',
			'it_will_take_about' => 'It will take about',
			'remain_left' => ' ',
			'camera_draw_self' => 'Camera/draw',
			'click_on' => 'Touch',
			'if_bad_continue_training' => 'If the results are still bad, continue training.',
			'the_ai_thinks_categories_look_like_this' => 'A visual representation of what the AI has learnt',
			'it_might_only_be_noise' => "That's why you are probably only seeing random noise and the detection may not work properly yet.",
			'image_left' => 'image left',
			'images_left' => 'images left',
			'beginner' => 'Beginner',
			'expert' => 'Expert',
			'except_last_layer' => 'except last layer',
			'activation_functions' => 'Activation functions',
			'set_for_all_layers' => 'Set for all layers',
			'shuffle_before_each_epoch' => 'Shuffle before each epoch',
			'summary' => 'Summary',
			'own_images' => 'Own images',
			'own_tensor' => 'Own tensors',
			'kernel_size' => 'Kernel-Size',
			'start_training' => 'Start training',
			'stop_training' => 'Stop training',
			'imprint' => 'Imprint',
			'change_shape' => 'Change shape',
			'simulate_real_data' => 'Simulate real data',
			'dimensionality_reduction' => 'Di&shy;men&shy;sio&shy;na&shy;lity re&shy;duc&shy;tion',
			'shy_activation_function' => 'Ac&shy;ti&shy;va&shy;tion fun&shy;ction',
			'shy_overfitting_prevention' => 'Pre&shy;vent Over&shy;fit&shy;ting',
			'rescale_and_recenter' => 'Re-scale and re-center data',
			'show_layer_data_flow' => 'Show layer data flow',
			'show_grad_cam' => 'Show gradCAM',
			'code' => 'Code',
			'own_csv' => 'Own CSV',
			'training' => 'Training',
			'predict' => 'Predict',
			'hyperparameters' => 'Hyperparameters',
			'valsplit' => 'Val.-Split',
			'divide_x_by' => 'Divide <i>X</i> by',
			'metric' => 'Metric',
			'loss' => 'Loss',
			'optimizer' => 'Optimizer',
			'learning_rate' => 'Learning Rate',
			'enable_tf_debug' => 'Enable TFJS Debugger',
			'enable_webcam' => 'Enable webcam',
			'disable_webcam' => 'Disable webcam',
			'switch_to_other_cam' => 'Switch to other cam',
			'copy_to_clipboard' => 'Copy to clipboard',
			'copy_to_clipboard_debug' => 'Copy to clipboard (debug)',
			'set_all_initializers' => 'Set all Initializers',
			'augmentation' => 'Augmentation',
			'iterations' => 'Iterations',
			'close' => 'Close',
			'register' => 'Register',
			'csv' => 'CSV',
			'math' => 'Math',
			'smaller' => 'Smaller',
			'larger' => 'Larger',
			'reset' => 'Reset',
			'delete_predictions' => 'Delete predictions',
			'memory_usage_while_training' => 'Memory usage while training (per batch)',
			'img_per_cat' => 'Img/cat',
			'batches' => 'Batches',
			'login' => 'Login',
			'username' => 'Username',
			'password' => 'Password',
			'download' => 'Download',
			'email' => 'E-Mail',
			'public' => 'Public',
			'save' => 'Save',
			'augment' => 'Augment',
			'download_model_data' => 'Download model data',
			'logout' => 'Logout',
			'load' => 'Load',
			'download_for_local_taurus' => 'Download for local/taurus training',
			'max_activated_neurons' => 'Max. activated neurons',
			'no_default_data' => 'Default data',
			'yes_own_tensor' => '&#x2318; Own tensor-data',
			'yes_own_csv' => '&#128290; Own CSV',
			'yes_own_images' => '&#128444; Own images/webcam',
			'width_amp_height' => 'Width&amp;height (0 = auto)',
			'randomizer_limits' => 'Randomizer Limits',
			'max_neurons_fcnn' => 'Max. neurons FCNN',
			'various_plots' => 'Various Plots',
			'sources_and_used_programs' => 'Sources and used programs',
			'visualize_images_in_grid' => 'Visualize images in grid',
			'model_compiled_successfully' => 'Model compiled successfully',
			'not_creating_model_because_values_are_missing' => 'Not creating model because some values are missing',
			'tensors' => 'Tensors',
			'set_val_split_to' => 'Set validationSplit to ',
			'set_optimizer_to' => 'Setting optimizer to ',
			'set_metric_to' => 'Setting metric to ',
			'set_loss_to' => 'Setting loss to ',
			'show_bars_instead_of_numbers' => 'Show bars instead of numbers',
			'number_of_grid_images' => 'Number of grid images',
			'show_raw_data' => 'Show raw data',
			'pixel_size' => 'Pixel size',
			'auto_rotate_images' => 'Auto rotate images',
			'number_of_rotations' => 'Number of rotations',
			'pretext_prepare_data' => 'You must prepare your dataset yourself! You can use this piece of code to generate the data file in the correct format after you pre-processed them.',
			'reinitialize_weights' => 'Reinitialize weights',
			'batch_plot_minimum_time' => 'Batch-Plot-Minimum-Time',
			'loss_metric_data_and_shape' => 'Loss, Metric, Data and Shapes',
			'sine_ripple' => 'Sine-Ripple',
			'invert_images' => 'Invert images',
			'flip_left_right' => 'Flip left and right',
			'layer_data_flow' => 'Layer data flow',
			'dense_description' => 'Creates a dense (fully connected) layer.<br>This layer implements the operation: <span class="temml_me">\\mathrm{output} = \\mathrm{activation}\\left(\\mathrm{input} \\cdot \\mathrm{kernel} + \\text{bias}\\right).</span> Activation is the element-wise activation function passed as the activation argument.<br><tt>kernel</tt> is a weights matrix created by the layer.<br><tt>bias</tt> is a bias vector created by the layer (only applicable if useBias is true).',
			'flatten_description' => 'Flattens the input. Does not affect the batch size. A Flatten layer flattens each batch in its inputs to 1D (making the output 2D).',
			'dropout_description' => 'Dropout consists in randomly setting a fraction rate of input units to 0 at each update during training time, which helps prevent overfitting.',
			'reshape_description' => 'Reshapes an input to a certain shape.',
			"elu_description" => "Exponential Linear Unit (ELU).<br>Equation: <span class='temml_me'>\\text{elu}\\left(x\\right) = \\left\\{\\begin{array}{ll} \\alpha \\cdot \\left(e^x - 1\\right) & \\text{for } x < 0 \\\\ \n x & \\text{for } x >= 0\\end{array}\\right.</span>",
			"leakyReLU_description" => "Leaky version of a rectified linear unit.<br>It allows a small gradient when the unit is not active: <span class='temml_me'>\\text{leakyReLU}(x) = \\left\\{\\begin{array}{ll} \\alpha \\cdot x & \\text{for } x < 0 \\\\ \n x & \\text{for } x >= 0 \\end{array}\\right.</span>",
			'reLU_description' => 'Rectified Linear Unit activation function. <span class="temml_me">\\mathrm{relu}\\left(x\\right) = \\mathrm{max}\\left(\mathrm{Max-Value}, x\\right)</span>',
			'softmax_description' => 'Softmax activation layer. <span class="temml_me">\\mathrm{softmax}\\left(x\\right) = \\frac{e^{z_j}}{\\sum^K_{k=1} e^{z_k}}</span>',
			"thresholdedReLU_description" => "Thresholded Rectified Linear Unit. Equation: <span class='temml_me'>f(x) = \\left\\{\\begin{array}{ll} x & \\text{for } x > \\theta \\\\ \n 0 & \\text{otherwise}\\end{array}\\right.</span>",
			'batchNormalization_description' => "Batch normalization layer (<a href='https://arxiv.org/abs/1502.03167' target='_blank'>Ioffe and Szegedy, 2014</a>).<br>Normalize the activations of the previous layer at each batch, i.e. applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.",
			'layerNormalization_description' => "Layer-normalization layer (<a target='_blank' href='https://arxiv.org/abs/1607.06450'>Ba et al., 2016</a>). Normalizes the activations of the previous layer for each given example in a batch independently, instead of across a batch like in batchNormalization. In other words, this layer applies a transformation that maintanis the mean activation within each example close to 0 and activation variance close to 1.",
			'conv1d_description' => '1D convolution layer (e.g., temporal convolution).<br>This layer creates a convolution kernel that is convolved with the layer input over a single spatial (or temporal) dimension to produce a tensor of outputs.<br>If <tt>use_bias</tt> is True, a bias vector is created and added to the outputs.<br>If <tt>activation</tt> is not <tt>null</tt>, it is applied to the outputs as well.',
			'conv2d_description' => '2D convolution layer (e.g. spatial convolution over images).<br>This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs.<br>If <tt>useBias</tt> is True, a bias vector is created and added to the outputs.<br>If <tt>activation</tt> is not null, it is applied to the outputs as well.',
			'conv2dTranspose_description' => 'Transposed convolutional layer (sometimes called Deconvolution). The need for transposed convolutions generally arises from the desire to use a transformation going in the opposite direction of a normal convolution, i.e., from something that has the shape of the output of some convolution to something that has the shape of its input while maintaining a connectivity pattern that is compatible with said convolution.',
			'conv3d_description' => '3D convolution layer (e.g. spatial convolution over volumes).<br>This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs.',
			'depthwiseConv2d_description' => 'Depthwise separable 2D convolution. Depthwise Separable convolutions consists in performing just the first step in a depthwise spatial convolution (which acts on each input channel separately). The depthMultiplier argument controls how many output channels are generated per input channel in the depthwise step.',
			'separableConv2d_description' => 'Depthwise separable 2D convolution. Separable convolution consists of first performing a depthwise spatial convolution (which acts on each input channel separately) followed by a pointwise convolution which mixes together the resulting output channels. The depthMultiplier argument controls how many output channels are generated per input channel in the depthwise step.',
			'upSampling2d_description' => 'Upsampling layer for 2D inputs. Repeats the rows and columns of the data by <tt>size[0]</tt> and <tt>size[1]</tt> respectively.',
			'averagePooling1d_description' => 'Average pooling operation for spatial data.',
			'averagePooling2d_description' => 'Average pooling operation for spatial data.',
			'averagePooling3d_description' => 'Average pooling operation for 3d data.',
			'maxPooling1d_description' => 'Max pooling operation for temporal data.',
			'maxPooling2d_description' => 'Global max pooling operation for spatial data.',
			'maxPooling3d_description' => 'Global max pooling operation for 3d data.',
			'alphaDropout_description' => 'Applies Alpha Dropout to the input. As it is a regularization layer, it is only active at training time.',
			'gaussianDropout_description' => 'Apply multiplicative 1-centered Gaussian noise. As it is a regularization layer, it is only active at training time.',
			'gaussianNoise_description' => 'Apply additive zero-centered Gaussian noise. As it is a regularization layer, it is only active at training time.',
			'DebugLayer_description' => "Log internal state of the data to the developer's console (like <tt>console.log</tt>). Does nothing to the data itself and returns them unchanged.",
			'max_number_of_values' => 'Max number of values (0 = no limit)',
			'provide_x_data' => 'Provide X-data file',
			'provide_y_data' => 'Provide Y-data file',
			'download_custom_zip_file' => 'Download custom data in a .zip file',
			'delay_between_images' => 'Delay in seconds between images in a series',
			'number_of_images_in_series' => 'Number of images in a series',
			'restart_fcnn' => "Restart FCNN",
			'undo_redo_stack_lost' => 'Undo/redo stack lost!',
			'changing_mode_deletes_stack' => 'Changing the mode deletes the undo/redo stack.',
			'auto_adjust_last_layer_if_dense' => "Auto-adjust last layer's number of neurons (if Dense)",
			'load_images' => 'Load Images',
			"loading_data" => 'Loading data',
			'ai_tries_to_draw' => 'The AI tries to draw how it thinks the categories look like...',
			'stop_generating_images' => 'Stop generating images',
			'stopped_generating_images' => "Stopped generating new images, this may take a while",
			'now_being' => 'Now, ',
			'images_of_each_category' => 'Images of each categories are being loaded.',
			'one_second' => "1 second",
			'years' => 'years',
			'year' => 'year',
			'minutes' => 'minutes',
			'minute' => 'minute',
			'seconds' => 'seconds',
			"hours" => "hours",
			'second' => 'second',
			'days' => 'days',
			'day' => 'day',
			'left' => 'left',
			"example_images" => "Example Images",
			"and_try_to_draw_a_warning_sign" => "and try to draw a warning sign",
			"go_back_to_examples" => "to go back to example images",
			'the_training_was_only_with' => 'The training has been done with only',
			'images_and' => 'images and',
			'epochs_done' => 'epochs done. Thus, the results are probably bad',
			'this_may_take_a_while' => 'This may take a while',
			"loading_images_into_memory" => "Loading images into memory",
			"train_the_neural_network" => "Tap here to train neural network",
			"train_further" => "Train the network further",
			"loading_model" => "Loading model",
			"loading_example_images" => "Loading example images",
			"undoing_redoing" => "Undoing/redoing",
			"skip_presentation" => "Skip &rarr;",
			"very_unsure" => "Very unsure",
			"quite_unsure" => "Quite unsure",
			"a_bit_unsure" => "A bit unsure",
			"neutral" => "A bit sure",
			"relatively_sure" => "Relatively sure",
			"very_sure" => "Very sure",
			"time_per_batch" => "Time per Batch",
			"training" => "Training",
			"done_training_took" => "Done Training, took",
			"done_generating_images" => "Done generating images",
			"generating_image_for_neuron" => "Generating image for neuron",
			"failed_try_again" => "failed. Trying again",
			"fixing_output_shape" => "Output shape is being fixed...",
			"output_shape_repaired" => "Output shape repaired",
			"please_try_training_again" => 'Please try training again',
			'No' => 'No',
			'Yes' => 'Yes',
			'autofix_output_shape' => 'Do you want to automatically fix the output shape?',
			'defective_output_shape' => 'Defective output shape detected',
			"switched_to_beginner_mode" => "Switched to beginner mode",
			"beginner" => "Beginner",
			"expert" => "Expert",
			'changed_mode_from' => "Changed mode from",
			"to" => "to",
			"lost_undo_redo_stack" => "lost undo/redo stack",
			"stopped_training" => "Stopped training",
			"updating_predictions" => "Updating predictions",
			"loaded_configuration" => "Loaded configuration",
			"model_is_ok" => "Model is OK",
			"got_data" => "Got data, tensors created",
			"site_is_ready" => "Site is ready",
			"trying_to_set_backend" => "Trying to set backend",
			"backend_set" => "Backend set",
			"set_theme" => "Set theme",
			"theme_set" => "Theme set",
			"has_cookie_for" => "Has cookie for",
			"initializing_losses" => "Initializing losses",
			"initializing_metrics" => "Initializing metrics",
			"setting_backend" => "Setting backend",
			"properly_set_backend" => "Backend set properly",
			"width" => "width",
			"height" => "height",
			"changing" => "Changing",
			"changed_data_source" => "Changed data source",
			"hiding_augmentation" => "Hiding augmentation",
			"showing_augmentation" => "Showing augmentation",
			"input_shape_is_read_only" => "The Input-Shape read-only",
			"input_shape_is_writable" => "The Input-Shape is editable",
			"updating_page" => "Updating page...",
			"page_update_took" => "Page update took",
			"getting_labels" => "Getting labels",
			"compiling_model" => "Compiling model",
			"done_changing" => "Done changing",
			"took" => "took",
			"setting_layer" => "Setting layer",
			"setting_options_for_layer" => "Setting options for layer",
			"creating_model" => "Creating model",
			"graph_explanation" => "The lines in the graph represent the error. The lower the line, the smaller the error.<hr class='cosmo_hr'>The blue line indicates the improvements on the data that the network is trained on, while the orange line indicates how well it performs on data it hasn't seen before.<hr class='cosmo_hr'>Both lines should decrease and look somewhat similar for the training to be progressing well.",
			"previous_images" => "Previous images",
			"current_images" => "Current images",
			"predictions_explanation_while_training" => "Down below is one example of each category. The bars show the calculated likelihood of the image to be in that category. The most strongly detected category is green. You can see the Categories change as the network learns.",
			"prohibition" => "Prohibition",
			'Brandschutz' => 'Fire prevention',
			'Verbot' => 'Prohibition',
			'Gebot' => 'Mandatory',
			'Rettung' => 'Rescue',
			'Warnung' => 'Warning',
			"currently" => "Currently",
			"correct" => "correct",
			"wrong" => "Wrong",
			"total" => "Total",
			"images_are_being_detected_correctly" => "images are being detected correctly",
			"category" => "Kategorie",
			"percentage_correct" => "Percentage correct",
			"training_done_text" => "The training phase is complete. If the accuracy is still insufficient, the network can be further trained to potentially achieve better results.",
			"initializing_categories" => "Initializing categories",
			"initializing_tabs" => "Initialisiere Tabs",
			"initializing_page_contents" => "Initializing page contents",
			"initializing_set_options_for_all" => "Initializing 'set options for all'",
			"got_data_creating_tensors" => "Got data, creating tensors...",
			"started_training" => "Started training",
			"compiling model" => "Compiling model",
			"compiled_model" => "Compiled model",
			"finished_training" => "Finished training",
			"stopped_downloading_because_button_was_clicked" => "Stop downloading because stop-download-button was clicked",
			"weight_matrix" => "Weight matrix",
			"weight_matrices" => "Weight matrices",
			"kernel_pixel_size" => "Kernel-pixel-size",
			"shuffle_data_before_validation_split" => "Shuffle data before doing validation split (recommended)?",
			"separator" => "Seperator",
			"auto_adjust_last_layer_neurons" => "Auto-adjust last layer's number of neurons?",
			"auto_one_hot_encoding" => 'Auto One-Hot-encode Y (disables "divide by")?',
			"auto_loss_metric" => "Auto loss/metric?",
			"auto_set_last_layer_to_linear" => "Auto-set last layer's activation to linear when any Y-values are smaller than 0 or greater than 1?",
			"divide_by" => "Divide by",
			"load_custom_function_csv" => "Load custom function (from, to, stepsize)",
			"loading_the_site_took" => "Loading the site took",
			"site_was_active" => "Page was active",
			"site_was_inactive" => "Page was inactive",
			"input_image" => "Input data",
			"generated_image" => "Generated data",
			"weights" => "Weights",
			"bias" => "Bias",
			"activation_function_of_neuron" => "Activation function of Neuron/Filter",
			"maximally_activated_explanation" => "The neuron visualization method utilizes an input image (x) to generate a resulting image (x∗). It involves utilizing the weights (W) and bias (b) of a neuron to apply an activation function (f(x;W,b)) to the input image. This activation function determines how strongly the neuron responds to specific features in the image. The result is determined using the argmax function, which identifies the region in the image that triggers the highest activation of the neuron. This region is then further refined to optimize the generated image. The process is iterative, adjusting the input image based on the gradients of the activation function until the desired outcome is achieved.",
			"start" => "Start",
			"end" => "End",
			"stepsize" => "Stepsize",
			"function_with_explanation" => "Function (use x and/or y as variables and JavaScript-Functions like <tt>Math.sin(x)</tt>)",
			"no_header_lines_found" => "No header line found",
			"no_data_lines_found" => "No data lines found",
			"duplicate_header_entries_found" => "Duplicate header entries found",
			"remove_data_img_predictions" => "Remove predictions",
			"beta1" => "&beta;<sub>1</sub>",
			"beta2" => "&beta;<sub>2</sub>",
			"epsilon" => "&epsilon;",
			"rho" => "&rho;",
			"initial_accumulator_value" => "Initial Accumulator Value",
			"decay" => "Decay",
			"momentum" => "Momentum",
			"no_decimal_points_math_mode" => "Number of decimal points (0 = no limit)",
			"max_nr_vals" => "Maximum number of rows/columns per matrix",
			"train_visualization_only_works_for_default_data" => "Train visualization only works for default data.",
			"train_visualization_only_works_for_classification_problems" => "Train visualization only works for default data.",
			"train_visualization_only_works_for_images" => "Train visualization only works for images.",
			"train_visualization_only_works_when_last_layer_is_softmax" => "Train visualization only works when the last layer has the SoftMax-activation function.",
			"setting_width" => "Setting width",
			"setting_height" => "Setting height",
			"model_not_given" => "Model not given",
			"could_not_get_model" => "Could not get model",
			"privacy_tainted_no_longer_screenshots" => "Privacy is tainted. Bug reports will no longer contain screenshots.",
			"stop_downloading_start_training" => "Stop downloading and start training",
			"failed_to_add_layer_type" => "Failed to add layer type:",
			"the_loaded_model_has_no_layers" => "The loaded model has no layers",
			"old_model_had_no_layers" => "Old model had no layers defined",
			"no_layers_found" => "No layers found",
			"no_model_found" => "No model found",
			"start" => "Start",
			"log" => "Log",
			"code_and_contact" => "Code and contact",
			"visualization_tab" => "Visualization",
			"augmentation" => "Augmentation",
			"general" => "General",
			"different_number_layers_gui_model" => "There is a different number of layers in the GUI than in the model",
			"model" => "model",
			"removed_layer" => "Removed layer",
			"added_layer" => "Added layer",
			"getting_data" => "Getting data",
			"started_training" => "Started training",
			"prediction_done" => "Prediction done",
			"inverted_image" => "Inverted image",
			"starting_webcam" => "Starting webcam",
			"stopping_webcam" => "Stopping webcam",
			"rotating_image" => "Rotating image",
			"webgl_not_supported" => "WebGL is not supported",
			"found_camera" => "Found camera",
			"webcam_access_denied" => "Webcam access was denied",
			"x_data_incomplete" => "X-Data is yet incomplete",
			"y_data_incomplete" => "Y-Data is yet incomplete",
			"took_photo_from_webcam" => "Took photo from webcam",
			"only_one_webcam" => "Has only one camera, no front and back camera",
			"taking_photo_from_webcam" => "Taking photo from webcam",
			"changed_metrics" => "Changed metrics",
			"using_camera" => "Using camera",
			"no_webgl_using_cpu" => "Has no WebGL. Using CPU backend.",
			"setting_epochs_to" => "Setting epochs to",
			"set_labels" => "Set labels",
			"not_changing_labels_they_stayed_the_same" => "Not changing labels, they stayed the same",
			"saving_current_status" => "Saving current status",
			"you_cannot_use_gradcam_and_internal_states_together" => "You can either use gradCAM or the internal layer states, but not both.",
			"temporarily_using_expert_mode" => "Temporarily using expert mode",
			"predict_data_shape" => "Predict data shape",
			"error" => "Error",
			"prediction_failed" => "Prediction failed",
			"done_setting_initializer" => "Done setting initializer",
			"setting_initializer" => "Setting initializer",
			"setting_seed_to" => "Setting seed to",
			"done_setting_seed_to" => "Setting seed to",
			"waiting_for_screenshot" => "Waiting for screenshot",
			"done_reinitializing" => "Done re-initializing",
			"starting_reinitializing" => "Started re-initializing",
			"are_you_sure" => "Are you sure?",
			"this_loses_your_training_process_but_you_can_undo_it" => "This loses your training progress, but you can undo it.",
			"yes_reinit" => "Yes, re-init!",
			"tried_reinit_but_no_model_found" => "Tried re-initializing, but no model was found",
			"reinit_cancelled" => "Re-init cancelled",
			"checked_possible_layer_types" => "Checked possible layer types",
			"checking_webcams" => "Checking webcams",
			"flip_left_right" => "Flip left/right",
			"no_model_found_but_has_missing_values" => "No model found, but has missing values",
			"not_creating_model_because_some_values_are_missing" => "Not creating model because some values are missing",
			"an_error_occured_setting_weights_check_dev_console" => "An error occured setting the weights. Check the developer's console for more details.",
			"cannot_show_gradcam_while_training" => "Cannot show gradCAM while training",
			"not_wasting_resources_on_gradcam_when_not_visible" => "Not wasting resources on gradCAM when the predict tab is not visible anyways.",
			"cannot_use_gradcam_without_conv_layer" => "Cannot continue using gradCAM when you have no convolutional layers",
			"cannot_predict_two_layers_at_the_same_time" => "Cannot predict 2 layers at the same time. Waiting until done",
			"inverted_image_that_has_been_turned" => "Inverted image that has been turned",
			"awaiting_finishing_of_training" => "Awaiting finishing of training",
			"auto_augmenting_images" => "Auto augmenting images",
			"somehow_there_were_zero_training_data_consider_it_a_bug" => "Somehow, there were 0 training data available. Consider this a bug in asanAI if you have chosen default settings.",
			"generating_data_from_images" => "Generating data from images",
			"done_generating_data_from_images" => "Done generating data from images",
			"auto_augmentation_currently_not_supported_for_segmentation" => "Auto-Augmentation is currently not implemented for image segmentation",
			"enough_labels_for_one_hot_encoding" => "Enough labels for oneHot-Encoding",
			"currently_there_is_a_bug_for_one_hot_encoding_with_only_one_vector_so_its_disabled" => "Currently, there is a bug that only allows Auto-One-Hot-Encoding with a one-column-vector only. Therefore, Auto-One-Hot-Encoding has been disabled",
			"using_camera" => "Using camera",
			"soon_a_photo_series_will_start" => "Soon, a photo-series will start",
			"first_photo_will_be_taken_in_n_seconds" => "First photo will be taken in <b></b> seconds.",
			"flip_left_right_that_has_been_turned" => "Flip left/right image that has been turned",
			"done_taking_n_images" => "Done taking %d images",
			"taking_image_n_of_m" => "Taking image %d/%d",
			"not_enough_labels_for_one_hot_encoding_got_n_need_at_least_two" => "Not enough labels for oneHot-Encoding (got %d, need at least >= 2)",
			"redone_last_undone_change" => "Redone last undone change",
			"undone_last_change" => "Undone last change",
			"generated_encodings" => "Generated encodings",
			"auto_generating_enables_but_no_labels_given" => "Auto-encoding enabled, but no labels given",
			"changed_metrics" => "Changed metrics",
			"setting_all_kernel_initializers_to" => "Setting all kernel initializers to",
			"setting_all_bias_initializers_to" => "Setting all bias initializers to",
			"setting_all_activation_functions_except_last_layer_to" => "Setting all activation functions (except for last layer) to",
			"setting_all_activation_functions_to" => "Setting all activation functions to",
			"setting_labels_from_config" => "Setting labels from config",
			"setting_activation_function_of_layer_n_to_linear" => "Setting the activation function of layer %d to linear",
			"setting_neurons_or_filters_of_layer_n_to_3" => "Setting the neurons/filter of layer %d to 3",
			"error_keras_not_found_in_config" => "Error: keras not found in config",
			"ok_chosen_dataset" => "OK: chosen dataset",
			"setting_optimizer_to_rmsprop" => "Setting optimizer to rmsprop",
			"deleting_layer_for_custom_image" => "Deleting layer for custom image",
			"setting_batch_size_to" => "Set batchsize to",
			"initializing_epochs_to" => "Initializing epochs to",
			"setting_weights_from_config_weights" => "Setting weights from config-weights",
			"error_failed_to_load_model_and_or_weights" => "Failed to load model and/or weights",
			"error_cannot_load_this_model_file_is_it_json_from_asanai_or_a_graph_model" => "Error: Cannot load this model file. Is it a JSON file from asanAI? Is it maybe a graph model?",
			"input_size_too_small_restoring_last_known_good_config" => "The input size was too small. Restoring input size to the last known good configuration:",
			"waiting_n_seconds" => "Waiting %d seconds...",
			"done_waiting_n_seconds" => "Done waiting %d seconds...",
			"model_doesnt_include_layers_cannot_show_in_latex" => "model does not include layers. Cannot be shown in LaTeX",
			"unknown_optimizer" => "Unknown optimizer:",
			"optimizer_algorithm" => "Optimizer algorithm",
			"given_object_not_a_tensor" => "Given object is not a tensor",
			"tensor_already_disposed_where_it_shouldnt_be" => "Tensor is already disposed, where it shouldn't be.",
			"arr_is_undefined_or_false" => "arr is undefined or false",
			"arr_is_not_an_array" => "arr is not an array",
			"model_is_not_defined" => "Model is not defined",
			"waiting_for_model" => "Waiting for model",
			"adding_layer" => "Adding layer",
			"trained_nn_n_and_m_results" => "trained nn: %d and %d results:",
			"could_not_install_new_callback" => "Could not install new callback",
			"can_only_run_one_test_at_a_time" => "Can only run one test at a time",
			"unknown_backend" => "Unknown backend",
			"empty_predictions_tensor_in_predict_webcam" => "Empty predictions_tensor in predict_webcam",
			"cam_not_defined_existing_webcam" => "cam not defined. Exiting webcam.",
			"predictions_tensor_not_defined" => "predictions_tensor not defined",
			"the_tensor_about_to_be_predicted_was_empty" => "The tensor about to be predicted was empty.",
			"model_or_layer_was_already_disposed_not_predicitng" => "Model or layer was already disposed, not predicting.",
			"already_predicting_exiting_webcam" => "Already predicting. Exiting webcam.",
			"no_model_defined" => "No model defined",
			"arr_is_an_array_but_empty" => "arr is an array but empty",
			"arr_is_an_array_but_multidimensional_it_needs_to_be_one_dimensional" => "arr is an array, but it seems to be multidimensional. It can only be one-dimensional.",
			"global_model_data_is_empty" => "global_model_data is empty!",
			"using_resize_type" => "Using resize type",
			"something_went_wrong_when_trying_to_determine_get_units_at_layer" => "Something went wrong when trying to determine get_units_at_layer",
			"there_was_an_error_getting_default_resize_method" => "There was a problem getting #default_resize_method",
			"unknown_value" => "Unknown value",
			"unknown_swal_r" => "Unknown Swal r",
			"new_number_of_output_neurons_is_zero_or_undefined" => "New number of output neurons is 0 or undefined",
			"do_not_change_neurons_while_is_setting_config_is_true" => "Do not change neurons while is_setting_config is true",
			"new_number_of_output_neurons_matches_the_number_already_in_the_model" => "New number of output neurons matches the number of neurons already in the model",
			"cannot_autoset_layer_errors" => "Cannot autoset layer. Errors:",
			"batch_dimension_in_output_shape_must_be_null" => "Batch-dimension in output shape must be null",
			"output_shape_length_must_be_two" => "Output-shape length must be 2",
			"last_layer_must_be_of_type_dense" => "Last layer must be of type dense",
			"last_layer_must_have_softmax_to_autoset_layers" => "Last layer must have softmax activation function to autoset layers",
			"data_is_undefined" => "Data is undefined",
			"the_real_output_shape_x_does_not_match_the_expected_output_shape_y" => "The real output shape ([%s]) does not match the expected output shape ([%s])",
			"the_number_of_categories_n_doesnt_match_the_number_of_given_canvasses_m" => "The number of categories (%d) doesn't match the number of given canvasses (%d)",
			"initializer_value_failed_should_be_n_is_m" => "Initializer value failed: Should be: %d, is: %d",
			"not_rerunning_run_neural_network" => "Not re-running run_neural_network",
			"unknown_reason_for_not_displaying_simple_visualization" => "Unknown reason for not displaying simple visualization",
			"x_shape_is_wrong_for_simple_visualization" => "X-shape is wrong for simple visualization",
			"y_shape_is_wrong_for_simple_visualization" => "Y-shape is wrong for simple visualization",
			"model_shape_is_wrong_for_simple_visualization" => "Model-shape is wrong for simple visualization",
			"waiting_for_set_dense_layer_units" => "Waiting for set_dense_layer_units",
			"no_layers" => "No layers",
			"could_not_get_xs_and_xy" => "Could not get xs_and_ys",
			"no_model_to_compile" => "No model to compile",
			"missing_title" => "Missing title",
			"start_must_be_a_number" => "Start must be a number",
			"end_must_be_a_number" => "End must be a number",
			"changing_selectedIndex" => "Changing selectedIndex",
			"changing_val_to" => "Changing val to",
			"awaiting_disable_invalid_layers_event" => "Awaiting disable_invalid_layers_event()",
			"currently_waiting_for_n_layer_m_becoming_equal_to_a" => "Currently waiting for \"%s\" (layer %d) becoming equal to %s",
			"start_waiting_for_x_becoming_equal_to_y" => "Start waiting for \"%s\" becoming equal to %s",
			"setting_the_units_of_layer_n_to_m" => "Setting the units of layer %d to %d",
			"clicking_on_this_item_for_layer_duplication" => "Clicking on this item for layer duplication:",
			"waiting_until_model_layers_length_m_minus_start_layers_n_is_greater_than_zero" => "Waiting until model.layers.length (%d) - (start_layers) (%d) > 0",
			"webcam_is_hidden_also_fcnn_not_visible_exiting_webcam" => "Webcam is hidden, also, fcnn_canvas is not visible. Exiting webcam.",
			"model_has_no_input" => "Model has no input",
			"predictions_tensor_was_empty" => "Predictions tensor was empty",
			"model_was_already_disposed" => "Model was already disposed",
			"cannot_predict_since_the_data_about_to_be_predicted_is_already_disposed" => "Cannot predict since the data about to be predicted is already disposed.",
			"cannot_get_model_input_shape" => "Cannot get model.input.shape",
			"predict_data_is_already_disposed" => "predict_data is already disposed",
			"predict_demo_failed_error" => "Predict demo failed, error:",
			"uploading_custom_images_is_only_supported_for_image_models" => "Uploading custom images is only supported for image models.",
			"error_while_getting_reader_result" => "Error while getting reader.result",
			"the_zip_file_you_uploaded_seems_to_be_corrupt_or_partially_uploaded" => "The zip file you uploaded seems to be corrupt or only partially uploaded.",
			"it_seems_like_uploading_the_file_has_failed" => "It seems like uploading the file has failed",
			"no_model" => "No model",
			"recursion_level_for_compile_model_too_high" => "recursion level for compile_model too high",
			"model_doesnt_include__call_hook" => "model does not include _callHook",
			"model_get_weights_is_not_a_function" => "model.getWeights is not a function",
			"wrong_model_but_thats_ok_because_you_are_testing_unusual_function_inputs" => "Wrong model, but that's okay because you are testing unusual function inputs",
			"saving_model_failed" => "Saving model failed",
			"model_may_be_defective_and_cannot_be_saved" => "The model may be defective and cannot be saved. Sorry. The error is",
			"parsing_error_in_get_weights_shape" => "Parsing error in get_weights_shape",
			"but_ok_because_fake_model" => "but ok because fake_model",
			"given_model_is_not_a_model" => "given model is not a model",
			"get_weights_is_not_defined" => "getWeights is not defined",
			"weights_n_is_disposed" => "weights[%d] is disposed",
			"error_while_loading_custom_images_zip_file" => "Error while loading custom images zip file",
			"error_at_executing_show_snow" => "Error executing show_snow",
			"loading_time_took_more_than_n_seconds_which_is_too_slow" => "Loading time took more than %d seconds which is way too slow!",
			"invalid_layer_nr_max_layer_n_layer_nr_m" => "Invalid layer number: max_layer: %d, layer_nr: %d",
			"get_weights_is_not_a_function_model_may_have_been_undefined" => "getWeights is not a function. The model may have been undefined while attempting this.",
			"error_in_download" => "Error in download",
			"e_is_undefined_in_get_weights_as_string_probably_harmless" => "e is undefined in get_weights_as_string. This has happened to me when rebuilding the model after it was set to null. If this happened here, it is most probably harmless.",
			"cannot_find_model_using_global_one" => "Cannot find model, using global one",
			"weights_json_was_not_valid" => "The weights.json file you uploaded did not contain valid JSON. Do not use the .bin-file. Use the .json-file.",
			"weights_loaded_successfully" => "Weights loaded successfully",
			"error_loading_weights" => "Error loading weights",
			"set_weights_from_json_object_json_was_empty" => "set_weights_from_json_object: json is empty",
			"could_not_find_input" => "Could not find input",
			"idname_is_null_returning" => "idname is null. Returning.",
			"idname_is_undefined_returning" => "Undefined idname. Returning.",
			"x_and_y_keys_must_have_same_nr_of_values_but_has_m_and_y" => "x and y keys must have the same number of values. They are different, x has %d keys and y has %d keys!",
			"failed_temml" => "failed temml:",
			"could_not_get_fcnn_data" => "Could not get FCNN data",
			"could_not_retrieve_x_data" => "Could not retrieve x data",
			"could_not_retrieve_y_data" => "Could not retrieve y data",
			"last_layer_not_dense" => "Last layer not dense",
			"an_error_occured" => "An error occurred:",
			"start_and_end_number_are_equal" => "Start and end are equal",
			"model_layers_is_not_defined_or_empty" => "model.layers is not defined or empty",
			"there_was_an_error_compiling_the_model" => "There was an error compiling the model",
			"stepsize_is_not_a_number" => "stepsize is not a number",
			"stepsize_cannot_be_zero" => "Stepsize cannot be 0",
			"function_is_too_short" => "Function is too short.",
			"end_number_must_be_something_other_than_zero" => "End number must be a number other than 0!",
			"start_number_must_be_something_other_than_zero" => "Start must be a number other than 0!",
			"function_does_not_include_x" => "Function does not include x",
			"desc_boxes_and_layers_different_length" => "The description boxes and the layers have a different length",
			"tensor_already_disposed_write_optimizer_to_math_tab" => "Tensor already disposed in write_optimizer_to_math_tab",
			"download_with_data_disabled_input_shape_doesnt_have_four_elements" => "'Download with data' disabled because the input-shape does not have 4 elements, but looks like this",
			"download_with_data_disabled_input_shape_doesnt_have_two_elements" => "'Download with data' disabled because the input-shape does not have 2 elements, but looks like this",
			"setting_divide_by_to" => "Setting divide_by to",
			"setting_max_number_of_files_per_category_to" => "Setting max_number_of_files_per_category to",
			"example_predict_data_was_empty" => "example_predict_data was empty",
			"no_classes_found" => "No classes found",
			"download_with_data_disabled_because_the_loss_is_not_categorical_cross_entropy" => "'Download with data' disabled because the loss is not categoricalCrossentropy",
			"download_with_data_disabled_because_not_classification_problem" => "'Download with data' disabled because the current problem does not seem to be a classification problem",
			"download_with_data_disabled_because_no_layers" => "'Download with data' disabled because has no layers",
			"download_with_data_disabled_because_no_model" => "'Download with data' is disabled because the Model is not defined",
			"stepsize_cannot_be_zero" => "Stepsize cannot be 0",
			"no_content" => "No content",
			"tensor_shape_does_not_match_model_shape_not_predicting_example" => "tensor shape does not match model shape. Not predicting example text. Input shape/tensor shape",
			"value_is_empty" => "Value is empty",
			"wrong_input_shape_for_prediction_data_x_model_y" => "Wrong input shape for prediction. Data: [%s], model: [%s]",
			"no_max_number_of_files_per_category_found_in_config" => "No max_number_of_files_per_category found in config",
			"layers_not_in_model" => "Layers not in model",
			"img_blob_could_not_be_found" => "Img-blob could not be found!",
			"not_fanavg_nor_fanin" => "Not fanAvg, nor FanIn",
			"cannot_determine_type_of_layer" => "Cannot determine type of layer",
			"xy_data_does_not_contain_x", "xy_data does not contain x",
			"xy_data_does_not_contain_y", "xy_data does not contain y",
			"canvas_blob_could_not_be_found" => "Canvas-blob could not be found!"
		),

		'de' => array(
			"predicted_category" => "Vorhergesagte Kategorie",
			"correct_category" => "Richtige Kategorie",
			"model_was_set" => "Modell erfolgreich gesetzt",
			'example_csv_shoe_size' => 'Schuhbeispiel-CSV laden (0 = männlich, 1 = weiblich)',
			'Brandschutz' => 'Brandschutz',
			'Gebot' => 'Gebot',
			'we_want_to_train_this_model_5_categories' => 'Der Computer soll nun lernen, Bilder in die jeweils passende der fünf vorgegebenen Kategorien einzuordnen.',
			'fire' => 'Brandschutz',
			'mandatory' => 'Gebot',
			'prohibition' => 'Verbot',
			'rescue' => 'Rettung',
			'warning' => 'Warnung',
			'the_more_variations_the_model_sees' => 'Je mehr Variationen das Modell sieht, desto besser kann es die wichtigsten Merkmale der Bilder lernen.',
			'quality_depends_on_random' => 'Die Qualität des Ergebnisses hängt vom Zufall ab.',
			'program_looks_at_data' => 'Der Lernprozess (das Training) läuft jetzt und der Computer probiert durch Versuch und Irrtum sehr viele verschiedene Filterkonfigurationen aus.',
			'the_further_on_top_the_better' => "Insbesondere am Anfang des Trainings werden viele Bilder noch in die falsche Kategorie eingeordnet. Im weiteren Verlauf wird dann zunehmend jeweils die richtige Kategorie zugeordnet, wobei diese Zuordnung auch immer zuverlässiger ist. Diese kategoriale Zuordnung ist umso zuverlässiger, je weiter ein Bild nach oben in den blauen Bereich wandert.",
			'add_category' => 'Kategorie hinzufügen',
			'settings' => 'Einstellungen',
			'description' => 'Be&shy;schrei&shy;bung',
			'use_bias' => 'Bias benutzen',
			'activation_function' => 'Aktivier&shy;ungs&shy;fun&shy;ktion',
			'bias_initializer' => 'Bias-Initialisierer',
			'kernel_initializer' => 'Kernel-Initialisierer',
			'trainable' => 'Trainierbar',
			'visualize_layer' => 'Layer visualisieren',
			'visualize_this_layer' => 'Diesen Layer visualisieren',
			'examples' => 'Beispiele',
			'dataset' => 'Datensatz',
			'height' => 'Höhe',
			'width' => 'Breite',
			'batch_size' => 'Batchgröße',
			'epochs' => 'Epochen',
			'own_data' => 'Datenquelle',
			'filters' => 'Filter',
			'distribution' => 'Verteilung',
			'image_options' => 'Bildoptionen',
			'feature_extraction' => 'Merkmalsex&shy;traktion',
			'classification' => 'Klassi&shy;fikation',
			'flatten' => 'Verflachen',
			'dataset_and_network' => 'Datensatz und Netzwerk',
			'visualization' => 'Modellvisualisierung',
			'data' => 'Daten',
			'training_data' => 'Daten',
			'currently_the_network_has_seen' => 'Die verbleibende Zeit in dieser Trainingsphase beträgt noch ca.',
			'of' => 'von',
			'times_seen' => 'mal angesehen',
			'it_will_take_about' => 'Es wird noch ca.',
			'remain_left' => 'dauern',
			'camera_draw_self' => 'Kamera/selbstmalen',
			'click_on' => 'Berühre',
			'if_bad_continue_training' => 'Wenn die Ergebnisse noch zu schlecht sind, trainiere weiter.',
			'the_ai_thinks_categories_look_like_this' => 'Eine visuelle Repräsentation dessen, was die KI gelernt hat',
			'it_might_only_be_noise' => 'Daher sehen Sie hier wahrscheinlich nur Rauschen und die Erkennung geht noch nicht.',
			'image_left' => 'Bild übrig',
			'images_left' => 'Bilder übrig',
			'beginner' => 'Anfänger',
			'expert' => 'Experte',
			'except_last_layer' => 'außer letztem Layer',
			'activation_functions' => 'Aktivierungsfunktionen',
			'set_for_all_layers' => 'Einstellungen für alle Layer',
			'shuffle_before_each_epoch' => 'Vor jeder Epoche zufällig sortieren',
			'summary' => 'Zusammenfassung',
			'own_images' => 'Eigene Bilder',
			'own_tensor' => 'Eigene Tensoren',
			'kernel_size' => 'Kernel-Größe',
			'start_training' => 'Training starten',
			'stop_training' => 'Training stoppen',
			'imprint' => 'Impressum',
			'change_shape' => 'Shape verändern',
			'simulate_real_data' => 'Echten Daten simulieren',
			'dimensionality_reduction' => 'Di&shy;men&shy;sio&shy;ns&shy;re&shy;duk&shy;tion',
			'shy_activation_function' => 'Ak&shy;ti&shy;vier&shy;ungsfun&shy;ktion',
			'shy_overfitting_prevention' => 'Over&shy;fit&shy;ting ver&shy;hinderung',
			'rescale_and_recenter' => 'Reskalierung und Zentrierung',
			'show_layer_data_flow' => 'Datenfluss anzeigen',
			'show_grad_cam' => 'gradCAM anzeigen',
			'code' => 'Quellcode',
			'own_csv' => 'Eigene CSV',
			'training' => 'Training',
			'predict' => 'Predict',
			'hyperparameters' => 'Hyperparameter',
			'valsplit' => 'Val.-Split',
			'divide_x_by' => 'Teile <i>X</i> durch',
			'metric' => 'Metrik',
			'loss' => 'Loss',
			'optimizer' => 'Optimierer',
			'learning_rate' => 'Lernrate',
			'enable_tf_debug' => 'TFJS Debugger aktivieren',
			'enable_webcam' => 'Webcam aktivieren',
			'disable_webcam' => 'Webcam deaktivieren',
			'switch_to_other_cam' => 'Zur anderen Kamera wechseln',
			'copy_to_clipboard' => 'In Zwischenablage kopieren',
			'copy_to_clipboard_debug' => 'In Zwischenablage kopieren (Debug)',
			'set_all_initializers' => 'Setze alle Initialisierer',
			'augmentation' => 'Augmentierung',
			'iterations' => 'Iterationen',
			'close' => 'Schließen',
			'register' => 'Registrieren',
			'csv' => 'CSV',
			'math' => 'Mathe',
			'smaller' => 'Kleiner',
			'larger' => 'Größer',
			'reset' => 'Reset',
			'delete_predictions' => 'Predictions löschen',
			'memory_usage_while_training' => 'Speicherverbrauch während des Trainings (pro Batch)',
			'img_per_cat' => 'Bilder/Kat.',
			'batches' => 'Batches',
			'login' => 'Anmelden',
			'username' => 'Benutzername',
			'password' => 'Passwort',
			'download' => 'Herunterladen',
			'email' => 'E-Mail',
			'public' => 'Öffentlich',
			'save' => 'Speichern',
			'augment' => 'Augmentieren',
			'download_model_data' => 'Modelldaten downloaden',
			'logout' => 'Abmelden',
			'load' => 'laden',
			'download_for_local_taurus' => 'Für lokales oder Taurus-Training herunterladen',
			'max_activated_neurons' => 'Maximal aktivierte Neuronen',
			'no_default_data' => 'Standarddaten',
			'yes_own_tensor' => '&#x2318; eigene Tensordaten',
			'yes_own_csv' => '&#128290; eigene CSV',
			'yes_own_images' => '&#128444; eigene Bilder/Webcam',
			'width_amp_height' => 'Höhe&amp;Breite (0 = auto)',
			'randomizer_limits' => 'Randomisierergrenzen',
			'max_neurons_fcnn' => 'Max. Neuronen FCNN',
			'various_plots' => 'Verschiedene Plots',
			'sources_and_used_programs' => 'Quellen',
			'visualize_images_in_grid' => 'Bilder in Grid visualisieren',
			'model_compiled_successfully' => 'Modell erfolgreich kompiliert',
			'not_creating_model_because_values_are_missing' => 'Kann Modell nicht erstellen, weil Werte fehlen',
			'tensors' => 'Tensoren',
			'set_val_split_to' => 'Setze den Validation-Split auf ',
			'set_optimizer_to' => 'Setze den Optimierer auf ',
			'set_metric_to' => 'Setze die Metrik auf ',
			'set_loss_to' => 'Setze den Loss auf ',
			'show_bars_instead_of_numbers' => 'Balken statt Zahlen verwenden',
			'number_of_grid_images' => 'Anzahl Bilder im Grid',
			'show_raw_data' => 'Rohdaten anzeigen',
			'pixel_size' => 'Pixelgröße',
			'auto_rotate_images' => 'Bilder automatisch rotieren',
			'number_of_rotations' => 'Anzahl Rotationen',
			'pretext_prepare_data' => 'Sie müssen Ihre Daten selbst vorbereiten! Sie können folgenden Code nehmen, um Datenstrukturen aus Python in das richtige Format umzuwandeln, das Sie mit asanAI benutzen können.',
			'reinitialize_weights' => 'Gewichte reinitialisieren',
			'batch_plot_minimum_time' => 'Minimale Zeit zwischen Batch-Plots',
			'loss_metric_data_and_shape' => 'Loss, Metrik, Daten und Shapes',
			'sine_ripple' => 'Sinus-Kräusel',
			'invert_images' => 'Bilder invertieren',
			'flip_left_right' => 'Bilder spiegeln',
			'layer_data_flow' => 'Layer-Datenfluss',
			'dense_description' => 'Erstellt eine dichte (vollständig verbundene) Schicht.<br>Diese Schicht implementiert die Operation: <span class="temml_me">\\mathrm{output} = \\mathrm{activation}\\left(\\mathrm{input} \\cdot \\mathrm{kernel} + \\text{bias}\\right).</span> Die Aktivierung ist die elementweise Aktivierungsfunktion, die als Aktivierungsargument übergeben wird.<br><tt>kernel</tt> ist eine Gewichtsmatrix, die von der Schicht erstellt wird.<br><tt>bias</tt> ist ein Bias-Vektor, der von der Schicht erstellt wird (nur anwendbar, wenn useBias true ist).',
			'flatten_description' => 'Flacht die Eingabe ab. Beeinflusst nicht die Batch-Größe. Eine Flatten-Schicht macht in ihren Eingaben jede Batch in 1D flach (wodurch die Ausgabe 2D wird).',
			'dropout_description' => 'Dropout besteht darin, eine Bruchteilrate der Eingabeeinheiten während jeder Aktualisierung während der Trainingszeit zufällig auf 0 zu setzen, was Überanpassung verhindert.',
			'reshape_description' => 'Formt eine Eingabe in eine bestimmte Form um.',
			"elu_description" => "Exponential Linear Unit (ELU).<br>Gleichung: <span class='temml_me'>\\text{elu}\\left(x\\right) = \\left\\{\\begin{array}{ll} \\alpha \\cdot \\left(e^x - 1\\right) & \\text{for } x < 0 \\\\ \n x & \\text{for } x >= 0\\end{array}\\right.</span>",
			"leakyReLU_description" => "Leaky-Version einer rektifizierten linearen Einheit.<br>Sie erlaubt eine kleine Steigung, wenn die Einheit nicht aktiv ist: <span class='temml_me'>\\text{leakyReLU}(x) = \\left\\{\\begin{array}{ll} \\alpha \\cdot x & \\text{for } x < 0 \\\\ \n x & \\text{for } x >= 0 \\end{array}\\right.</span>",
			'reLU_description' => 'Aktivierungsfunktion der rektifizierten linearen Einheit. <span class="temml_me">\\mathrm{relu}\\left(x\\right) = \\mathrm{max}\\left(\mathrm{Max-Value}, x\\right)</span>',
			'softmax_description' => 'Softmax-Aktivierungsschicht. <span class="temml_me">\\mathrm{softmax}\\left(x\\right) = \\frac{e^{z_j}}{\\sum^K_{k=1} e^{z_k}}</span>',
			"thresholdedReLU_description" => "Thresholded Rectified Linear Unit. Gleichung: <span class='temml_me'>f(x) = \\left\\{\\begin{array}{ll} x & \\text{for } x > \\theta \\\\ \n 0 & \\text{otherwise}\\end{array}\\right.</span>",
			'batchNormalization_description' => "Batch-Normalisierungsschicht (<a href='https://arxiv.org/abs/1502.03167' target='_blank'>Ioffe and Szegedy, 2014</a>).<br>Normalisieren Sie die Aktivierungen der vorherigen Schicht in jeder Batch, d.h. wendet eine Transformation an, die die mittlere Aktivierung nahe bei 0 und die Aktivierungsstandardabweichung nahe bei 1 hält.",
			'layerNormalization_description' => "Normalisierungsschicht (<a target='_blank' href='https://arxiv.org/abs/1607.06450'>Ba et al., 2016</a>). Normalisieren Sie die Aktivierungen der vorherigen Schicht für jedes gegebene Beispiel in einer Batch unabhängig voneinander, anstatt in einer Batch wie in der Batch-Normalisierung. Mit anderen Worten, diese Schicht wendet eine Transformation an, die die mittlere Aktivierung innerhalb jedes Beispiels nahe bei 0 und die Aktivierungsvarianz nahe bei 1 hält.",
			'conv1d_description' => '1D-Faltungs-Schicht (z.B. zeitliche Faltung).<br>Diese Schicht erstellt einen Faltungskern, der mit der Eingabe der Schicht über eine einzelne räumliche (oder zeitliche) Dimension gefaltet wird, um einen Tensor von Ausgaben zu erzeugen.<br>Wenn <tt>use_bias</tt> True ist, wird ein Bias-Vektor erstellt und den Ausgaben hinzugefügt.<br>Wenn <tt>activation</tt> nicht <tt>null</tt> ist, wird es auch auf die Ausgaben angewendet.',
			'conv2d_description' => '2D-Faltungs-Schicht (z.B. räumliche Faltung über Bilder).<br>Diese Schicht erstellt einen Faltungskern, der mit der Eingabe der Schicht gefaltet wird, um einen Tensor von Ausgaben zu erzeugen.<br>Wenn <tt>useBias</tt> True ist, wird ein Bias-Vektor erstellt und den Ausgaben hinzugefügt.<br>Wenn <tt>activation</tt> nicht null ist, wird es auch auf die Ausgaben angewendet.',
			'conv2dTranspose_description' => 'Transponierte Faltungsschicht (manchmal auch Deconvolution genannt). Der Bedarf an transponierten Faltungen ergibt sich in der Regel aus dem Wunsch, eine Transformation in die entgegengesetzte Richtung einer normalen Faltung zu verwenden, d.h. von etwas, das die Form der Ausgabe einiger Faltungen hat, zu etwas, das die Form ihres Eingangs hat, während ein Konnektivitätsmuster beibehalten wird, das mit dieser Faltung kompatibel ist.',
			'conv3d_description' => '3D-Faltungs-Schicht (z.B. räumliche Faltung über Volumen).<br>Diese Schicht erstellt einen Faltungskern, der mit der Eingabe der Schicht gefaltet wird, um einen Tensor von Ausgaben zu erzeugen.',
			'depthwiseConv2d_description' => 'Tiefe separierbare 2D-Faltung. Tiefe separierbare Faltungen bestehen darin, nur den ersten Schritt einer tiefen räumlichen Faltung durchzuführen (die auf jede Eingabeschicht separat wirkt). Das Argument "depthMultiplier" steuert, wie viele Ausgabeschichten pro Eingabeschicht im Tiefe-Schritt generiert werden.',
			'separableConv2d_description' => 'Tiefe separierbare 2D-Faltung. Separierbare Faltung besteht darin, zuerst eine räumliche Faltung in der Tiefe (die auf jede Eingabeschicht separat wirkt) durchzuführen, gefolgt von einer punktweisen Faltung, die die resultierenden Ausgabeschichten miteinander vermischt. Das Argument "depthMultiplier" steuert, wie viele Ausgabeschichten pro Eingabeschicht im Tiefe-Stufen-Schritt generiert werden.',
			'upSampling2d_description' => 'Upsampling-Schicht für 2D-Eingaben. Wiederholt die Zeilen und Spalten der Daten jeweils um <tt>size[0]</tt> bzw. <tt>size[1]</tt> Mal.',
			'averagePooling1d_description' => 'Durchschnittliche Pooling-Operation für räumliche Daten.',
			'averagePooling2d_description' => 'Durchschnittliche Pooling-Operation für räumliche Daten.',
			'averagePooling3d_description' => 'Durchschnittliche Pooling-Operation für 3d Daten.',
			'maxPooling1d_description' => 'Maximale Pooling-Operation für zeitliche Daten.',
			'maxPooling2d_description' => 'Globale Max-Pooling-Operation für räumliche Daten.',
			'maxPooling3d_description' => 'Globale Max-Pooling-Operation für 3d Daten.',
			'alphaDropout_description' => 'Wendet Alpha-Dropout auf die Eingabe an. Da es sich um eine Regularisierungsschicht handelt, ist sie nur während des Trainings aktiv.',
			'gaussianDropout_description' => 'Wendet multiplikatives gaußsches Rauschen mit einer Zentrierung um 1 an. Da es sich um eine Regularisierungsschicht handelt, ist sie nur während des Trainings aktiv.',
			'gaussianNoise_description' => 'Füge additive gaußsches Rauschen mit einer Null-Zentrierung hinzu. Da es sich um eine Regularisierungsschicht handelt, ist sie nur während des Trainings aktiv.',
			'DebugLayer_description' => 'Protokolliert den internen Zustand der Daten in die Entwicklerkonsole (wie <tt>console.log</tt>). Tut nichts mit den Daten selbst und gibt sie unverändert zurück.',
			'max_number_of_values' => 'Maximale Anzahl an Werten (0 = kein Limit)',
			'provide_x_data' => 'X-Daten',
			'provide_y_data' => 'Y-Daten',
			'download_custom_zip_file' => 'Downloade die eigenen Daten als .zip-Datei',
			'delay_between_images' => 'Wartezeit zwischen den Bildern in der Serie',
			'number_of_images_in_series' => 'Anzahl Bilder pro Serie',
			'restart_fcnn' => "FCNN neustarten",
			'undo_redo_stack_lost' => 'Rückgängig/wiederherstellen-Stack verloren!',
			'changing_mode_deletes_stack' => 'Das ändern des Modus löscht den gesamten Undo/Redo-Stack.',
			'auto_adjust_last_layer_if_dense' => "Automatisch den letzten Layer anpassen (wenn Dense)",
			'load_images' => 'Lade Bilder',
			"loading_data" => 'Lade Daten',
			'ai_tries_to_draw' => 'Die KI versucht zu malen, wie sie diese Kategorien gelernt hat...',
			'stop_generating_images' => 'Bildgenerierung stoppen',
			'stopped_generating_images' => "Die Bildgenerierung wurde gestoppt. Das kann einen Moment dauern.",
			'now_being' => 'Jetzt werden',
			'images_of_each_category' => 'Bilder aus jeder Kategorie geladen.',
			'one_second' => "1 Sekunde",
			'years' => 'Jahre',
			'year' => 'Jahr',
			'minutes' => 'Minuten',
			'minute' => 'Minute',
			'seconds' => 'Sekunden',
			"hours" => "Stunden",
			'second' => 'Sekunde',
			'days' => 'Tage',
			'day' => 'Tag',
			'left' => 'übrig',
			"example_images" => "Beispielbilder",
			"and_try_to_draw_a_warning_sign" => "und versuche ein Warnschild zu malen",
			"go_back_to_examples" => "um zu den Beispielbildern zurückzugehen",
			'the_training_was_only_with' => 'Das Training wurde mit insgesamt nur',
			'images_and' => 'Bildern und',
			'epochs_done' => 'Epochen gemacht. Die Ergebnisse sind also wahrscheinlich schlecht',
			'this_may_take_a_while' => 'Das kann einen Moment dauern',
			"loading_images_into_memory" => "Lade die Bilder in den Speicher",
			"train_the_neural_network" => "Hier klicken, um neuronales Netz zu trainieren",
			"train_further" => "Das Netzwerk weiter trainieren",
			"loading_model" => "Lade Modell",
			"loading_example_images" => "Lade Beispielbilder",
			"undoing_redoing" => "Rückgängig machen/wiederherstellen",
			"skip_presentation" => "Überspringen &rarr;",
			"very_unsure" => "Sehr unsicher",
			"quite_unsure" => "Eher unsicher",
			"a_bit_unsure" => "Ein wenig unsicher",
			"neutral" => "Ein wenig sicher",
			"relatively_sure" => "Relativ sicher",
			"very_sure" => "Sehr sicher",
			"time_per_batch" => "Zeit pro Batch",
			"training" => "Training",
			"done_training_took" => "Training fertig, es dauerte",
			"done_generating_images" => "Bilder fertig generiert",
			"generating_image_for_neuron" => "Generiere Bild für Neuron",
			"failed_try_again" => "fehlgeschlagen. Versuche es erneut",
			"fixing_output_shape" => "Output-Shape wird repariert",
			"output_shape_repaired" => "Output shape repariert",
			"please_try_training_again" => 'Bitte erneut trainieren',
			'No' => 'Nein',
			'Yes' => 'Ja',
			'autofix_output_shape' => 'Möchten Sie die Output-Shape automatisch reparieren lassen?',
			'defective_output_shape' => 'Kaputte Output-Shape entdeckt!',
			"switched_to_beginner_mode" => "In den Anfängermodus gewechselt",
			"beginner" => "Anfänger",
			"expert" => "Experte",
			'changed_mode_from' => "Modus von",
			"to" => "nach",
			"lost_undo_redo_stack" => "Rückgängig/wiederherstellen resettet",
			"stopped_training" => "Training beendet",
			"updating_predictions" => "Aktualisiere Predictions",
			"loaded_configuration" => "Konfiguration geladen",
			"model_is_ok" => "Modell ist OK",
			"got_data" => "Daten geholt, Tensoren erstellt",
			"site_is_ready" => "Seite fertig geladen",
			"trying_to_set_backend" => "Versuche, das Backend zu setzen",
			"backend_set" => "Backend gesetzt",
			"set_theme" => "Setze Theme",
			"theme_set" => "Theme gesetzt",
			"has_cookie_for" => "Hat Cookie für",
			"initializing_losses" => "Initialisiere Losses",
			"initializing_metrics" => "Initialisiere Metriken",
			"setting_backend" => "Setze Backend",
			"properly_set_backend" => "Backend erfolgreich gesetzt",
			"width" => "Breite",
			"height" => "Höhe",
			"changing" => "Ändere",
			"changed_data_source" => "Datenquelle geändert",
			"hiding_augmentation" => "Augmentierung versteckt",
			"showing_augmentation" => "Augmentierung gezeigt",
			"input_shape_is_read_only" => "Die Input-Shape ist nur lesbar",
			"input_shape_is_writable" => "Die Input-Shape ist bearbeitbar",
			"updating_page" => "Update die Seite...",
			"page_update_took" => "Das Seitenupdate brauchte",
			"getting_labels" => "Hole Labels",
			"compiling_model" => "Kompiliere Modell",
			"done_changing" => "Fertig mit Ändern der",
			"took" => "brauchte",
			"setting_layer" => "Setze Layer",
			"setting_options_for_layer" => "Setze Optionen für Layer",
			"creating_model" => "Erstelle Modell",
			"graph_explanation" => "Die Linien im Graphen zeigen den Fehler an. Umso niedriger die Linie, desto geringer der Fehler.<hr class='cosmo_hr'>Die blaue Linie zeigt die Verbesserungen auf den Daten, auf denen das Netzwerk trainiert.<hr class='cosmo_hr'>Die orange Linie zeigt an, wie gut es es auf Daten ist, die es nicht gesehen hat.<br>Beide Linien sollten niedriger werden und etwa ähnlich aussehen, damit das Training gut läuft.",
			"previous_images" => "Vorherige Bilder",
			"current_images" => "Aktuelle Bilder",
			"predictions_explanation_while_training" => "Unten ist je ein Beispiel aus jeder Kategorie. Die Balken zeigen, wie viel Prozent die jeweilige Kategorie erkannt wurde. Die am meisten erkannte Kategorie ist grün. Sie können live sehen, wie sich die Kategorien verändern, während das Netzwerk lernt.",
			"prohibition" => "Verbot",
			"Verbot" => "Verbot",
			"Rettung" => "Rettung",
			"Warnung" => "Warnung",
			"currently" => "Aktuell",
			"correct" => "richtig",
			"wrong" => "Falsch",
			"total" => "Gesamt",
			"images_are_being_detected_correctly" => "Bilder wurden richtig erkannt",
			"category" => "Kategorie",
			"percentage_correct" => "Prozent richtig",
			"training_done_text" => "Diese Trainingsphase ist abgeschlossen. Sollte die Genauigkeit noch nicht ausreichend sein, kann das Netz weiter trainiert werden, um möglicherweise bessere Ergebnisse zu erzielen.",
			"initializing_categories" => "Kategorien werden initialisiert",
			"initializing_tabs" => "Initialisiere Tabs",
			"initializing_page_contents" => "Initialisiere Seiteninhalte",
			"initializing_set_options_for_all" => "Initialisiere 'Setze Optionen für alle Layer'",
			"got_data_creating_tensors" => "Daten geholt, erstelle Tensoren...",
			"started_training" => "Training gestartet",
			"compiling model" => "Kompiliere Modell",
			"compiled_model" => "Modell kompiliert",
			"finished_training" => "Training beendet",
			"stopped_downloading_because_button_was_clicked" => "Download gestoppt, weil der Download-Stoppen-Button geklickt wurde",
			"weight_matrix" => "Gewichtungsmatrix",
			"weight_matrices" => "Gewichtungsmatrizen",
			"kernel_pixel_size" => "Kernel-Pixelgröße",
			"shuffle_data_before_validation_split" => "Daten zufällig sortieren, bevor der Validierungsdatensatz abgespalten wird (empfohlen)?",
			"separator" => "Trennzeichen",
			"auto_adjust_last_layer_neurons" => "Die Anzahl der Neuronen im letzten Layer automatisch anpassen?",
			"auto_one_hot_encoding" => 'Automatisches One-Hot-Encoding (Deaktiviert "teilen durch")?',
			"auto_loss_metric" => "Automatischer Loss/Metrik?",
			"auto_set_last_layer_to_linear" => "Automatisch die Aktivierungsfunktion des letzten Layers auf Linear setzen, wenn die Outputs kleiner 0 oder größer 1 sind?",
			"divide_by" => "Teilen durch",
			"load_custom_function_csv" => "Benutzerdefinierte Funktion (von, bis, Schrittgröße)",
			"loading_the_site_took" => "Das Laden der Seite brauchte",
			"site_was_active" => "Seite war aktiv",
			"site_was_inactive" => "Seite war inaktiv",
			"input_image" => "Eingabedaten",
			"generated_image" => "Generierte Daten",
			"weights" => "Gewichte",
			"bias" => "Bias",
			"activation_function_of_neuron" => "Aktivierungsfunktion eines Neurons/Filters",
			"maximally_activated_explanation" => "Die Visualisierungsmethode für Neuronen verwendet ein Eingangsbild (x), um ein generiertes Bild (x∗) zu erstellen. Dabei werden die Gewichte (W) und der Bias (b) eines Neurons verwendet, um eine Aktivierungsfunktion (f(x;W,b)) auf das Eingangsbild anzuwenden. Diese Aktivierungsfunktion bestimmt, wie stark das Neuron auf bestimmte Merkmale im Bild reagiert. Das Ergebnis wird durch die argmax-Funktion bestimmt, die den Bereich im Bild identifiziert, der die höchste Aktivierung des Neurons auslöst. Dieser Bereich wird dann weiter verfeinert, um das generierte Bild zu optimieren. Der Prozess wird iterativ durchgeführt, indem das Eingangsbild basierend auf den Gradienten der Aktivierungsfunktion angepasst wird, bis das gewünschte Ergebnis erreicht ist.",
			"start" => "Start",
			"end" => "Ende",
			"stepsize" => "Schrittgröße",
			"function_with_explanation" => "Funktion (x und/oder y als Variablenname und JavaScript-Funktionen wie <tt>Math.sin(x)</tt>)",
			"no_header_lines_found" => "Keine Überschriftenzeile gefunden",
			"no_data_lines_found" => "Keine Datenzeilen gefunden",
			"duplicate_header_entries_found" => "Doppelte Überschriften gefunden",
			"remove_data_img_predictions" => "Predictions entfernen",
			"beta1" => "&beta;<sub>1</sub>",
			"beta2" => "&beta;<sub>2</sub>",
			"epsilon" => "&epsilon;",
			"rho" => "&rho;",
			"initial_accumulator_value" => "Initial Accumulator Value",
			"decay" => "Decay",
			"momentum" => "Momentum",
			"no_decimal_points_math_mode" => "Anzahl Nachkommanstellen (0 = kein Limit)",
			"max_nr_vals" => "Maximale Anzahl an Spalten/Zeilen pro Matrix",
			"train_visualization_only_works_for_default_data" => "Die Trainingsvisualisierung funktioniert nur für Standarddaten.",
			"train_visualization_only_works_for_classification_problems" => "Die Trainingsvisualisierung funktioniert nur für Klassifikationsprobleme.",
			"train_visualization_only_works_for_images" => "Die Trainingsvisualisierung funktioniert nur für Bilddaten.",
			"train_visualization_only_works_when_last_layer_is_softmax" => "Die Trainingsvisualisierung funktioniert nur, wenn der letzte Layer die Aktivierungsfunktion SoftMax hat.",
			"setting_width" => "Setze Breite",
			"setting_height" => "Setze Höhe",
			"model_not_given" => "Modell nicht gesetzt",
			"could_not_get_model" => "Konnte Modell nicht holen",
			"privacy_tainted_no_longer_screenshots" => "Die Privatsphäre ist beeinträchtigt. Fehlerberichte werden keine Screenshots mehr enthalten.",
			"stop_downloading_start_training" => "Stoppe den Download und beginne das Training",
			"failed_to_add_layer_type" => "Der Layer-Typ konnte nicht hinzugefügt werden:",
			"the_loaded_model_has_no_layers" => "Das geladene Modell hat keine Layer",
			"old_model_had_no_layers" => "Das alte Modell hatte keine Layer",
			"no_layers_found" => "Keine Layer gefunden",
			"no_model_found" => "Kein Modell gefunden",
			"start" => "Start",
			"log" => "Log",
			"code_and_contact" => "Quellcode und Kontakt",
			"visualization_tab" => "Visualisierung",
			"augmentation" => "Augmentierung",
			"general" => "Allgemein",
			"different_number_layers_gui_model" => "Das geladene Modell und die GUI haben eine unterschiedliche Anzahl an Layern",
			"model" => "Modell",
			"removed_layer" => "Layer entfernt",
			"added_layer" => "Layer hinzugefügt",
			"getting_data" => "Hole Daten",
			"started_training" => "Training gestartet",
			"prediction_done" => "Prediction fertig",
			"inverted_image" => "Bild invertiert",
			"starting_webcam" => "Starte Webcam",
			"stopping_webcam" => "Stoppe Webcam",
			"rotating_image" => "Rotiere bild",
			"webgl_not_supported" => "WebGL wird nicht unterstützt",
			"found_camera" => "Kamera gefunden",
			"webcam_access_denied" => "Webcamzugriff wurde verweigert",
			"x_data_incomplete" => "X-Data ist noch unvollständig",
			"y_data_incomplete" => "Y-Data ist noch unvollständig",
			"took_photo_from_webcam" => "Photo von Webcam aufgenommen",
			"only_one_webcam" => "Nur eine Webcam gefunden, Einteilung in Front- oder Rückkamera nicht möglich",
			"taking_photo_from_webcam" => "Nehme ein einzelnes Bild per Webcam auf",
			"changed_metrics" => "Metrik geändert",
			"using_camera" => "Benutze Kamera",
			"no_webgl_using_cpu" => "Kein WebGL-Support. Benutze CPU-Backend.",
			"setting_epochs_to" => "Setze die Epochenzahl auf",
			"set_labels" => "Setze die Labels",
			"not_changing_labels_they_stayed_the_same" => "Ändere die Labels nicht, sie sind gleich geblieben",
			"saving_current_status" => "Speichere aktuellen Stand",
			"you_cannot_use_gradcam_and_internal_states_together" => "GradCAM und die Datenfluss-Ansicht können nicht gemeinsam benutzt werden.",
			"temporarily_using_expert_mode" => "Aktiviere kurzzeitig den Expertenmodus",
			"predict_data_shape" => "Prediction Daten-Shape",
			"error" => "Fehler",
			"prediction_failed" => "Prediction fehlgeschlagen",
			"done_setting_initializer" => "Initializer-Einstellung gesetzt",
			"setting_initializer" => "Setze Initializer",
			"setting_seed_to" => "Setze Seed auf",
			"done_setting_seed_to" => "Seed gesetzt auf",
			"waiting_for_screenshot" => "Warte auf Screenshot",
			"done_reinitializing" => "Reinitialisierung fertig",
			"starting_reinitializing" => "Starte Reinitialisierung",
			"are_you_sure" => "Bist du sicher?",
			"this_loses_your_training_process_but_you_can_undo_it" => "Der Trainingsfortschritt geht dabei verloren, aber du kannst es rückgängig machen",
			"yes_reinit" => "Ja, Reinitialisieren!",
			"tried_reinit_but_no_model_found" => "Reinitialisierung versucht, aber es wurde kein Modell gefunden",
			"reinit_cancelled" => "Reinitialisierung abgebrochen",
			"checked_possible_layer_types" => "Mögliche Layertypen überprüft",
			"checking_webcams" => "Überprüfe Webcams",
			"flip_left_right" => "Links/rechts gespiegelt",
			"no_model_found_but_has_missing_values" => "Kein Modell gefunden, aber hat fehlende Werte",
			"not_creating_model_because_some_values_are_missing" => "Erstelle kein Modell, da einige Werte fehlen",
			"an_error_occured_setting_weights_check_dev_console" => "Ein Fehler ist beim Einstellen der Gewichte aufgetreten. Überprüfe die Entwicklerkonsole für mehr details",
			"cannot_show_gradcam_while_training" => "Kann GradCAM nicht während des Trainings anzeigen",
			"not_wasting_resources_on_gradcam_when_not_visible" => "Verschwende keine Ressourcen füg GradCAM wenn die Visualisierung nicht sichtbar ist.",
			"cannot_use_gradcam_without_conv_layer" => "GradCAM kann nicht benutzt werden wenn keine Convolutional Layer gesetzt sind",
			"cannot_predict_two_layers_at_the_same_time" => "Kann nicht zwei Layer gleichzeitig predicten. Warte, bis einer fertig ist",
			"inverted_image_that_has_been_turned" => "Invertiere ein Bild das bereits gedreht wurde um",
			"awaiting_finishing_of_training" => "Warte, bis das Training beendet ist",
			"auto_augmenting_images" => "Auto-augmentiere Bilder",
			"somehow_there_were_zero_training_data_consider_it_a_bug" => "Es gab genau 0 Trainignsdaten. Wenn du die Default-Einstellungen genutzt hast, ist das wahrscheinlich ein Bug in asanAI.",
			"generating_data_from_images" => "Generiere Daten aus Bildern",
			"done_generating_data_from_images" => "Das Generieren von Daten aus Bildern wurde beendet",
			"auto_augmentation_currently_not_supported_for_segmentation" => "Auto-Augmentierung für Segmentierungsnetze wird aktuell nicht unterstützt",
			"enough_labels_for_one_hot_encoding" => "Genug Labels für oneHot-Encoding",
			"currently_there_is_a_bug_for_one_hot_encoding_with_only_one_vector_so_its_disabled" => "Aktuell gibt es einen Bug, wenn man One-Hot-Encoding machen will aber nur einen einspalting Vektor hat. Daher wurde One-Hot-Encoding deaktiviert.",
			"using_camera" => "Benutze Kamera",
			"soon_a_photo_series_will_start" => "Gleich startet eine Foto-Serie",
			"first_photo_will_be_taken_in_n_seconds" => "Das erste Bild wird in <b></b> Sekunden aufgenommen.",
			"flip_left_right_that_has_been_turned" => "Spiegel links/rechts bei einem Bild das bereits gedreht wurde um",
			"done_taking_n_images" => "Fertig damit, %d Bilder zu holen",
			"taking_image_n_of_m" => "Hole Bild %d/%d",
			"not_enough_labels_for_one_hot_encoding_got_n_need_at_least_two" => "Nicht genug Labels für oneHot-Encoding (habe %d bekommen, aber brauche mindestens >= 2)",
			"redone_last_undone_change" => "Letzte rückgängig gemachte Änderung wiederhergestellt",
			"undone_last_change" => "Letzte Änderung rückgängig gemacht",
			"generated_encodings" => "Encodings generiert",
			"auto_generating_enables_but_no_labels_given" => "Auto-encoding aktiviert, aber keine Labels gesetzt",
			"changed_metrics" => "Metrik geändert",
			"setting_all_kernel_initializers_to" => "Setze alle Kernel-Initializer auf",
			"setting_all_bias_initializers_to" => "Setze alle Bias-Initializer auf",
			"setting_all_activation_functions_except_last_layer_to" => "Setze alle Aktivierungsfunktionen (außer die im letzten Layer) auf",
			"setting_all_activation_functions_to" => "Setze alle Aktivierungsfunktionen auf",
			"setting_labels_from_config" => "Setze Labels von der Konfiguration",
			"setting_activation_function_of_layer_n_to_linear" => "Setze die Aktivierungsfunktion des Layers %d auf Linear",
			"setting_neurons_or_filters_of_layer_n_to_3" => "Setze die Neuronen/Filter des Layers %d auf 3",
			"error_keras_not_found_in_config" => "Fehler: keras konnte nicht gefunden werden in der Variable config",
			"ok_chosen_dataset" => "OK: Datensatz gewählt",
			"setting_optimizer_to_rmsprop" => "Setze Optimizer auf rmsprop",
			"deleting_layer_for_custom_image" => "Lösche Layer für benutzerdefiniertes Bild",
			"setting_batch_size_to" => "Setze Batchsize auf",
			"initializing_epochs_to" => "Initialisiere Epochen auf",
			"setting_weights_from_config_weights" => "Setze Gewichtungen von den Gewichtungen aus der Konfiguration",
			"error_failed_to_load_model_and_or_weights" => "Fehler beim Laden des Modells oder der Gewichte",
			"error_cannot_load_this_model_file_is_it_json_from_asanai_or_a_graph_model" => "Fehler: Kann diese Modelldatei nicht laden. Stamm sie von asanAI? Ist es vielleiht ein Graph-Modell?",
			"input_size_too_small_restoring_last_known_good_config" => "Die Input-Größe war zu klein. Stelle die letzte bekannte funktionierende Konfiguration wieder her:",
			"waiting_n_seconds" => "Warte für %d Sekunden...",
			"done_waiting_n_seconds" => "Fertig damit, für %d Sekunden zu warten...",
			"model_doesnt_include_layers_cannot_show_in_latex" => "Modell hat keine Layer. Kann nicht in LaTeX gezeigt werden.",
			"unknown_optimizer" => "Unknown optimizer:",
			"optimizer_algorithm" => "Optimizeralgorithmus",
			"given_object_not_a_tensor" => "Gegebenes Objekt ist kein Tensor",
			"tensor_already_disposed_where_it_shouldnt_be" => "Tensor ist bereits disposed wo er es nicht sein sollte.",
			"arr_is_undefined_or_false" => "arr ist undefined oder false",
			"arr_is_not_an_array" => "arr ist kein Array",
			"model_is_not_defined" => "Modell ist nicht definiert",
			"waiting_for_model" => "Warte auf Modell",
			"adding_layer" => "Füge Layer hinzu",
			"trained_nn_n_and_m_results" => "NN trainiert: %d und %d Ergebnisse:",
			"could_not_install_new_callback" => "Konnte neuen Callback nicht installieren",
			"can_only_run_one_test_at_a_time" => "Es kann nur ein Test gleichzeitig ausgeführt werden",
			"unknown_backend" => "Unbekanntes Backend",
			"empty_predictions_tensor_in_predict_webcam" => "Leerer predictions_tensor in predict_webcam",
			"cam_not_defined_existing_webcam" => "cam nicht definiert. Beende die Webcam.",
			"predictions_tensor_not_defined" => "predictions_tensor nicht definiert",
			"the_tensor_about_to_be_predicted_was_empty" => "Der Tensor, der predicted werden sollte, war leer.",
			"model_or_layer_was_already_disposed_not_predicitng" => "Modell oder Layer ist schon disposed. Predicte nicht.",
			"already_predicting_exiting_webcam" => "Predicte bereits. Beende Webcam.",
			"no_model_defined" => "Kein Modell definiert",
			"arr_is_an_array_but_empty" => "arr ist ein Array, aber es ist leer",
			"arr_is_an_array_but_multidimensional_it_needs_to_be_one_dimensional" => "arr ist ein Array, aber es ist mehrdimensional. Es muss eindimensional sein",
			"global_model_data_is_empty" => "global_model_data ist leer!",
			"using_resize_type" => "Benutze Resize-Typ",
			"something_went_wrong_when_trying_to_determine_get_units_at_layer" => "Etwas lief beim Aufruf der Funktion get_units_at_layer schief",
			"there_was_an_error_getting_default_resize_method" => "Es gab ein Problem beim Bestimmen der #default_resize_method",
			"unknown_value" => "Unbekannter Wert",
			"unknown_swal_r" => "Unbekanntes Swal r",
			"new_number_of_output_neurons_is_zero_or_undefined" => "Neue Zahl der Outputneuronen ist 0 oder undefiniert",
			"do_not_change_neurons_while_is_setting_config_is_true" => "Ändere die Anzahl von Neuronen nicht, während is_setting_config true ist",
			"new_number_of_output_neurons_matches_the_number_already_in_the_model" => "Neue Zahl der Outputneuronen ist die gleiche wie die die bereits im Modell geladen ist",
			"cannot_autoset_layer_errors" => "Kann Layer nicht automatisch setzen. Fehler:",
			"batch_dimension_in_output_shape_must_be_null" => "Batch-Dimension in der Output-Shape muss null sein",
			"output_shape_length_must_be_two" => "Die Länge der Output-Shape muss 2 sein",
			"last_layer_must_be_of_type_dense" => "Der letzte Layer muss vom Type Dense sein",
			"last_layer_must_have_softmax_to_autoset_layers" => "Der letzte Layer muss als Aktivierungsfunktion Softmax haben, damit Layer automatisch gesetzt werden können",
			"data_is_undefined" => "Daten sind undefiniert",
			"the_real_output_shape_x_does_not_match_the_expected_output_shape_y" => "Die echte Output-Shape ([%s]) passt nicht zur erwarteten Output-Shape ([%s])",
			"the_number_of_categories_n_doesnt_match_the_number_of_given_canvasses_m" => "Die Anzahl von Kategorien (%d) passt nicht zur Anzahl der gegebenen Canvasse (%d)",
			"initializer_value_failed_should_be_n_is_m" => "Initializer-Wert falsch: Sollte %d sein, ist %d",
			"not_rerunning_run_neural_network" => "Lasse run_neural_network nicht erneut laufen",
			"unknown_reason_for_not_displaying_simple_visualization" => "Unbekannter Grund, warum die Simple Visualization nicht angezeigt werden kann",
			"x_shape_is_wrong_for_simple_visualization" => "X-Shape ist falsch für Simple Visualization",
			"y_shape_is_wrong_for_simple_visualization" => "Y-Shape ist falsch für Simple Visualization",
			"model_shape_is_wrong_for_simple_visualization" => "Modell-Shape ist falsch für Simple Visualization",
			"waiting_for_set_dense_layer_units" => "Warte auf set_dense_layer_units",
			"no_layers" =>  "Keine Layer",
			"could_not_get_xs_and_xy" => "Konnte xs_and_ys nicht holen",
			"no_model_to_compile" => "Kein Modell zum Kompilieren",
			"missing_title" => "Fehlender Titel",
			"start_must_be_a_number" => "Start muss eine Zahl sein",
			"end_must_be_a_number" => "End muss eine Zahl sein",
			"changing_selectedIndex" => "Ändere selectedIndex",
			"changing_val_to" => "Ändere val nach",
			"awaiting_disable_invalid_layers_event" => "Warte auf disable_invalid_layers_event()",
			"currently_waiting_for_n_layer_m_becoming_equal_to_a" => "Warte darauf, dass \"%s\" (Layer %d) gleich wird zu %s",
			"start_waiting_for_x_becoming_equal_to_y" => "Warte darauf, dass \"%s\" gleich %s wird",
			"setting_the_units_of_layer_n_to_m" => "Setze die Units vom Layer %d auf %d",
			"clicking_on_this_item_for_layer_duplication" => "Klicke auf diesen Layer für Layer-Duplikation:",
			"waiting_until_model_layers_length_m_minus_start_layers_n_is_greater_than_zero" => "Warte, bis model.layers.length (%d) - (start_layers) (%d) > 0",
			"webcam_is_hidden_also_fcnn_not_visible_exiting_webcam" => "Webcam ist versteckt, genauso wie, fcnn_canvas. Beende Webcam.",
			"model_has_no_input" => "Modell hat keinen Input",
			"predictions_tensor_was_empty" => "Predictions tensor war leer",
			"model_was_already_disposed" => "Modell ist bereits disposed",
			"cannot_predict_since_the_data_about_to_be_predicted_is_already_disposed" => "Kann nicht predicten, da die Daten die predicted werden sollen bereits disposed sind",
			"cannot_get_model_input_shape" => "Kann model.input.shape nicht holen",
			"predict_data_is_already_disposed" => "predict_data ist bereits disposed",
			"predict_demo_failed_error" => "Predict demo fehlgeschlagen, Fehler:",
			"uploading_custom_images_is_only_supported_for_image_models" => "Das Hochladen von benutzerdefinierten Bildern ist geht nur mit Bildmodellen",
			"error_while_getting_reader_result" => "Fehler beim Holen von reader.result",
			"the_zip_file_you_uploaded_seems_to_be_corrupt_or_partially_uploaded" => "Die Zip-Datei die du hochzuladen versucht hast scheint korrupt zu sein oder nur teilweise hochgeladen werden zu können",
			"it_seems_like_uploading_the_file_has_failed" => "Es sieht so aus als wäre das Hochladen der Datei fehlgeschlagen",
			"no_model" => "Kein Modell",
			"recursion_level_for_compile_model_too_high" => "recursion level für compile_model zu hoch",
			"model_doesnt_include__call_hook" => "Modell beinhaltet kein _callHook",
			"model_get_weights_is_not_a_function" => "model.getWeights ist keine Funktion",
			"wrong_model_but_thats_ok_because_you_are_testing_unusual_function_inputs" => "Falsches Modell, aber das ist Ok, weil du gerade unübliche Funktionsinputs testest",
			"saving_model_failed" => "Das Speichern des Modells ist fehlgeschlagen",
			"model_may_be_defective_and_cannot_be_saved" => "Das Modell ist wahrscheinlich defekt und kann nicht gespeichert werden, der Fehler lautet",
			"parsing_error_in_get_weights_shape" => "Parsingfehler in get_weights_shape",
			"but_ok_because_fake_model" => "aber ist OK, weil es ein fake_model ist",
			"given_model_is_not_a_model" => "Gegebenes Modell ist kein Modell",
			"get_weights_is_not_defined" => "getWeights ist nicht definiert",
			"weights_n_is_disposed" => "weights[%d] ist disposed",
			"error_while_loading_custom_images_zip_file" => "Fehler beim Laden der Benutzerdefinierte Zip-Datei",
			"error_at_executing_show_snow" => "Fehler beim Ausführen von show_snow",
			"loading_time_took_more_than_n_seconds_which_is_too_slow" => "Ladezeit war mehr als %d Sekunden, was viel zu langsam ist!",
			"invalid_layer_nr_max_layer_n_layer_nr_m" => "Falsche Layer-Nummer: max_layer: %d, layer_nr: %d",
			"get_weights_is_not_a_function_model_may_have_been_undefined" => "getWeights ist keine Function. Das Modell war wahrscheinlich undefiniert.",
			"error_in_download" => "Fehler beim Download",
			"e_is_undefined_in_get_weights_as_string_probably_harmless" => "e ist undefiniert in get_weights_as_string. Das kann passieren wenn man das Modell neu baut nachdem es auf Null gesetzt war. In diesem Fall ist es harmlos.",
			"cannot_find_model_using_global_one" => "Kann Modell nicht finden, nutze globales Modell",
			"weights_json_was_not_valid" => "Die weights.json-Datei, die du hochzuladen probiert hast, war kein valides JSON. Nutze nicht die .bin-Datei, sondern die .json-file.",
			"weights_loaded_successfully" => "Gewichte erfolgreich geladen",
			"error_loading_weights" => "Fehler beim Laden der Gewichte",
			"set_weights_from_json_object_json_was_empty" => "set_weights_from_json_object: JSON war leer",
			"could_not_find_input" => "Konnte input nicht finden",
			"idname_is_null_returning" => "idname ist null. Verlasse Funktion.",
			"idname_is_undefined_returning" => "idname ist undefiniert. Verlasse Funktion.",
			"x_and_y_keys_must_have_same_nr_of_values_but_has_m_and_y" => "x und y keys müssen die gleiche Anzahl an Werten haben, aber sie sind unterschiedlich.x hat %d keys und y hat %d keys!",
			"failed_temml" => "Temml fehlgeschlagen:",
			"could_not_get_fcnn_data" => "Konnte FCNN-Daten nicht holen",
			"could_not_retrieve_x_data" => "Konnte x-Daten nicht holen",
			"could_not_retrieve_y_data" => "Konnte y-Daten nicht holen",
			"last_layer_not_dense" => "Der letzte Layer ist nicht Dense",
			"an_error_occured" => "Es ist ein Fehler aufgetreten:",
			"start_and_end_number_are_equal" => "Start- und Endzahl sind identisch",
			"model_layers_is_not_defined_or_empty" => "model.layers ist nicht definiert oder leer",
			"there_was_an_error_compiling_the_model" => "Es gab ein Problem beim Kompilieren des Modells",
			"stepsize_is_not_a_number" => "stepsize ist keine Zahl",
			"stepsize_cannot_be_zero" => "Stepsize darf nicht 0 sein",
			"function_is_too_short" => "Funktion ist zu kurz",
			"end_number_must_be_something_other_than_zero" => "Endzahl muss eine andere Zahl als null sein",
			"start_number_must_be_something_other_than_zero" => "Startzahl muss eine andere Zahl als null sein",
			"function_does_not_include_x" => "Funktion beinhaltet kein x",
			"desc_boxes_and_layers_different_length" => "Die Beschreibungsboxen und die Layerboxen haben eine unterschiedliche Länge",
			"tensor_already_disposed_write_optimizer_to_math_tab" => "Tensor ist bereits disposed im write_optimizer_to_math_tab",
			"download_with_data_disabled_input_shape_doesnt_have_four_elements" => "'Mit Daten Downloaden' deaktiviert, weil die Input-Shape keine 4 Elemente hat, sondern so aussieht",
			"download_with_data_disabled_input_shape_doesnt_have_two_elements" => "'Mit Daten Downloaden' deaktiviert, weil die Input-Shape keine 2 Elemente hat, sondern so aussieht",
			"setting_divide_by_to" => "Setze divide_by nach",
			"setting_max_number_of_files_per_category_to" => "Setze max_number_of_files_per_category nach",
			"example_predict_data_was_empty" => "example_predict_data war leer",
			"no_classes_found" => "Keine Klassen gefunden",
			"download_with_data_disabled_because_the_loss_is_not_categorical_cross_entropy" => "'Download mit Daten' deaktiviert, weil der Loss nicht categoricalCrossentropy ist",
			"download_with_data_disabled_because_not_classification_problem" => "'Download mit Daten' deaktiviert, da das aktuelle Problem kein Klassifizierungsproblem zu sein scheint",
			"download_with_data_disabled_because_no_layers" => "'Download mit Daten' deaktiviert, weil das Modell keine Layer hat",
			"download_with_data_disabled_because_no_model" => "'Download mit Daten' deaktiviert, weil kein Modell definiert ist",
			"stepsize_cannot_be_zero" => "Stepgröße kann nicht null sein",
			"no_content" => "Kein Inhalt",
			"tensor_shape_does_not_match_model_shape_not_predicting_example" => "Tensor-Shape passt nicht zum Modell. Beispiel wird nicht predicted. Input-Shape/Tensor-Shape",
			"value_is_empty" => "Wert ist leer",
			"wrong_input_shape_for_prediction_data_x_model_y" => "Falsche Input-Shape für Prediction. Daten: [%s], Modell: [%s]",
			"no_max_number_of_files_per_category_found_in_config" => "Der Wert max_number_of_files_per_category wurde nicht in der Config gefunden",
			"layers_not_in_model" => "Layers nicht im Modell",
			"img_blob_could_not_be_found" => "Img-Blob konnte nicht gefunden werden!",
			"not_fanavg_nor_fanin" => "weder fanAvg noch FanIn",
			"cannot_determine_type_of_layer" => "Kann Layertyp nicht bestimmen für Layer",
			"xy_data_does_not_contain_x", "xy_data beinhaltet kein x",
			"xy_data_does_not_contain_y", "xy_data beinhaltet kein y",
			"canvas_blob_could_not_be_found" => "Canvas-Blob konnte nicht gefunden werden!"
		)
	);

	function checkSubElementsKeys($array) {
		$keys = [];

		foreach ($array as $subArray) {
			if (!is_array($subArray)) {
				die("Sub-element is not an array");
			}

			$subKeys = array_keys($subArray);

			if (empty($keys)) {
				$keys = $subKeys;
			} elseif ($keys !== $subKeys) {
				$missingKeys = array_diff($keys, $subKeys);
				if($missingKeys) {
					die("Missing key: " . reset($missingKeys));
				}
			}
		}

		return true;
	}

	if(!checkSubElementsKeys($GLOBALS["translations"])) {
		die("Sub-elements do not have the same keys");
	}

	if(isset($_GET["print"])) {
		print json_encode($translations);
	}
?>
