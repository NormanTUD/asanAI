<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate AI Lab v4.4 - No Recursion & Stable Viz</title>
    
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    
    <script>window.MathJax = { tex: { inlineMath: [['$', '$']], displayMath: [['$$', '$$']] } };</script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 20px; background: #f1f5f9; color: #1e293b; }
        .card { background: white; padding: 25px; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); margin-bottom: 30px; border: 1px solid #e2e8f0; width: calc(100% - 50px); }
        
        /* Grid Layouts */
        .grid-layout { display: grid; grid-template-columns: 320px 1fr; gap: 20px; }
        @media (max-width: 1000px) { .grid-layout { grid-template-columns: 1fr; } }
        
        .layers-vertical { background: #f8fafc; padding: 20px; border-radius: 12px; border: 1px solid #cbd5e0; display: flex; flex-direction: column; gap: 15px; }
        .layer-box { background: white; border: 2px solid #3b82f6; border-radius: 8px; padding: 12px; position: relative; }
        .layer-badge { position: absolute; top: -12px; left: 10px; background: #3b82f6; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; }
        
        /* Buttons */
        .btn { cursor: pointer; padding: 10px 16px; border: none; border-radius: 8px; font-weight: 600; transition: 0.3s; margin: 5px 0; }
        .btn-train { background: #2563eb; color: white; width: 100%; }
        .btn-stop { background: #ef4444; color: white; width: 100%; }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }

        /* Console & Outputs */
        .status-console { background: #0f172a; color: #38bdf8; padding: 10px; font-family: 'Courier New', monospace; border-radius: 8px; height: 80px; overflow-y: auto; font-size: 0.8rem; margin-top: 10px; }
        .heatmap-canvas { width: 100px; height: 100px; image-rendering: pixelated; border: 1px solid #94a3b8; margin-bottom: 5px; margin-right: 5px; }
        
        /* Plot Containers */
        .plot-container { width: 100%; min-width: 0; height: 320px; background: white; border: 1px solid #e2e8f0; border-radius: 8px; position: relative; }
        
        /* Tables */
        table { border-collapse: collapse; background: white; font-size: 11px; width: 100%; }
        td, th { border: 1px solid #e2e8f0; padding: 6px; text-align: center; }
        .in-col { background: #dcfce7 !important; }
        .out-col { background: #f3e8ff !important; }
        .res-col { background: #fff7ed !important; font-weight: bold; }
        
        /* Inputs */
        input[type="number"] { width: 50px; padding: 4px; border: 1px solid #cbd5e0; border-radius: 4px; }
        .rgb-input { border: none; width: 40px; text-align: center; color: white; text-shadow: 1px 1px 1px black; font-weight: bold; border-radius: 2px; display: block; margin: 2px auto; }
        .vision-canvas { border: 2px solid #334155; width: 120px; height: 120px; image-rendering: pixelated; }

        /* FCNN Canvas Styles */
        #fcnn_wrapper { width: 100%; overflow-x: auto; background: white; border: 1px solid #e2e8f0; border-radius: 8px; margin-bottom: 15px; text-align: center; padding: 10px; }
        #fcnn_canvas { display: inline-block; max-width: 100%; }
    </style>
</head>
<body>

<script>
    // --- Mocks & Environment f√ºr fcnn.js ---
    
    var is_dark_mode = false;
    var lang = "de";
    var language = { 
        "de": { "input_image": "Eingabe", "could_not_get_fcnn_data": "Keine Daten" },
        "en": { "input_image": "Input", "could_not_get_fcnn_data": "No Data" }
    };
    var layer_states_saved = {}; 
    var restart_fcnn_timeout = null;
    var is_running_test = false;
    var currently_running_change_data_origin = false;
    var is_setting_config = false;
    var model = null; 

    function dbg(msg) { }
    function assert(condition, message) { if (!condition) { console.error("Assertion failed: " + message); } }
    function log_once(msg) { console.log(msg); }
    
    // Helpers
    function get_layer_classname_by_nr(idx) {
        if(!model || !model.layers[idx]) return "Unknown";
        return model.layers[idx].getClassName();
    }
    function get_units_at_layer(idx) {
        if(!model || !model.layers[idx]) return 0;
        return model.layers[idx].units || model.layers[idx].filters || 0; 
    }
    
    // --- FCNN Logic Ohne MD5/Caching ---
    
    async function restart_fcnn(force = 0) {
        const el = $("#fcnn_canvas");
        if(el.length) { 
            if(restart_fcnn_timeout) clearTimeout(restart_fcnn_timeout);
            restart_fcnn_timeout = setTimeout(() => {
                restart_fcnn_internal(force); 
                restart_fcnn_timeout = null;
            }, 100);
        }
    }

    async function restart_fcnn_internal (force = 0) {
        if(is_running_test || currently_running_change_data_origin) { if(!force) return; }
        if(!$("#fcnn_canvas").is(":visible")) return;

        var fcnn_data = get_fcnn_data(); 
        if(!fcnn_data) { return; }

        var [names, units, meta_infos] = fcnn_data;
        // Kein Cache-Check mehr -> direkt zeichnen
        await draw_fcnn(units, names, meta_infos);
        return true;
    }

    function get_fcnn_data () {
        var names = [];
        var units = [];
        var meta_infos = [];

        if(!model || !model.layers) return;
        var nr_layers = model.layers.length;
        if(!nr_layers) return;

        var start_layer = 0;

        for (var layer_idx = 0; layer_idx < nr_layers; layer_idx++) {
            var class_name = get_layer_classname_by_nr(layer_idx);

            if(!["Dense", "Flatten", "LayerNormalization"].includes(class_name) && !(typeof class_name === "string" && class_name.toLowerCase().includes("conv2d"))) {
                continue;
            }

            var _unit = get_units_at_layer(layer_idx);
            
            // Input layer handling
            if(layer_idx === 0 && model.layers[0].input.shape) {
                 let inShape = model.layers[0].input.shape;
                 let inputs = inShape[inShape.length - 1];
                 if(inputs && inputs < 100) { 
                     names.push("Input");
                     units.push(inputs);
                     meta_infos.push({ layer_type: "Input", nr: -1, input_shape: inShape, output_shape: inShape });
                 }
            }

            if(layer_idx == nr_layers - 1) names.push("Output Layer");
            else names.push(`${class_name} ${layer_idx}`);

            units.push(_unit);

            var kernel_size_x = 3, kernel_size_y = 3; // Default
            meta_infos.push({
                layer_type: class_name,
                nr: start_layer + layer_idx,
                input_shape: "",
                output_shape: "",
                kernel_size_x: kernel_size_x,
                kernel_size_y: kernel_size_y
            });
        }

        return [names, units, meta_infos];
    }

    async function draw_fcnn(...args) {
        if(is_setting_config) return;

        var layers = args[0];
        var _labels = args[1];
        var meta_infos = args[2];

        var canvas = document.getElementById("fcnn_canvas");
        if (!canvas) return;

        var ctx = canvas.getContext("2d", { willReadFrequently: true });
        var container = $("#fcnn_wrapper");
        var ghw = container.width() || 800;

        var canvasWidth = Math.max(600, ghw);
        var canvasHeight = 400; 

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        var maxNeurons = Math.max(...layers);
        var maxRadius = Math.min(15, (canvasHeight * 0.8) / maxNeurons / 2, (canvasWidth * 0.8) / (layers.length) / 2);
        var layerSpacing = canvasWidth / (layers.length + 0.5); 
        var startX = layerSpacing / 2;
        var maxSpacing = Math.min(maxRadius * 2.5, (canvasHeight * 0.9) / maxNeurons);

        _draw_custom_simple(ctx, layers, meta_infos, canvasWidth, canvasHeight, maxRadius, maxSpacing);
    }

    function _draw_custom_simple(ctx, layers, meta_infos, w, h, radius, spacing) {
	    const layerCount = layers.length;
	    const xStep = w / (layerCount);
	    const nodePositions = [];

	    // 1. Knoten Positionen berechnen und zeichnen
	    for(let i=0; i<layerCount; i++) {
		    const neuronCount = layers[i];
		    const x = (i * xStep) + (xStep/2);
		    const layerNodes = [];

		    const maxVis = 32;
		    const drawCount = Math.min(neuronCount, maxVis);
		    const totalH = (drawCount-1) * spacing;
		    const startY = (h/2) - (totalH/2);

		    ctx.fillStyle = "#1e293b";
		    ctx.font = "bold 12px Arial";
		    ctx.textAlign = "center";
		    let lType = meta_infos[i] ? meta_infos[i].layer_type : "Layer";
		    if(lType === "Input") ctx.fillText("Input", x, 20);
		    else if(i === layerCount-1) ctx.fillText("Output", x, 20);
		    else ctx.fillText(lType, x, 20);

		    ctx.font = "10px Arial";
		    ctx.fillStyle = "#64748b";
		    ctx.fillText(neuronCount + " units", x, h - 10);

		    for(let j=0; j<drawCount; j++) {
			    const y = startY + (j * spacing);
			    layerNodes.push({x, y});

			    ctx.beginPath();
			    ctx.arc(x, y, radius, 0, 2*Math.PI);
			    ctx.fillStyle = (i===0) ? "#10b981" : (i===layerCount-1) ? "#8b5cf6" : "#3b82f6";
			    ctx.fill();
			    ctx.strokeStyle = "#000000"; // Schwarze Umrandung der Knoten
			    ctx.lineWidth = 1;
			    ctx.stroke();
		    }
		    nodePositions.push(layerNodes);
	    }

	    // 2. Verbindungen in Schwarz zeichnen
	    ctx.globalCompositeOperation = 'destination-over';
	    for(let i=0; i<nodePositions.length-1; i++) {
		    const curr = nodePositions[i];
		    const next = nodePositions[i+1];

		    ctx.strokeStyle = "#000000"; // Schwarze Linien

		    // Dynamische Transparenz f√ºr bessere √úbersicht
		    if(curr.length * next.length > 1000) ctx.globalAlpha = 0.1;
		    else ctx.globalAlpha = 0.4;

		    ctx.lineWidth = 0.8;

		    for(let c of curr) {
			    for(let n of next) {
				    ctx.beginPath();
				    ctx.moveTo(c.x, c.y);
				    ctx.lineTo(n.x, n.y);
				    ctx.stroke();
			    }
		    }
	    }
	    ctx.globalAlpha = 1.0;
    }
</script>
<div class="card">
    <h2>0. Minimales Neuron Lab</h2>
    <div class="grid-layout">
        <div class="layers-vertical">
            <div class="layer-box" style="border-color:#10b981"><span class="layer-badge">INPUT</span>1 Node (x)</div>
            <div class="layer-box" style="border-color:#8b5cf6"><span class="layer-badge">OUTPUT</span>1 Node (y)</div>
            LR: <input type="number" id="lin-lr" value="0.1" step="0.01">
            Epochs: <input type="number" id="lin-epochs" value="100">
        </div>
        <div>
            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                <div id="lin-loss-chart" class="plot-container"></div>
                <div id="lin-data-chart" class="plot-container"></div>
            </div>
            <div id="lin-math-monitor" style="padding:15px; margin-top:10px;"></div>
            <button id="btn-lin-train" class="btn btn-train" onclick="toggleTraining('lin')">üöÄ Training Starten</button>
            <button class="btn" style="background:#64748b; color:white; width:100%" onclick="initBlock('lin')">üîÑ Reset Modell</button>
            <div id="lin-console" class="status-console"></div>
        </div>
    </div>
</div>

<div class="card">
    <h3>1. Statistik: Normalverteilung</h3>
    <div style="text-align: center; margin-bottom: 10px; font-size: 1.1rem;">
        $$ f(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^2} $$
    </div>
    <div id="gauss-chart" style="height:250px; width:100%;"></div>
</div>

<div class="card" id="vision-lab">
	<div class="md">
## 2. Vision Lab
Dieses Modul zeigt, wie **Convolutional Neural Networks** Kanten erkennen.
* **Sharpen:** Hebt Kontraste hervor.
* **Blur:** Gl√§ttet das Bild.

> **Hinweis:** Bewege die Maus √ºber das Quellbild, um die Matrix-Multiplikation live zu sehen.
	</div>
    <h2>2. Vision Lab (Convolution & Matrix)</h2>
    <div style="margin-bottom: 15px; display: flex; gap: 8px; flex-wrap: wrap;">
        <button class="btn" onclick="setKernel([[0,-1,0],[-1,5,-1],[0,-1,0]])">Sharpen</button>
        <button class="btn" onclick="setKernel([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]])">Blur</button>
        <button class="btn" onclick="setKernel([[-1,-1,-1],[-1,8,-1],[-1,-1,-1]])">Edge</button>
        <button class="btn" onclick="setKernel([[0,0,0],[0,1,0],[0,0,0]])">Identity</button>
    </div>
    
    <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: flex-start;">
        <div style="position: relative; line-height: 0; display: inline-block;">
            <b style="line-height: 1.5; display: block;">Original (Hover me!)</b>
            <canvas id="conv-src-display" class="vision-canvas" width="50" height="50" style="cursor: none; border: 1px solid #ccc;"></canvas>
            <div id="conv-focus" style="position: absolute; border: 2px solid red; pointer-events: none; display: none; box-sizing: border-box; z-index: 10;"></div>
        </div>
        
        <div>
            <b>Filter Kernel</b><br>
            Gr√∂√üe: <input type="number" id="k-size" value="3" min="1" max="5" step="2" onchange="initVisionLab()">
            <table id="kernel-table" style="margin-top: 10px; border-collapse: collapse;"></table>
        </div>

        <div id="conv-res-container" style="position: relative; line-height: 0; display: inline-block;">
            <b style="line-height: 1.5; display: block;">Filtered Result</b>
            <canvas id="conv-res" class="vision-canvas" width="50" height="50" style="border: 1px solid #ccc;"></canvas>
            <div id="conv-crosshair" style="position: absolute; pointer-events: none; display: none; z-index: 10;">
                <div style="position: absolute; width: 10px; height: 2px; background: red; left: -5px; top: -1px;"></div>
                <div style="position: absolute; width: 2px; height: 10px; background: red; left: -1px; top: -5px;"></div>
            </div>
        </div>
    </div>

    <div id="conv-math-step" style="margin-top: 20px; padding: 15px; background: #f8fafc; border: 1px solid #cbd5e0; border-radius: 8px; font-size: 0.85rem; overflow-x: auto; min-height: 100px;">
        Bewege die Maus √ºber das Bild...
    </div>
    
    <img id="conv-src-hidden" src="https://picsum.photos/id/20/50/50" crossorigin="anonymous" style="display:none">
</div>

<div class="card">
    <h2>3. Deep Learning Lab</h2>
    <div style="margin-bottom: 15px; display: flex; gap: 10px;">
        <button class="btn" onclick="loadPreset('AND')">AND</button>
        <button class="btn" onclick="loadPreset('XOR')">XOR</button>
        LR: <input type="number" id="deep-lr" value="0.05" step="0.01">
        Epochs: <input type="number" id="deep-epochs" value="100">
    </div>
    <div class="grid-layout">
        <div id="deep-gui" class="layers-vertical"></div>
        <div>
            <div id="fcnn_wrapper">
                <canvas id="fcnn_canvas"></canvas>
            </div>

            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                <div id="deep-loss-chart" class="plot-container"></div>
                <div id="deep-data-chart" class="plot-container"></div>
            </div>
            
            <div style="margin-top: 10px;">
                <b>Weights (Live):</b>
                <div id="deep-tensor-viz" style="display:flex; gap:5px; flex-wrap: wrap;"></div>
            </div>

            <div id="deep-math-monitor" style="padding:15px; margin-top:10px;"></div>
            <table id="deep-train-table">
                <thead><tr id="deep-thr"></tr></thead>
                <tbody></tbody>
            </table>
            <button class="btn" style="background:#10b981; color:white; width:100%" onclick="addRow('deep')">+ Neue Datenzeile</button>
            
            <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-top:10px;">
                <strong>üîç Freie Vorhersage:</strong>
                <div id="manual-input-area" style="display:inline-block; margin: 0 10px;"></div>
                <span>‚Üí <strong id="manual-result" style="color:#b45309">0.00</strong></span>
            </div>

            <button id="btn-deep-train" class="btn btn-train" onclick="toggleTraining('deep')">üöÄ Training Starten</button>
            <button class="btn" style="background:#64748b; color:white; width:100%" onclick="initBlock('deep')">üîÑ Reset Modell</button>
            <div id="deep-console" class="status-console"></div>
        </div>
    </div>
</div>

<script>
    const configs = {
        lin: { inputs: ["x"], outputs: ["y"], layers: [], data: [[1,2],[2,4],[3,6]], model: null, loss: [], isTraining: false, totalEpochs: 0 },
        deep: { inputs: ["In 1", "In 2"], outputs: ["Out"], layers: [{nodes: 4, act: 'relu'}], data: [[0,0,0],[0,1,1],[1,0,1],[1,1,0]], model: null, loss: [], isTraining: false, totalEpochs: 0 }
    };

    function log(id, msg) {
        const con = document.getElementById(id + '-console');
        const time = new Date().toLocaleTimeString().split(' ')[0];
        con.innerHTML = `[${time}] ${msg}<br>` + con.innerHTML;
    }

    function initBlock(id, resetLoss=true) {
        const c = configs[id];
        log(id, `Initialisiere Modell (Reset: ${resetLoss})...`);
        if(resetLoss) { 
            c.loss = []; c.totalEpochs = 0; 
            const btn = document.getElementById(`btn-${id}-train`);
            if(btn) btn.innerText = "üöÄ Training Starten";
        }
        if(c.model) c.model.dispose();
        
        c.model = tf.sequential();
        if(c.layers.length > 0) {
            c.layers.forEach((l, i) => {
                c.model.add(tf.layers.dense({ units: parseInt(l.nodes), activation: l.act, inputShape: i === 0 ? [c.inputs.length] : undefined }));
            });
            c.model.add(tf.layers.dense({ units: c.outputs.length, activation: id==='lin'?null:'sigmoid' }));
        } else {
            c.model.add(tf.layers.dense({ units: c.outputs.length, inputShape: [c.inputs.length], activation: id==='lin'?null:'sigmoid' }));
        }
        
        c.model.compile({ optimizer: tf.train.adam(parseFloat(document.getElementById(id+'-lr').value)), loss: 'meanSquaredError' });
        
        if(id === 'deep') {
            window.model = c.model;
            // Clean up old weight canvases on reset
            document.getElementById('deep-tensor-viz').innerHTML = '';
            setTimeout(() => { if(typeof restart_fcnn === 'function') restart_fcnn(1); }, 100);
        }

        renderUI(id);
        updateVisuals(id);
        log(id, `Modell bereit.`);
    }

    function addDeepLayer() {
        configs.deep.layers.push({nodes: 4, act: 'relu'}); 
        initBlock('deep', false); 
    }

    function removeDeepLayer(index) {
        configs.deep.layers.splice(index, 1); 
        initBlock('deep', false);
    }

    function renderUI(id) {
        const c = configs[id];
        if(id === 'deep') {
            const gui = document.getElementById('deep-gui');
            gui.innerHTML = "";
            
            // Input Layer
            const dIn = document.createElement('div'); dIn.className="layer-box"; dIn.style.borderColor="#10b981";
            dIn.innerHTML = `<span class="layer-badge">INPUT</span>${c.inputs.length} Nodes`;
            gui.appendChild(dIn);

            // Hidden Layers
            c.layers.forEach((l, i) => {
                const div = document.createElement('div'); div.className="layer-box";
                div.innerHTML = `<span class="layer-badge">HIDDEN ${i+1}</span>
                    Nodes: <input type="number" value="${l.nodes}" onchange="configs.deep.layers[${i}].nodes=parseInt(this.value); initBlock('deep', false)">
                    <select onchange="configs.deep.layers[${i}].act=this.value; initBlock('deep', false)">
                        <option value="relu" ${l.act==='relu'?'selected':''}>ReLU</option>
                        <option value="tanh" ${l.act==='tanh'?'selected':''}>Tanh</option>
                    </select>
                    <button onclick="removeDeepLayer(${i})" style="color:red; border:none; background:none; cursor:pointer; float:right;">‚úñ</button>`;
                gui.appendChild(div);
            });
            
            // Button Add
            const btnAdd = document.createElement('button'); 
            btnAdd.className="btn"; 
            btnAdd.innerText="+ Schicht hinzuf√ºgen";
            btnAdd.onclick = addDeepLayer;
            gui.appendChild(btnAdd);
            
            // Output Layer
            const dOut = document.createElement('div'); dOut.className="layer-box"; dOut.style.borderColor="#8b5cf6";
            dOut.innerHTML = `<span class="layer-badge">OUTPUT</span>1 Node`;
            gui.appendChild(dOut);
            
            document.getElementById('deep-thr').innerHTML = c.inputs.map(h => `<th class="in-col">${h}</th>`).join('') + `<th class="out-col">Soll</th><th class="res-col">Ist</th>`;
            updateTableRows(id);

            const area = document.getElementById('manual-input-area'); area.innerHTML = "";
            c.inputs.forEach(() => {
                const inp = document.createElement('input'); inp.type="number"; inp.value="0"; inp.className="manual-val"; inp.step="0.1";
                inp.oninput = runManualPred; area.appendChild(inp);
            });
        }
    }

    function updateTableRows(id) {
        const tbody = document.querySelector(`#${id}-train-table tbody`);
        if(!tbody) return;
        tbody.innerHTML = "";
        configs[id].data.forEach((row, ri) => {
            const tr = tbody.insertRow();
            row.forEach((v, ci) => {
                const td = tr.insertCell();
                const inp = document.createElement('input');
                inp.type = "number"; inp.value = v; inp.step = "0.1";
                inp.oninput = (e) => { configs[id].data[ri][ci] = parseFloat(e.target.value) || 0; livePredict(id); };
                td.appendChild(inp);
            });
            tr.insertCell().id = `res-${id}-${ri}`; tr.cells[tr.cells.length-1].className = "res-col";
        });
        livePredict(id);
    }

    function livePredict(id) {
        if(id !== 'deep') return;
        configs[id].data.forEach((row, ri) => {
            const el = document.getElementById(`res-${id}-${ri}`);
            if(!el) return;
            tf.tidy(() => {
                const p = configs[id].model.predict(tf.tensor2d([row.slice(0, configs[id].inputs.length)])).dataSync();
                el.innerText = p[0].toFixed(3);
            });
        });
        runManualPred();
    }

    function runManualPred() {
        const inps = document.querySelectorAll('.manual-val');
        if(!inps.length) return;
        const vals = Array.from(inps).map(i => parseFloat(i.value) || 0);
        tf.tidy(() => {
            const p = configs.deep.model.predict(tf.tensor2d([vals])).dataSync();
            document.getElementById('manual-result').innerText = p[0].toFixed(4);
        });
    }

    async function toggleTraining(id) {
        const c = configs[id];
        if(c.isTraining) { 
            c.isTraining = false; 
            log(id, "Training pausiert.");
            return; 
        }
        
        c.isTraining = true;
        const btn = document.getElementById(`btn-${id}-train`);
        btn.className = "btn btn-stop"; btn.innerText = "üõë Stoppen";
        log(id, "Training l√§uft...");

        const xs = tf.tensor2d(c.data.map(r => r.slice(0, c.inputs.length)));
        const ys = tf.tensor2d(c.data.map(r => r.slice(c.inputs.length)));

        const epochs = parseInt(document.getElementById(id+'-epochs').value);
        
        for(let i=0; i<epochs && c.isTraining; i++) {
            const h = await c.model.fit(xs, ys, { epochs: 1, verbose: 0 });
            c.loss.push(h.history.loss[0]);
            c.totalEpochs++;
            if(i % 5 === 0 || i === epochs-1) {
                updateVisuals(id); livePredict(id);
                document.getElementById(id+'-console').firstChild.textContent = `[Epoch ${c.totalEpochs}] Loss: ${h.history.loss[0].toFixed(6)}`;
            }
            await tf.nextFrame();
        }
        
        c.isTraining = false; 
        btn.className = "btn btn-train"; 
        btn.innerText = "üöÄ Training Fortsetzen"; 
        xs.dispose(); ys.dispose();
        log(id, "Training Zyklus beendet.");
    }


    function updateVisuals(id) {
	    const c = configs[id];

	    const layout = { 
		    margin: {t:30, b:30, l:40, r:10}, 
		    title: 'Gesamte Loss History', 
		    xaxis: {
			    title: 'Epoche', 
			    autorange: true // Erm√∂glicht das Mitwachsen der Achse
		    }, 
		    yaxis: {
			    title: 'Loss', 
			    autorange: true,
			    type: 'log' 
		    },
		    autosize: true,
		    // FIX: Wir nutzen die L√§nge der Loss-Daten als Revision. 
		    // Das zwingt Plotly dazu, die Achsen bei neuen Datenpunkten neu zu validieren.
		    uirevision: c.loss.length.toString() 
	    };

	    const config = { responsive: true }; 
	    const epochsX = c.loss.map((_, index) => index);

	    Plotly.react(id+'-loss-chart', [{ 
		    x: epochsX,
		    y: c.loss, 
		    type: 'scatter', 
		    line: {color: '#ef4444', width: 2}, 
		    name: 'MSE' 
	    }], layout, config);

	    // --- Der Rest bleibt identisch ---
	    if(id === 'deep') {
		    const vizContainer = document.getElementById('deep-tensor-viz');
		    let canvasIndex = 0;
		    c.model.layers.forEach((l) => {
			    if(l.getWeights().length > 0) {
				    let cvs = document.getElementById(`weight-cvs-${canvasIndex}`);
				    if(!cvs) {
					    cvs = document.createElement('canvas');
					    cvs.id = `weight-cvs-${canvasIndex}`;
					    cvs.className = "heatmap-canvas";
					    vizContainer.appendChild(cvs);
				    }
				    tf.tidy(() => {
					    const w = l.getWeights()[0];
					    const norm = w.reshape([w.shape[0], w.shape[1]||1]).sub(w.min()).div(w.max().sub(w.min()).add(0.001)).mul(255).cast('int32');
					    tf.browser.toPixels(norm, cvs);
				    });
				    canvasIndex++;
			    }
		    });
		    while(document.getElementById(`weight-cvs-${canvasIndex}`)) {
			    document.getElementById(`weight-cvs-${canvasIndex}`).remove();
			    canvasIndex++;
		    }
		    plotDeepData();
	    }

	    const mon = document.getElementById(id+'-math-monitor');
	    let h = "";
	    c.model.layers.forEach((l, idx) => {
		    const w = l.getWeights(); if(!w.length) return;
		    const W = w[0].arraySync(), B = w[1].arraySync();
		    const texW = "\\begin{pmatrix} " + (Array.isArray(W[0]) ? W.map(r => r.map(v=>v.toFixed(2)).join(" & ")).join(" \\\\ ") : W.map(v=>v.toFixed(2)).join(" & ")) + " \\end{pmatrix}";
		    const texB = "\\begin{pmatrix} " + B.map(v => v.toFixed(2)).join(" \\\\ ") + " \\end{pmatrix}";
		    h += `<div>$ y_{${idx+1}} = \\sigma ( ${texW}^T \\cdot x_{${idx}} + ${texB} ) $</div>`;
	    });
	    mon.innerHTML = h; MathJax.typesetPromise([mon]);
	    if(id==='lin') plotLinData();
    }

    function plotLinData() {
        const c = configs.lin;
        const x = c.data.map(r => r[0]), y = c.data.map(r => r[1]);
        const tx = []; for(let i=0; i<=6; i+=0.5) tx.push(i);
        const py = c.model.predict(tf.tensor2d(tx, [tx.length, 1])).dataSync();
        Plotly.react('lin-data-chart', [{x,y,mode:'markers',name:'Data'}, {x:tx,y:Array.from(py),mode:'lines',name:'Pred'}], {margin:{t:30,b:30,l:30,r:10}, title: 'Regression', autosize:true}, {responsive:true});
    }

    function plotDeepData() {
        const c = configs.deep;
        if(c.inputs.length !== 2) {
             document.getElementById('deep-data-chart').innerHTML = "<br><center>Visualisierung nur f√ºr 2 Inputs verf√ºgbar</center>";
             return;
        }

        const x1 = c.data.map(r => r[0]);
        const x2 = c.data.map(r => r[1]);
        const y_true = c.data.map(r => r[2]);
        
        const gridX = [], gridY = [], gridZ = [];
        const steps = 20;
        for(let i=0; i<=steps; i++) {
            for(let j=0; j<=steps; j++) {
                gridX.push(i/steps * 1.2 - 0.1);
                gridY.push(j/steps * 1.2 - 0.1);
            }
        }
        
        tf.tidy(() => {
            const inputs = tf.tensor2d(gridX.map((v,i) => [v, gridY[i]]));
            const preds = c.model.predict(inputs).dataSync();
            
            const traceContour = {
                x: gridX, y: gridY, z: Array.from(preds),
                type: 'contour', showscale: false, opacity: 0.4,
                colorscale: 'RdBu', contours: { start: 0, end: 1, size: 0.1 }
            };
            
            const traceData = {
                x: x1, y: x2, mode: 'markers+text',
                text: y_true, textposition: 'top center',
                marker: { size: 12, color: y_true, colorscale: [[0, 'red'], [1, 'blue']], line: {color: 'black', width: 2} }
            };

            Plotly.react('deep-data-chart', [traceContour, traceData], {
                margin:{t:30,b:30,l:30,r:10}, 
                title: 'Decision Boundary',
                xaxis: {range: [-0.1, 1.1]}, yaxis: {range: [-0.1, 1.1]},
                autosize: true
            }, {responsive: true});
        });
    }

    





function initVisionLab() {
    const size = parseInt(document.getElementById('k-size').value) || 3;
    const kt = document.getElementById('kernel-table'); 
    kt.innerHTML = "";
    
    for(let i=0; i<size; i++) {
        let tr = kt.insertRow();
        for(let j=0; j<size; j++) {
            let td = tr.insertCell();
            let inp = document.createElement('input'); 
            inp.type="number"; inp.className="k-inp"; inp.style.width="40px";
            inp.value = (i === Math.floor(size/2) && j === Math.floor(size/2)) ? 1 : 0; 
            inp.oninput = runConv; 
            td.appendChild(inp);
        }
    }
    
    const img = document.getElementById('conv-src-hidden');
    const srcCanvas = document.getElementById('conv-src-display');
    const focus = document.getElementById('conv-focus');
    const cross = document.getElementById('conv-crosshair');
    const resCanvas = document.getElementById('conv-res');

    const setupCanvas = () => {
        const ctx = srcCanvas.getContext('2d', {willReadFrequently: true});
        ctx.drawImage(img, 0, 0, 50, 50);
        setTimeout(runConv, 100); 
    };

    if(img.complete) setupCanvas(); else img.onload = setupCanvas;

    srcCanvas.onmousemove = (e) => {
        const rect = srcCanvas.getBoundingClientRect();
        const scale = rect.width / 50; 
        
        const x = Math.floor((e.clientX - rect.left) / scale);
        const y = Math.floor((e.clientY - rect.top) / scale);
        const offset = Math.floor(size/2);
        
        // 1. Fokus-Viereck auf dem Original
        focus.style.display = 'block';
        focus.style.width = (size * scale) + "px";
        focus.style.height = (size * scale) + "px";
        focus.style.left = ((x - offset) * scale) + "px";
        focus.style.top = (srcCanvas.offsetTop + (y - offset) * scale) + "px";
        
        // 2. Rotes Kreuz auf dem Output (Projektionsstelle)
        cross.style.display = 'block';
        cross.style.left = (x * scale + scale/2) + "px";
        cross.style.top = (resCanvas.offsetTop + y * scale + scale/2) + "px";
        
        updateConvMath(x, y, size);
    };

    srcCanvas.onmouseleave = () => {
        focus.style.display = 'none';
        cross.style.display = 'none';
    };
}

async function runConv() {
    const resCanvas = document.getElementById('conv-res');
    const srcCanvas = document.getElementById('conv-src-display');
    if (!srcCanvas || srcCanvas.width === 0) return;

    const size = parseInt(document.getElementById('k-size').value) || 3;
    const kValues = Array.from(document.querySelectorAll('.k-inp')).map(i => parseFloat(i.value) || 0);
    
    try {
        tf.tidy(() => {
            const t = tf.browser.fromPixels(srcCanvas).toFloat();
            const ker = tf.tensor2d(kValues, [size, size]).reverse(0).reverse(1).expandDims(-1).expandDims(-1);
            
            const channels = tf.split(t, 3, 2);
            const processed = channels.map(ch => 
                tf.conv2d(ch.expandDims(0), ker, 1, 'same').squeeze()
            );
            
            const combined = tf.stack(processed, 2).clipByValue(0, 255).cast('int32');
            tf.browser.toPixels(combined, resCanvas);
        });
    } catch (err) {
        console.warn("TFJS noch nicht bereit:", err);
    }
}

function updateConvMath(x, y, size) {
    const srcCanvas = document.getElementById('conv-src-display');
    const ctx = srcCanvas.getContext('2d', {willReadFrequently: true});
    const kValues = Array.from(document.querySelectorAll('.k-inp')).map(i => parseFloat(i.value) || 0);
    const offset = Math.floor(size/2);
    
    // Pixeldaten an der Mausposition holen
    const imgData = ctx.getImageData(x - offset, y - offset, size, size).data;
    const targetDiv = document.getElementById('conv-math-step');
    
    let sum = 0;
    let latexParts = [];
    
    for(let i = 0; i < kValues.length; i++) {
        const px = imgData[i * 4]; // R-Kanal (Graustufen-Repr√§sentation)
        const weight = kValues[i];
        sum += px * weight;
        // LaTeX Formatierung: Pixelwert mal Gewicht
        latexParts.push(`${px} \\cdot ${weight.toFixed(1)}`);
    }
    
    // Die komplette Formel zusammenbauen
    const formula = `y_{res} = ` + latexParts.join(" + ") + ` = ${Math.round(sum)}`;
    
    // Den Text als LaTeX in das Div schreiben
    targetDiv.innerHTML = `$$ ${formula} $$`;
    
    // WICHTIG: MathJax mitteilen, dass es dieses spezifische Div neu rendern soll
    if (window.MathJax && window.MathJax.typesetPromise) {
        MathJax.typesetPromise([targetDiv]).catch((err) => console.log(err.message));
    }
}

function setKernel(matrix) {
    document.getElementById('k-size').value = matrix.length;
    initVisionLab();
    const inps = document.querySelectorAll('.k-inp');
    matrix.flat().forEach((val, i) => { if(inps[i]) inps[i].value = val; });
    runConv();
}


    function updateRGB() {
        const cv = document.getElementById('rgb-res'), ctx = cv.getContext('2d');
        const inps = Array.from(document.querySelectorAll('.rgb-input')).map(i=>parseInt(i.value)||0);
        const img = ctx.createImageData(2,2);
        for(let i=0; i<4; i++) { img.data[i*4]=inps[i*3]; img.data[i*4+1]=inps[i*3+1]; img.data[i*4+2]=inps[i*3+2]; img.data[i*4+3]=255; }
        ctx.putImageData(img,0,0);
    }

    

    function loadPreset(n) {
        if(n==='AND') configs.deep = {...configs.deep, layers:[{nodes:2,act:'relu'}], data:[[0,0,0],[0,1,0],[1,0,0],[1,1,1]]};
        if(n==='XOR') configs.deep = {...configs.deep, layers:[{nodes:4,act:'relu'}], data:[[0,0,0],[0,1,1],[1,0,1],[1,1,0]]};
        initBlock('deep');
    }
    
    function addRow(id) { 
        configs[id].data.push(new Array(configs[id].inputs.length + 1).fill(0)); 
        updateTableRows(id); 
    }

    window.onresize = () => {
        ['lin-loss-chart', 'lin-data-chart', 'gauss-chart', 'deep-loss-chart', 'deep-data-chart'].forEach(id => {
            const el = document.getElementById(id);
            if(el) Plotly.Plots.resize(el);
        });
        if(typeof restart_fcnn === 'function') restart_fcnn(1);
    };

    window.onload = () => {
        initBlock('lin'); initBlock('deep'); initVisionLab();
        
        const x=[], y=[]; for(let i=-4; i<=4; i+=0.1) { x.push(i); y.push(Math.exp(-0.5*i*i)/Math.sqrt(2*Math.PI)); }
        Plotly.newPlot('gauss-chart', [{x,y,fill:'tozeroy', line:{color:'#3b82f6'}}], {
            margin:{t:30,b:30,l:40,r:10}, 
            title: 'Standardnormalverteilung',
            autosize: true
        }, {responsive: true});
    };

	   function renderMarkdown() {
	   document.querySelectorAll('.md').forEach(container => {
		   // Den rohen Text holen, dabei Einr√ºckungen (Trimming) entfernen
		   const rawContent = container.innerHTML.replace(/^[ \t]+/gm, '');
		   container.innerHTML = marked.parse(rawContent);
	   });
	   }

    // In dein window.onload integrieren:
    const oldOnload = window.onload;
    window.onload = () => {
	    if(oldOnload) oldOnload();
	    renderMarkdown();
	    // Wichtig: MathJax erneut triggern, falls Formeln im Markdown waren
	    if (window.MathJax) MathJax.typeset();
    };
</script>
</body>
</html>
