<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>TFJS Loss-Landscape und Optimizer-Trajektorien</title>
    
    <script src="tf/tf.min.js"></script> 
    
    <script src="libs/plotly-latest.min.js"></script>
    
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; }
        .controls { margin: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 8px; }
        .plot-container { display: flex; flex-wrap: wrap; justify-content: center; width: 95%; }
        .plot-div { width: 450px; height: 450px; margin: 10px; border: 1px solid #eee; }
        label { display: block; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>TFJS Loss-Landscape & Optimizer-Trajektorien</h1>

    <div class="controls">
        <label for="steps">Schritte für Loss-Landscape-Berechnung (n):</label>
        <input type="number" id="steps" value="10" min="1" max="50">

        <label for="resolution">Auflösung (m) - je m Schritte messen:</label>
        <input type="number" id="resolution" value="10" min="1" max="50">

        <label for="epochs">Epochen für Training:</label>
        <input type="number" id="epochs" value="50" min="1" max="1000">

        <button onclick="startExperiment()">Experiment starten</button>
    </div>

    <div id="status">Bereit. Bitte starten Sie das Experiment.</div>

    <div class="plot-container" id="plot-container">
        </div>

<script>
    // ***********************************************
    // ... (Abschnitte I, II, III, IV bleiben unverändert, da die Logik für Loss-Berechnung und Training korrekt ist)
    // ***********************************************
// I. Globale Konfiguration & Daten
const BASE_SEED = 42; 
const LEARNING_RATE = 0.01;

const OPTIMIZERS = {
    'SGD': () => tf.train.sgd(LEARNING_RATE),
    'Momentum': () => tf.train.momentum(LEARNING_RATE, 0.9),
    'Adagrad': () => tf.train.adagrad(LEARNING_RATE),
    'Adadelta': () => tf.train.adadelta(LEARNING_RATE),
    'Adam': () => tf.train.adam(LEARNING_RATE),
    'Adamax': () => tf.train.adamax(LEARNING_RATE),
    'RMSProp': () => tf.train.rmsprop(LEARNING_RATE),
};

// Einfache lineare Daten: y = 2x + 1.0 
const dataConfig = {
    inputShape: [1],
    outputShape: [1],
    data: [
        { x: 0, y: 1.0 },
        { x: 1, y: 3.0 },
        { x: 2, y: 5.0 },
        { x: 3, y: 7.0 },
        { x: 4, y: 9.0 },
    ]
};

const xs = tf.tensor2d(dataConfig.data.map(d => [d.x]));
const ys = tf.tensor2d(dataConfig.data.map(d => [d.y]));
const N_DATA_POINTS = dataConfig.data.length;

// II. Modell & Loss-Berechnung
function createSimpleModel() {
    const model = tf.sequential();
    model.add(tf.layers.dense({
        units: 1,
        inputShape: dataConfig.inputShape,
        kernelInitializer: tf.initializers.constant({ value: 0.1 }),
        biasInitializer: tf.initializers.constant({ value: -0.1 }),
    }));
    
    return model;
}

function calculateLoss(w, b) {
    return tf.tidy(() => {
        const weights = tf.tensor2d([[w]]);
        const bias = tf.tensor1d([b]);

        const tempModel = createSimpleModel();
        tempModel.layers[0].setWeights([weights, bias]);
        
        tempModel.compile({ 
            optimizer: 'sgd', 
            loss: 'meanSquaredError' 
        });

        const lossTensor = tempModel.evaluate(xs, ys, { batchSize: N_DATA_POINTS });
        
        const loss = lossTensor.dataSync()[0];

        weights.dispose();
        bias.dispose();
        tempModel.dispose(); 

        return loss;
    });
}

// III. Loss-Landscape Berechnung
function computeLossLandscape(startW, startB, n, m) {
    const W_RANGE = Array.from({ length: 2 * n + 1 }, (_, i) => startW - n + i);
    const B_RANGE = Array.from({ length: 2 * n + 1 }, (_, i) => startB - n + i);
    
    const W_PLOT = W_RANGE.filter((_, i) => i % m === 0);
    const B_PLOT = B_RANGE.filter((_, i) => i % m === 0);

    const L_PLOT = new Array(B_PLOT.length).fill(0).map(() => new Array(W_PLOT.length).fill(0));
    
    let totalPoints = W_PLOT.length * B_PLOT.length;
    let currentPoint = 0;
    document.getElementById('status').innerText = `Berechne Loss-Landschaft (${totalPoints} Punkte)...`;

    for (let i = 0; i < B_PLOT.length; i++) {
        for (let j = 0; j < W_PLOT.length; j++) {
            const w = W_PLOT[j];
            const b = B_PLOT[i];
            L_PLOT[i][j] = calculateLoss(w, b);
            currentPoint++;
            document.getElementById('status').innerText = `Berechne Loss-Landschaft: ${Math.floor((currentPoint / totalPoints) * 100)}%`;
        }
    }

    return { W: W_PLOT, B: B_PLOT, L: L_PLOT };
}

// IV. Training und Trajektorie
async function trainAndRecordTrajectory(name, optimizer, epochs, initialW, initialB) {
    const model = createSimpleModel();
    model.compile({ optimizer: optimizer, loss: 'meanSquaredError' });

    const trajectory = { W: [], B: [], Loss: [] };

    const callback = {
        onBatchEnd: (batch, logs) => {
            const layer = model.layers[0];
            const weights = layer.getWeights();
            
            trajectory.W.push(weights[0].dataSync()[0]); 
            trajectory.B.push(weights[1].dataSync()[0]); 
            trajectory.Loss.push(logs.loss); 
        },
        onEpochEnd: (epoch, logs) => {
            document.getElementById('status').innerText = `${name} - Epoche ${epoch + 1}/${epochs}: Loss = ${logs.loss.toFixed(4)}`;
        }
    };
    
    await model.fit(xs, ys, {
        epochs: epochs,
        callbacks: callback,
        batchSize: N_DATA_POINTS 
    });

    model.dispose();
    optimizer.dispose();
    
    return trajectory;
}

// ***********************************************
// V. Plotting
// ***********************************************

function plot3D(optimizerName, landscape, trajectory) {
    const plotDivId = `plot-${optimizerName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;

    const plotContainer = document.getElementById('plot-container');
    const plotDiv = document.createElement('div');
    plotDiv.id = plotDivId;
    plotDiv.className = 'plot-div';
    plotContainer.appendChild(plotDiv);

    // 1. Loss-Landschaft (Surface)
    const surfaceTrace = {
        z: landscape.L,
        x: landscape.W,
        y: landscape.B, // y-Achse ist Bias (b)
        type: 'surface',
        name: 'Loss Landscape',
        showscale: true, // Zeige Farbskala, um Loss-Korrelation zu verdeutlichen
        opacity: 0.9,
        colorscale: 'Plasma', // Ändere auf eine kontrastreichere Skala
        surfacecolor: landscape.L, // Weise die Loss-Werte explizit als Farbe zu
        cmin: Math.min(...landscape.L.flat()), // Definiere den minimalen Farbwert
        cmax: Math.max(...landscape.L.flat()), // Definiere den maximalen Farbwert
    };

    // 2. Trajektorie (Scatter3D)
    const trajectoryTrace = {
        x: trajectory.W,
        y: trajectory.B,
        z: trajectory.Loss,
        type: 'scatter3d',
        mode: 'lines+markers',
        name: `${optimizerName} Trajectory`,
        marker: { size: 4, color: 'red', symbol: 'circle' },
        line: { width: 5, color: 'red' }
    };

    const data = [surfaceTrace, trajectoryTrace];

    const layout = {
        title: `${optimizerName} Loss-Landschaft & Trajektorie`,
        scene: {
            // NEU: Eindeutige Achsenbeschriftung W und B
            xaxis: { title: 'Gewicht (w)' }, 
            yaxis: { title: 'Bias (b)' }, // y-Achse ist Bias (b)
            zaxis: { title: 'Loss (MSE)', type: 'log' }, 
            camera: { 
                up: {x: 0, y: 0, z: 1},
                center: {x: 0, y: 0, z: 0},
                eye: {x: 1.5, y: 1.5, z: 1.5} // Etwas anderer Blickwinkel
            }
        },
        margin: { l: 0, r: 0, b: 0, t: 30 }
    };

    Plotly.newPlot(plotDivId, data, layout);
}

// ***********************************************
// VI. Experiment-Start
// ***********************************************

async function startExperiment() {
    const N = parseInt(document.getElementById('steps').value);
    const M = parseInt(document.getElementById('resolution').value);
    const EPOCHS = parseInt(document.getElementById('epochs').value);

    if (!N || !M || !EPOCHS) {
        alert("Bitte gültige Zahlen für die Parameter eingeben.");
        return;
    }

    document.getElementById('plot-container').innerHTML = '';
    document.getElementById('status').innerText = 'Experiment wird vorbereitet...';
    
    const initialModel = createSimpleModel();
    const initialWeights = initialModel.layers[0].getWeights();
    const initialW = initialWeights[0].dataSync()[0];
    const initialB = initialWeights[1].dataSync()[0];
    initialModel.dispose(); 

    document.getElementById('status').innerText = `Startgewichte: W = ${initialW.toFixed(4)}, B = ${initialB.toFixed(4)}. Berechne Loss-Landschaft...`;

    const landscape = computeLossLandscape(initialW, initialB, N, M);
    document.getElementById('status').innerText = 'Loss-Landschaft berechnet. Starte Training...';
    
    for (const name in OPTIMIZERS) {
        document.getElementById('status').innerText = `Starte Training für Optimierer: ${name}...`;
        
        const optimizer = OPTIMIZERS[name](); 

        const trajectory = await trainAndRecordTrajectory(name, optimizer, EPOCHS, initialW, initialB);
        
        plot3D(name, landscape, trajectory);
    }

    document.getElementById('status').innerText = 'Experiment abgeschlossen. Alle Plots sind generiert.';
}
</script>
</body>
</html>
