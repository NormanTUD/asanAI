<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>TFJS Loss-Landscape & Optimizer-Trajektorien</title>
    
    <script src="tf/tf.min.js"></script> 
    <script src="libs/plotly-latest.min.js"></script>
    
    <style>
        /* ======================================= */
        /* DARK MODE STYLES & LAYOUT */
        /* ======================================= */
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        h1 { color: #569cd6; margin-bottom: 5px;} 
        
        .controls { 
            margin: 20px 0; 
            padding: 15px; 
            border: 1px solid #3c3c3c; 
            border-radius: 8px; 
            background-color: #252526; 
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 95%; /* Kontrollblock auf volle Breite */
            max-width: 1200px;
        }
        .control-group { 
            display: flex; 
            flex-direction: column; 
            min-width: 150px;
        }
        input[type="number"], button, textarea {
            background-color: #333;
            border: 1px solid #444;
            color: #d4d4d4;
            padding: 5px;
            border-radius: 3px;
            margin-top: 5px;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
            font-family: monospace;
            font-size: 12px;
        }
        button {
            cursor: pointer;
            font-weight: bold;
            padding: 8px 15px;
        }
        #startButton {
            background-color: #007acc;
            border: none;
        }
        #startButton:hover {
            background-color: #005f99;
        }
        #stopButton {
            background-color: #cc4040;
            border: none;
            display: none; /* Initial versteckt */
        }
        #stopButton:hover {
            background-color: #a03030;
        }
        
        .optimizer-selection {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            padding: 5px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #1e1e1e;
        }
        .optimizer-selection label {
            display: flex;
            align-items: center;
        }

        #status {
            width: 95%;
            max-width: 1200px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #252526;
            border: 1px solid #3c3c3c; 
            border-radius: 4px;
        }

        /* Dynamische Plot-Gr√∂√üe */
        .plot-container { 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: flex-start; /* Links ausrichten */
            width: 95%; 
            max-width: 1200px;
        }
        .plot-div { 
            flex: 1 1 45%; /* L√§sst 2 Plots nebeneinander zu */
            min-width: 400px;
            height: 500px; /* Feste H√∂he, aber dynamische Breite */
            margin: 10px; 
            border: 1px solid #444; 
            border-radius: 8px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <h1>TFJS Loss-Landscape & Optimizer-Trajektorien</h1>

    <div class="controls">
        <div class="control-group">
            <h3>üî¢ Daten (x, y Paare)</h3>
            <label for="dataInput">x-Werte (kommagetrennt):</label>
            <textarea id="dataInput">0, 1, 2, 3, 4</textarea>
            <label for="dataOutput">y-Werte (kommagetrennt):</label>
            <textarea id="dataOutput">1.0, 3.0, 5.0, 7.0, 9.0</textarea>
        </div>

        <div class="control-group">
            <h3>‚öôÔ∏è Parameter</h3>
            <label for="learningRate">Lernrate (LR):</label>
            <input type="number" id="learningRate" value="0.01" min="0.0001" max="1" step="0.001">

            <label for="epochs">Epochen:</label>
            <input type="number" id="epochs" value="50" min="1" max="1000">

            <label for="steps">Puffer (N) f√ºr Landschaftsrand:</label>
            <input type="number" id="steps" value="1" min="0" max="10"> 
        </div>

        <div class="control-group">
            <h3>ü§ñ Optimizer</h3>
            <div id="optimizer-checkboxes" class="optimizer-selection">
                </div>
        </div>

        <div class="control-group" style="align-self: flex-end;">
            <button id="startButton" onclick="startExperiment()">Experiment starten</button>
            <button id="stopButton" onclick="stopExperiment()">Experiment stoppen</button>
        </div>
    </div>

    <div id="status">Bereit. Bitte starten Sie das Experiment.</div>

    <div class="plot-container" id="plot-container">
    </div>

<script>
    // ***********************************************
    // I. Globale Konfiguration & Zustand
    // ***********************************************
    
    const PLOT_DENSITY_STEP = 0.1; 
    const ALL_OPTIMIZERS = {
        'SGD': (lr) => tf.train.sgd(lr),
        'Momentum': (lr) => tf.train.momentum(lr, 0.9),
        'Adagrad': (lr) => tf.train.adagrad(lr),
        'Adadelta': (lr) => tf.train.adadelta(lr),
        'Adam': (lr) => tf.train.adam(lr),
        'Adamax': (lr) => tf.train.adamax(lr),
        'RMSProp': (lr) => tf.train.rmsprop(lr),
    };

    let experimentRunning = false;
    let stopRequested = false;


    // Funktion zum Parsen der Daten (jetzt dynamisch)
    function parseData() {
        try {
            const xStr = document.getElementById('dataInput').value;
            const yStr = document.getElementById('dataOutput').value;

            const xsArray = xStr.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
            const ysArray = yStr.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));

            if (xsArray.length !== ysArray.length || xsArray.length === 0) {
                throw new Error("X- und Y-Daten m√ºssen die gleiche Anzahl g√ºltiger Zahlen enthalten.");
            }

            // Wir erstellen die Tensoren hier und geben sie zur√ºck
            const xs = tf.tensor2d(xsArray.map(x => [x]));
            const ys = tf.tensor2d(ysArray.map(y => [y]));

            return { xs, ys, N_DATA_POINTS: xsArray.length };
        } catch (error) {
            document.getElementById('status').innerText = `Fehler beim Parsen der Daten: ${error.message}`;
            throw error;
        }
    }

    // Funktion zum Initialisieren der Optimizer-Checkboxen
    function initializeOptimizerCheckboxes() {
        const container = document.getElementById('optimizer-checkboxes');
        container.innerHTML = '';
        
        for (const name in ALL_OPTIMIZERS) {
            const id = `opt-${name}`;
            const label = document.createElement('label');

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = id;
            checkbox.name = 'optimizer';
            checkbox.value = name;
            
            if (['SGD', 'Adam', 'RMSProp'].includes(name)) {
                checkbox.checked = true;
            }

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(name));
            container.appendChild(label);
        }
    }
    window.onload = initializeOptimizerCheckboxes;
    
    // Window resize handler f√ºr dynamische Plots
    window.onresize = () => {
        const plotDivs = document.querySelectorAll('.plot-div');
        plotDivs.forEach(div => {
            Plotly.relayout(div.id, {
                width: div.clientWidth,
                height: div.clientHeight
            });
        });
    };


    // ***********************************************
    // II. Modell & Loss-Berechnung (Jetzt mit Daten-Parametern)
    // ***********************************************

    function createSimpleModel() {
        const model = tf.sequential();
        model.add(tf.layers.dense({
            units: 1,
            inputShape: [1], // Input-Shape ist immer [1] f√ºr dieses Problem
            kernelInitializer: tf.initializers.constant({ value: 0.1 }),
            biasInitializer: tf.initializers.constant({ value: -0.1 }),
        }));
        
        return model;
    }

    function calculateLoss(w, b, xs, ys, N_DATA_POINTS) {
        return tf.tidy(() => {
            const weights = tf.tensor2d([[w]]);
            const bias = tf.tensor1d([b]);

            const tempModel = createSimpleModel();
            tempModel.layers[0].setWeights([weights, bias]);
            
            tempModel.compile({ 
                optimizer: 'sgd', 
                loss: 'meanSquaredError' 
            });

            const lossTensor = tempModel.evaluate(xs, ys, { batchSize: N_DATA_POINTS, verbose: 0 });
            
            const loss = (Array.isArray(lossTensor)) ? lossTensor[0].dataSync()[0] : lossTensor.dataSync()[0];

            weights.dispose();
            bias.dispose();
            tempModel.dispose(); 

            return loss;
        });
    }

    // ***********************************************
    // III. Loss-Landscape Berechnung (Mit ETA)
    // ***********************************************

    function computeLossLandscape(minW, maxW, minB, maxB, N_buffer, xs, ys, N_DATA_POINTS) {
        return new Promise((resolve, reject) => {
            if (stopRequested) return reject(new Error("Experiment gestoppt."));

            const W_START = Math.floor(minW) - N_buffer;
            const W_END = Math.ceil(maxW) + N_buffer;
            const B_START = Math.floor(minB) - N_buffer;
            const B_END = Math.ceil(maxB) + N_buffer;

            const STEP_SIZE = PLOT_DENSITY_STEP; 

            const W_PLOT = [];
            for (let w = W_START; w <= W_END; w = parseFloat((w + STEP_SIZE).toFixed(2))) { 
                W_PLOT.push(w);
            }
            if (W_PLOT[W_PLOT.length - 1] < W_END) W_PLOT.push(W_END);
            
            const B_PLOT = [];
            for (let b = B_START; b <= B_END; b = parseFloat((b + STEP_SIZE).toFixed(2))) {
                B_PLOT.push(b);
            }
            if (B_PLOT[B_PLOT.length - 1] < B_END) B_PLOT.push(B_END);
            
            const L_PLOT = new Array(B_PLOT.length).fill(0).map(() => new Array(W_PLOT.length).fill(0));
            
            let totalPoints = W_PLOT.length * B_PLOT.length;
            let currentPoint = 0;
            const startTime = performance.now();

            const processChunk = () => {
                const chunkSize = 1000; 
                let chunkEnd = currentPoint + chunkSize;

                for (let k = currentPoint; k < chunkEnd && k < totalPoints; k++) {
                    if (stopRequested) return reject(new Error("Experiment gestoppt."));

                    const i = Math.floor(k / W_PLOT.length);
                    const j = k % W_PLOT.length;

                    const w = W_PLOT[j];
                    const b = B_PLOT[i];
                    // Daten-Tensoren werden √ºbergeben
                    L_PLOT[i][j] = calculateLoss(w, b, xs, ys, N_DATA_POINTS);
                    currentPoint++;
                }

                if (currentPoint < totalPoints) {
                    const elapsedTime = (performance.now() - startTime) / 1000;
                    const pointsPerSecond = currentPoint / elapsedTime;
                    const remainingPoints = totalPoints - currentPoint;
                    const etaSeconds = remainingPoints / pointsPerSecond;
                    const etaString = new Date(etaSeconds * 1000).toISOString().substring(11, 19);

                    document.getElementById('status').innerHTML = `
                        Berechne Loss-Landschaft: ${currentPoint}/${totalPoints} Punkte
                        (${Math.floor((currentPoint / totalPoints) * 100)}%) | ETA: ${etaString}
                    `;
                    setTimeout(processChunk, 10); // Nicht-blockierende Verz√∂gerung
                } else {
                    document.getElementById('status').innerText = 'Loss-Landschaft berechnet. Starte Plotten...';
                    resolve({ W: W_PLOT, B: B_PLOT, L: L_PLOT });
                }
            };

            processChunk();
        });
    }

    // ***********************************************
    // IV. Training und Trajektorie (Mit Stop-Check)
    // ***********************************************

    async function trainAndRecordTrajectory(name, optimizer, epochs, xs, ys, N_DATA_POINTS) {
        if (stopRequested) throw new Error("Experiment gestoppt.");

        const model = createSimpleModel();
        model.compile({ optimizer: optimizer, loss: 'meanSquaredError' });

        const trajectory = { W: [], B: [], Loss: [] };

        const customCallback = new tf.CustomCallback({
            onBatchEnd: (batch, logs) => {
                if (stopRequested) {
                     model.stopTraining = true;
                     return;
                }
                
                tf.tidy(() => {
                    const layer = model.layers[0];
                    const weights = layer.getWeights();
                    
                    const w_val = weights[0].dataSync()[0]; 
                    const b_val = weights[1].dataSync()[0]; 
                    
                    // Messen des Loss mit der exakten Funktion der Oberfl√§che
                    const measuredLoss = calculateLoss(w_val, b_val, xs, ys, N_DATA_POINTS); 

                    trajectory.W.push(w_val);
                    trajectory.B.push(b_val);
                    trajectory.Loss.push(measuredLoss); 
                });
            },
            onEpochEnd: (epoch, logs) => {
                document.getElementById('status').innerText = `${name} - Epoche ${epoch + 1}/${epochs}: Loss = ${logs.loss.toFixed(4)}`;
            }
        });
        
        await model.fit(xs, ys, {
            epochs: epochs,
            callbacks: [customCallback],
            batchSize: N_DATA_POINTS,
            verbose: 0 
        });

        model.dispose();
        
        if (stopRequested) throw new Error("Experiment gestoppt.");
        
        return trajectory;
    }

    // ***********************************************
    // V. Plotting (Dynamisch und korrekte Achsen)
    // ***********************************************

    function plot3D(optimizerName, landscape, trajectory) {
        const plotDivId = `plot-${optimizerName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;

        const plotContainer = document.getElementById('plot-container');
        const plotDiv = document.createElement('div');
        plotDiv.id = plotDivId;
        plotDiv.className = 'plot-div';
        plotContainer.appendChild(plotDiv);

        const minLoss = Math.min(...landscape.L.flat());
        const maxLoss = Math.max(...landscape.L.flat());

        const surfaceTrace = {
            z: landscape.L,
            x: landscape.W,
            y: landscape.B,
            type: 'surface',
            name: 'Loss Landscape',
            showscale: true,
            opacity: 0.9,
            colorscale: 'Plasma', 
            surfacecolor: landscape.L, 
            cmin: minLoss, 
            cmax: maxLoss, 
        };

        const trajectoryTrace = {
            x: trajectory.W,
            y: trajectory.B,
            z: trajectory.Loss,
            type: 'scatter3d',
            mode: 'lines+markers',
            name: `${optimizerName} Trajectory`,
            marker: { size: 4, color: 'red', symbol: 'circle' },
            line: { width: 5, color: 'red' }
        };

        const data = [surfaceTrace, trajectoryTrace];

        const layout = {
            title: { 
                text: `${optimizerName} Loss-Landschaft & Trajektorie`,
                font: { color: '#d4d4d4' } 
            },
            // Transparenter Hintergrund
            paper_bgcolor: 'rgba(0,0,0,0)', 
            plot_bgcolor: 'rgba(0,0,0,0)', 
            
            scene: {
                // Korrekte Achsenbeschriftung
                xaxis: { title: 'Weight (w)', backgroundcolor: '#333', gridcolor: '#444', zerolinecolor: '#777', tickfont: { color: '#d4d4d4' }, titlefont: { color: '#d4d4d4' } }, 
                yaxis: { title: 'Bias (b)', backgroundcolor: '#333', gridcolor: '#444', zerolinecolor: '#777', tickfont: { color: '#d4d4d4' }, titlefont: { color: '#d4d4d4' } }, 
                zaxis: { title: 'Loss (MSE, log)', type: 'log', backgroundcolor: '#333', gridcolor: '#444', zerolinecolor: '#777', tickfont: { color: '#d4d4d4' }, titlefont: { color: '#d4d4d4' } }, 
                camera: { 
                    up: {x: 0, y: 0, z: 1},
                    center: {x: 0, y: 0, z: 0},
                    eye: {x: 1.5, y: 1.5, z: 1.5}
                }
            },
            margin: { l: 0, r: 0, b: 0, t: 30 }
        };

        Plotly.newPlot(plotDivId, data, layout, {responsive: true});
        
        // Initialer Resize, um volle Breite zu gew√§hrleisten
        window.dispatchEvent(new Event('resize')); 
    }

    // ***********************************************
    // VI. Experiment-Start / Stop Logik
    // ***********************************************

    function setUIState(running) {
        experimentRunning = running;
        document.getElementById('startButton').style.display = running ? 'none' : 'block';
        document.getElementById('stopButton').style.display = running ? 'block' : 'none';
        // Deaktiviere alle Kontrollen w√§hrend der Ausf√ºhrung, au√üer dem Stop-Button
        document.querySelectorAll('.controls input, .controls textarea, .controls button:not(#stopButton)').forEach(el => el.disabled = running);
    }

    function stopExperiment() {
        stopRequested = true;
        document.getElementById('status').innerText = 'Stopp-Anforderung gesendet. Warte auf Ende der aktuellen Operation...';
    }

    async function startExperiment() {
        if (experimentRunning) return;
        setUIState(true);
        stopRequested = false;

        document.getElementById('plot-container').innerHTML = '';
        
        // KORREKTUR: data muss hier deklariert werden, damit es in 'finally' sichtbar ist.
        let data = null; 

        try {
            // 1. Daten und Parameter auslesen
            data = parseData(); // Zuweisung zur function-scoped Variable
            
            const N_buffer = parseInt(document.getElementById('steps').value);
            const EPOCHS = parseInt(document.getElementById('epochs').value);
            const LEARNING_RATE = parseFloat(document.getElementById('learningRate').value);

            const selectedOptimizers = Array.from(document.querySelectorAll('input[name="optimizer"]:checked'))
                                           .map(checkbox => checkbox.value);
            
            if (selectedOptimizers.length === 0) {
                document.getElementById('status').innerText = "Bitte w√§hlen Sie mindestens einen Optimizer aus.";
                setUIState(false);
                return;
            }

            document.getElementById('status').innerText = 'Experiment wird vorbereitet... Starte alle Trainingsl√§ufe.';
            
            let allTrajectories = {};
            let allW = [];
            let allB = [];
            
            // F√ºge Startwerte als Basis hinzu
            const initialModel = createSimpleModel();
            const initialWeights = initialModel.layers[0].getWeights();
            const initialW = initialWeights[0].dataSync()[0];
            const initialB = initialWeights[1].dataSync()[0];
            initialModel.dispose(); 
            
            allW.push(initialW);
            allB.push(initialB);

            // 2. Training durchf√ºhren
            for (const name of selectedOptimizers) {
                if (stopRequested) throw new Error("Experiment gestoppt.");
                document.getElementById('status').innerText = `Starte Training f√ºr Optimierer: ${name}...`;
                
                const optimizer = ALL_OPTIMIZERS[name](LEARNING_RATE); 
                const trajectory = await trainAndRecordTrajectory(name, optimizer, EPOCHS, data.xs, data.ys, data.N_DATA_POINTS); 
                
                allTrajectories[name] = trajectory;
                
                allW.push(...trajectory.W);
                allB.push(...trajectory.B);
            }

            if (stopRequested) throw new Error("Experiment gestoppt.");

            // 3. Dynamischen Bereich bestimmen
            const minW = Math.min(...allW);
            const maxW = Math.max(...allW);
            const minB = Math.min(...allB);
            const maxB = Math.max(...allB);

            // 4. Loss-Landschaft berechnen (mit ETA-Logging)
            const landscape = await computeLossLandscape(minW, maxW, minB, maxB, N_buffer, data.xs, data.ys, data.N_DATA_POINTS); 
            
            if (stopRequested) throw new Error("Experiment gestoppt.");

            // 5. Plotten
            document.getElementById('status').innerText = 'Loss-Landschaft berechnet. Generiere Plots...';
            for (const name in allTrajectories) {
                plot3D(name, landscape, allTrajectories[name]);
            }

            document.getElementById('status').innerText = 'Experiment abgeschlossen. Alle Plots sind generiert.';

        } catch (error) {
            if (error.message === "Experiment gestoppt.") {
                document.getElementById('status').innerText = 'Experiment wurde erfolgreich gestoppt.';
            } else {
                console.error(error);
                // Zeigt Fehlermeldung, wenn Fehler auftritt (z.B. parseData Fehler)
                document.getElementById('status').innerText = `FEHLER: ${error.message}`; 
            }
        } finally {
            setUIState(false);
            // Speicher bereinigen (nur wenn data erfolgreich geparst wurde)
            if (data && data.xs) {
                data.xs.dispose();
                data.ys.dispose();
            }
        }
    }
</script>
</body>
</html>
