<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>TFJS Loss-Landscape & Optimizer-Trajektorien</title>
    
    <script src="tf/tf.min.js"></script> 
    <script src="libs/plotly-latest.min.js"></script>
    
    <style>
        /* ======================================= */
        /* DARK MODE STYLES & LAYOUT */
        /* ======================================= */
        body { 
            font-family: Arial, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            background-color: #1e1e1e; /* Dunkler Hintergrund */
            color: #d4d4d4; /* Helle Schrift */
        }
        h1 { color: #569cd6; } /* Blauer Titel */
        
        .controls { 
            margin: 20px; 
            padding: 15px; 
            border: 1px solid #3c3c3c; 
            border-radius: 8px; 
            background-color: #252526; 
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .control-group { 
            display: flex; 
            flex-direction: column; 
        }
        input[type="number"], button {
            background-color: #333;
            border: 1px solid #444;
            color: #d4d4d4;
            padding: 5px;
            border-radius: 3px;
        }
        button {
            cursor: pointer;
            background-color: #007acc;
            border: none;
            font-weight: bold;
            padding: 8px 15px;
            margin-top: 10px;
        }
        button:hover {
            background-color: #005f99;
        }
        
        .optimizer-selection {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            max-width: 300px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #1e1e1e;
        }

        .plot-container { 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            width: 95%; 
        }
        .plot-div { 
            width: 450px; 
            height: 450px; 
            margin: 10px; 
            border: 1px solid #444; 
            border-radius: 8px;
            overflow: hidden; /* F√ºr sauberen Rand */
        }
    </style>
</head>
<body>
    <h1>TFJS Loss-Landscape & Optimizer-Trajektorien</h1>

    <div class="controls">
        <div class="control-group">
            <h3>‚öôÔ∏è Parameter</h3>
            <label for="learningRate">Lernrate (LR):</label>
            <input type="number" id="learningRate" value="0.01" min="0.0001" max="1" step="0.001">

            <label for="epochs">Epochen f√ºr Training:</label>
            <input type="number" id="epochs" value="50" min="1" max="1000">

            <label for="steps">Puffer (N) f√ºr Landschaftsrand:</label>
            <input type="number" id="steps" value="1" min="0" max="10"> 
        </div>

        <div class="control-group">
            <h3>ü§ñ Optimizer-Vergleich</h3>
            <div id="optimizer-checkboxes" class="optimizer-selection">
                </div>
        </div>

        <div class="control-group" style="align-self: flex-end;">
            <button onclick="startExperiment()">Experiment starten</button>
        </div>
    </div>

    <div id="status">Bereit. Bitte starten Sie das Experiment.</div>

    <div class="plot-container" id="plot-container">
    </div>

<script>
    // ***********************************************
    // I. Globale Konfiguration & Daten
    // ***********************************************
    
    // Feste Dichte f√ºr die Oberfl√§che, um sicherzustellen, dass gen√ºgend Punkte geplottet werden.
    const PLOT_DENSITY_STEP = 0.1; 

    // Alle verf√ºgbaren Optimizer
    const ALL_OPTIMIZERS = {
        'SGD': (lr) => tf.train.sgd(lr),
        'Momentum': (lr) => tf.train.momentum(lr, 0.9),
        'Adagrad': (lr) => tf.train.adagrad(lr),
        'Adadelta': (lr) => tf.train.adadelta(lr),
        'Adam': (lr) => tf.train.adam(lr),
        'Adamax': (lr) => tf.train.adamax(lr),
        'RMSProp': (lr) => tf.train.rmsprop(lr),
    };

    // Daten f√ºr y = 2x + 1.0 
    const dataConfig = {
        inputShape: [1],
        outputShape: [1],
        data: [
            { x: 0, y: 1.0 },
            { x: 1, y: 3.0 },
            { x: 2, y: 5.0 },
            { x: 3, y: 7.0 },
            { x: 4, y: 9.0 },
        ]
    };

    const xs = tf.tensor2d(dataConfig.data.map(d => [d.x]));
    const ys = tf.tensor2d(dataConfig.data.map(d => [d.y]));
    const N_DATA_POINTS = dataConfig.data.length;


    // Funktion zum Initialisieren der Optimizer-Checkboxen
    function initializeOptimizerCheckboxes() {
        const container = document.getElementById('optimizer-checkboxes');
        container.innerHTML = '';
        
        for (const name in ALL_OPTIMIZERS) {
            const id = `opt-${name}`;
            const label = document.createElement('label');
            label.setAttribute('for', id);
            label.style.display = 'flex';
            label.style.alignItems = 'center';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = id;
            checkbox.name = 'optimizer';
            checkbox.value = name;
            
            // W√§hle standardm√§√üig SGD, Adam und RMSProp aus
            if (['SGD', 'Adam', 'RMSProp'].includes(name)) {
                checkbox.checked = true;
            }

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(name));
            container.appendChild(label);
        }
    }
    window.onload = initializeOptimizerCheckboxes;


    // ***********************************************
    // II. Modell & Loss-Berechnung (Unver√§ndert)
    // ***********************************************

    function createSimpleModel() {
        const model = tf.sequential();
        model.add(tf.layers.dense({
            units: 1,
            inputShape: dataConfig.inputShape,
            kernelInitializer: tf.initializers.constant({ value: 0.1 }),
            biasInitializer: tf.initializers.constant({ value: -0.1 }),
        }));
        
        return model;
    }

    /**
     * Berechnet den Loss f√ºr gegebene Gewichte (w und b) ‚Äì DIESE FUNKTION DEFINIERT DIE SURFACE.
     */
    function calculateLoss(w, b) {
        return tf.tidy(() => {
            const weights = tf.tensor2d([[w]]);
            const bias = tf.tensor1d([b]);

            const tempModel = createSimpleModel();
            tempModel.layers[0].setWeights([weights, bias]);
            
            tempModel.compile({ 
                optimizer: 'sgd', 
                loss: 'meanSquaredError' 
            });

            const lossTensor = tempModel.evaluate(xs, ys, { batchSize: N_DATA_POINTS, verbose: 0 });
            
            const loss = (Array.isArray(lossTensor)) ? lossTensor[0].dataSync()[0] : lossTensor.dataSync()[0];

            weights.dispose();
            bias.dispose();
            tempModel.dispose(); 

            return loss;
        });
    }

    // ***********************************************
    // III. Loss-Landscape Berechnung
    // ***********************************************

    function computeLossLandscape(minW, maxW, minB, maxB, N_buffer) {
        // Runden der Grenzen auf die n√§chste Ganzzahl und Puffer hinzuf√ºgen
        const W_START = Math.floor(minW) - N_buffer;
        const W_END = Math.ceil(maxW) + N_buffer;
        const B_START = Math.floor(minB) - N_buffer;
        const B_END = Math.ceil(maxB) + N_buffer;

        const STEP_SIZE = PLOT_DENSITY_STEP; 

        const W_PLOT = [];
        for (let w = W_START; w <= W_END; w = parseFloat((w + STEP_SIZE).toFixed(2))) { // Fix for floating point precision
            W_PLOT.push(w);
        }
        
        const B_PLOT = [];
        for (let b = B_START; b <= B_END; b = parseFloat((b + STEP_SIZE).toFixed(2))) { // Fix for floating point precision
            B_PLOT.push(b);
        }
        
        const L_PLOT = new Array(B_PLOT.length).fill(0).map(() => new Array(W_PLOT.length).fill(0));
        
        let totalPoints = W_PLOT.length * B_PLOT.length;
        let currentPoint = 0;
        document.getElementById('status').innerText = `Berechne dynamische Loss-Landschaft (${totalPoints} Punkte)...`;
        
        // Die Berechnung ist CPU-intensiv.
        for (let i = 0; i < B_PLOT.length; i++) { 
            for (let j = 0; j < W_PLOT.length; j++) { 
                const w = W_PLOT[j];
                const b = B_PLOT[i];
                L_PLOT[i][j] = calculateLoss(w, b);
                currentPoint++;
                if (currentPoint % 100 === 0) { 
                    document.getElementById('status').innerText = `Berechne dynamische Loss-Landschaft: ${Math.floor((currentPoint / totalPoints) * 100)}%`;
                }
            }
        }
        document.getElementById('status').innerText = `Berechne dynamische Loss-Landschaft: 100%`;

        return { W: W_PLOT, B: B_PLOT, L: L_PLOT };
    }


    // ***********************************************
    // IV. Training und Trajektorie
    // ***********************************************

    async function trainAndRecordTrajectory(name, optimizer, epochs) {
        const model = createSimpleModel();
        model.compile({ optimizer: optimizer, loss: 'meanSquaredError' });

        const trajectory = { W: [], B: [], Loss: [] };

        const customCallback = new tf.CustomCallback({
            onBatchEnd: (batch, logs) => {
                tf.tidy(() => {
                    const layer = model.layers[0];
                    const weights = layer.getWeights();
                    
                    const w_val = weights[0].dataSync()[0]; 
                    const b_val = weights[1].dataSync()[0]; 
                    
                    // Messen des Loss mit der exakten Funktion der Oberfl√§che
                    const measuredLoss = calculateLoss(w_val, b_val); 

                    trajectory.W.push(w_val);
                    trajectory.B.push(b_val);
                    trajectory.Loss.push(measuredLoss); 
                });
            },
            onEpochEnd: (epoch, logs) => {
                document.getElementById('status').innerText = `${name} - Epoche ${epoch + 1}/${epochs}: Loss = ${logs.loss.toFixed(4)}`;
            }
        });
        
        await model.fit(xs, ys, {
            epochs: epochs,
            callbacks: [customCallback],
            batchSize: N_DATA_POINTS,
            verbose: 0 
        });

        model.dispose();
        optimizer.dispose();
        
        return trajectory;
    }

    // ***********************************************
    // V. Plotting (KORRIGIERT: Transparenter Background, Achsentitel)
    // ***********************************************

    function plot3D(optimizerName, landscape, trajectory) {
        const plotDivId = `plot-${optimizerName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;

        const plotContainer = document.getElementById('plot-container');
        const plotDiv = document.createElement('div');
        plotDiv.id = plotDivId;
        plotDiv.className = 'plot-div';
        plotContainer.appendChild(plotDiv);

        const minLoss = Math.min(...landscape.L.flat());
        const maxLoss = Math.max(...landscape.L.flat());

        // 1. Loss-Landschaft (Surface)
        const surfaceTrace = {
            z: landscape.L,
            x: landscape.W,
            y: landscape.B,
            type: 'surface',
            name: 'Loss Landscape',
            showscale: true,
            opacity: 0.9,
            colorscale: 'Plasma', 
            surfacecolor: landscape.L, 
            cmin: minLoss, 
            cmax: maxLoss, 
        };

        // 2. Trajektorie (Scatter3D)
        const trajectoryTrace = {
            x: trajectory.W,
            y: trajectory.B,
            z: trajectory.Loss,
            type: 'scatter3d',
            mode: 'lines+markers',
            name: `${optimizerName} Trajectory`,
            marker: { size: 4, color: 'red', symbol: 'circle' },
            line: { width: 5, color: 'red' }
        };

        const data = [surfaceTrace, trajectoryTrace];

        const layout = {
            title: { 
                text: `${optimizerName} Loss-Landschaft & Trajektorie`,
                font: { color: '#d4d4d4' } // Titel im Dark Mode
            },
            // Hintergrund auf Transparent f√ºr Dark Mode
            paper_bgcolor: 'rgba(0,0,0,0)', 
            plot_bgcolor: 'rgba(0,0,0,0)', 
            
            scene: {
                // Achsen-Titel und Farbe f√ºr Dark Mode
                xaxis: { title: 'Gewicht (w)', backgroundcolor: '#333', gridcolor: '#444', zerolinecolor: '#777', tickfont: { color: '#d4d4d4' }, titlefont: { color: '#d4d4d4' } }, 
                yaxis: { title: 'Bias (b)', backgroundcolor: '#333', gridcolor: '#444', zerolinecolor: '#777', tickfont: { color: '#d4d4d4' }, titlefont: { color: '#d4d4d4' } }, 
                zaxis: { title: 'Loss (MSE, log)', type: 'log', backgroundcolor: '#333', gridcolor: '#444', zerolinecolor: '#777', tickfont: { color: '#d4d4d4' }, titlefont: { color: '#d4d4d4' } }, 
                camera: { 
                    up: {x: 0, y: 0, z: 1},
                    center: {x: 0, y: 0, z: 0},
                    eye: {x: 1.5, y: 1.5, z: 1.5}
                }
            },
            margin: { l: 0, r: 0, b: 0, t: 30 }
        };

        Plotly.newPlot(plotDivId, data, layout, {responsive: true});
    }

    // ***********************************************
    // VI. Experiment-Start (Interaktivit√§t integriert)
    // ***********************************************

    async function startExperiment() {
        // Lese die globalen Parameter aus
        const N_buffer = parseInt(document.getElementById('steps').value);
        const EPOCHS = parseInt(document.getElementById('epochs').value);
        const LEARNING_RATE = parseFloat(document.getElementById('learningRate').value);

        if (!N_buffer || !EPOCHS || !LEARNING_RATE) {
            alert("Bitte g√ºltige Zahlen f√ºr die Parameter eingeben.");
            return;
        }

        // Finde die ausgew√§hlten Optimizer
        const selectedOptimizers = Array.from(document.querySelectorAll('input[name="optimizer"]:checked'))
                                       .map(checkbox => checkbox.value);
        
        if (selectedOptimizers.length === 0) {
            alert("Bitte w√§hlen Sie mindestens einen Optimizer aus.");
            return;
        }

        document.getElementById('plot-container').innerHTML = '';
        document.getElementById('status').innerText = 'Experiment wird vorbereitet... Starte alle Trainingsl√§ufe.';
        
        let allTrajectories = {};
        let allW = [];
        let allB = [];
        
        // F√ºge Startwerte als Basis hinzu
        const initialModel = createSimpleModel();
        const initialWeights = initialModel.layers[0].getWeights();
        const initialW = initialWeights[0].dataSync()[0];
        const initialB = initialWeights[1].dataSync()[0];
        initialModel.dispose(); 
        
        allW.push(initialW);
        allB.push(initialB);

        // F√ºhre nur das Training f√ºr die ausgew√§hlten Optimizer durch
        for (const name of selectedOptimizers) {
            document.getElementById('status').innerText = `Starte Training f√ºr Optimierer: ${name}...`;
            
            // Erstelle den Optimizer mit der eingestellten Lernrate
            const optimizer = ALL_OPTIMIZERS[name](LEARNING_RATE); 
            const trajectory = await trainAndRecordTrajectory(name, optimizer, EPOCHS); 
            
            allTrajectories[name] = trajectory;
            
            allW.push(...trajectory.W);
            allB.push(...trajectory.B);
        }

        // 2. Bestimme den globalen Min/Max-Bereich
        const minW = Math.min(...allW);
        const maxW = Math.max(...allW);
        const minB = Math.min(...allB);
        const maxB = Math.max(...allB);

        document.getElementById('status').innerText = 'Alle Trainings abgeschlossen. Berechne dynamische Loss-Landschaft...';

        // 3. Berechne die Loss-Landschaft basierend auf dem globalen Bereich
        const landscape = computeLossLandscape(minW, maxW, minB, maxB, N_buffer); 
        document.getElementById('status').innerText = 'Loss-Landschaft berechnet. Generiere Plots...';
        
        // 4. Plotten Sie jede Trajektorie auf der gemeinsamen Landschaft
        for (const name in allTrajectories) {
            plot3D(name, landscape, allTrajectories[name]);
        }

        document.getElementById('status').innerText = 'Experiment abgeschlossen. Alle Plots sind generiert.';
    }
</script>
</body>
</html>
